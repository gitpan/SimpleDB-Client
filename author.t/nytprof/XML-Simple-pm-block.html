    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml">
<!--
This file was generated by Devel::NYTProf version 3.11
-->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Language" content="en-us" />
    <title>Profile of /usr/local/lib/perl5/site_perl/5.10.1/XML/Simple.pm</title>
<link rel="stylesheet" type="text/css" href="style.css" />
    <script type="text/javascript" src="js/jquery-min.js"></script> 

    <script type="text/javascript" src="js/jquery-tablesorter-min.js"></script> 
    <link rel="stylesheet" type="text/css" href="js/style-tablesorter.css" />
    <script type="text/javascript">
    // when a column is first clicked on to sort it, use descending order
    // XXX doesn't seem to work (and not just because the tablesorter formatSortingOrder() is broken)
    $.tablesorter.defaults.sortInitialOrder = "desc";
    // add parser through the tablesorter addParser method 
    $.tablesorter.addParser({
        id: 'fmt_time',   // name of this parser
        is: function(s) { 
            return false; // return false so this parser is not auto detected 
        }, 
        format: function(orig) { // format data for normalization 
            // console.log(orig);
            val = orig.replace(/ns/,'');
            if (val != orig) { return val / (1000*1000*1000); } 
            val = orig.replace(/Âµs/,''); /* XXX use &micro; ? */
            if (val != orig) { return val / (1000*1000); } 
            var val = orig.replace(/ms/,'');
            if (val != orig) { return val / (1000); }
            var val = orig.replace(/s/,'');
            if (val != orig) { return val; }
            if (orig == '0') { return orig; } 
            console.log('no match for fmt_time of '.concat(orig));
            return orig;
        },
        type: 'numeric' // set type, either numeric or text 
    }); 
    </script> 
</head>
<body > 
<div class="header" style="position: relative; overflow-x: hidden; overflow-y: hidden; z-index: 0; ">
<div class="header_back">
            <a href="index.html">&larr; Index</a>
        </div>
<div class="headerForeground" style="float: left">
    <span class="siteTitle">NYTProf Performance Profile</span>
    <span class="siteSubtitle">&emsp;&emsp;<span>&laquo;&emsp;<span class="mode_btn mode_btn_selected">block view</span>&emsp;&bull;&emsp;<span class="mode_btn"><a href="XML-Simple-pm-line.html">line view</a></span>&emsp;&bull;&emsp;<span class="mode_btn"><a href="XML-Simple-pm-sub.html">sub view</a></span>&emsp;&raquo;</span><br />
            For 01.HTTP.t
        </span>
</div>
<div class="headerForeground" style="float: right; text-align: right">
    <span class="siteTitle">&nbsp;</span>
    <span class="siteSubtitle">Run on Tue May  4 14:17:45 2010<br />Reported on Tue May  4 14:18:07 2010</span>
</div>
<div style="position: absolute; left: 0px; top: 0%; width: 100%; height: 101%; z-index: -1; background-color: rgb(17, 136, 255); "></div>
<div style="position: absolute; left: 0px; top: 2%; width: 100%; height: 99%; z-index: -1; background-color: rgb(16, 134, 253); "></div>
<div style="position: absolute; left: 0px; top: 4%; width: 100%; height: 97%; z-index: -1; background-color: rgb(16, 133, 252); "></div>
<div style="position: absolute; left: 0px; top: 6%; width: 100%; height: 95%; z-index: -1; background-color: rgb(15, 131, 250); "></div>
<div style="position: absolute; left: 0px; top: 8%; width: 100%; height: 93%; z-index: -1; background-color: rgb(15, 130, 249); "></div>
<div style="position: absolute; left: 0px; top: 10%; width: 100%; height: 91%; z-index: -1; background-color: rgb(15, 129, 248); "></div>
<div style="position: absolute; left: 0px; top: 12%; width: 100%; height: 89%; z-index: -1; background-color: rgb(14, 127, 246); "></div>
<div style="position: absolute; left: 0px; top: 14%; width: 100%; height: 87%; z-index: -1; background-color: rgb(14, 126, 245); "></div>
<div style="position: absolute; left: 0px; top: 16%; width: 100%; height: 85%; z-index: -1; background-color: rgb(14, 125, 244); "></div>
<div style="position: absolute; left: 0px; top: 18%; width: 100%; height: 83%; z-index: -1; background-color: rgb(13, 123, 242); "></div>
<div style="position: absolute; left: 0px; top: 20%; width: 100%; height: 81%; z-index: -1; background-color: rgb(13, 122, 241); "></div>
<div style="position: absolute; left: 0px; top: 22%; width: 100%; height: 79%; z-index: -1; background-color: rgb(13, 121, 240); "></div>
<div style="position: absolute; left: 0px; top: 24%; width: 100%; height: 77%; z-index: -1; background-color: rgb(12, 119, 238); "></div>
<div style="position: absolute; left: 0px; top: 26%; width: 100%; height: 75%; z-index: -1; background-color: rgb(12, 118, 237); "></div>
<div style="position: absolute; left: 0px; top: 28%; width: 100%; height: 73%; z-index: -1; background-color: rgb(12, 116, 235); "></div>
<div style="position: absolute; left: 0px; top: 30%; width: 100%; height: 71%; z-index: -1; background-color: rgb(11, 115, 234); "></div>
<div style="position: absolute; left: 0px; top: 32%; width: 100%; height: 69%; z-index: -1; background-color: rgb(11, 114, 233); "></div>
<div style="position: absolute; left: 0px; top: 34%; width: 100%; height: 67%; z-index: -1; background-color: rgb(11, 112, 231); "></div>
<div style="position: absolute; left: 0px; top: 36%; width: 100%; height: 65%; z-index: -1; background-color: rgb(10, 111, 230); "></div>
<div style="position: absolute; left: 0px; top: 38%; width: 100%; height: 63%; z-index: -1; background-color: rgb(10, 110, 229); "></div>
<div style="position: absolute; left: 0px; top: 40%; width: 100%; height: 61%; z-index: -1; background-color: rgb(10, 108, 227); "></div>
<div style="position: absolute; left: 0px; top: 42%; width: 100%; height: 59%; z-index: -1; background-color: rgb(9, 107, 226); "></div>
<div style="position: absolute; left: 0px; top: 44%; width: 100%; height: 57%; z-index: -1; background-color: rgb(9, 106, 225); "></div>
<div style="position: absolute; left: 0px; top: 46%; width: 100%; height: 55%; z-index: -1; background-color: rgb(9, 104, 223); "></div>
<div style="position: absolute; left: 0px; top: 48%; width: 100%; height: 53%; z-index: -1; background-color: rgb(8, 103, 222); "></div>
<div style="position: absolute; left: 0px; top: 50%; width: 100%; height: 51%; z-index: -1; background-color: rgb(8, 102, 221); "></div>
<div style="position: absolute; left: 0px; top: 52%; width: 100%; height: 49%; z-index: -1; background-color: rgb(8, 100, 219); "></div>
<div style="position: absolute; left: 0px; top: 54%; width: 100%; height: 47%; z-index: -1; background-color: rgb(7, 99, 218); "></div>
<div style="position: absolute; left: 0px; top: 56%; width: 100%; height: 45%; z-index: -1; background-color: rgb(7, 97, 216); "></div>
<div style="position: absolute; left: 0px; top: 58%; width: 100%; height: 43%; z-index: -1; background-color: rgb(7, 96, 215); "></div>
<div style="position: absolute; left: 0px; top: 60%; width: 100%; height: 41%; z-index: -1; background-color: rgb(6, 95, 214); "></div>
<div style="position: absolute; left: 0px; top: 62%; width: 100%; height: 39%; z-index: -1; background-color: rgb(6, 93, 212); "></div>
<div style="position: absolute; left: 0px; top: 64%; width: 100%; height: 37%; z-index: -1; background-color: rgb(6, 92, 211); "></div>
<div style="position: absolute; left: 0px; top: 66%; width: 100%; height: 35%; z-index: -1; background-color: rgb(5, 91, 210); "></div>
<div style="position: absolute; left: 0px; top: 68%; width: 100%; height: 33%; z-index: -1; background-color: rgb(5, 89, 208); "></div>
<div style="position: absolute; left: 0px; top: 70%; width: 100%; height: 31%; z-index: -1; background-color: rgb(5, 88, 207); "></div>
<div style="position: absolute; left: 0px; top: 72%; width: 100%; height: 29%; z-index: -1; background-color: rgb(4, 87, 206); "></div>
<div style="position: absolute; left: 0px; top: 74%; width: 100%; height: 27%; z-index: -1; background-color: rgb(4, 85, 204); "></div>
<div style="position: absolute; left: 0px; top: 76%; width: 100%; height: 25%; z-index: -1; background-color: rgb(4, 84, 203); "></div>
<div style="position: absolute; left: 0px; top: 78%; width: 100%; height: 23%; z-index: -1; background-color: rgb(3, 82, 201); "></div>
<div style="position: absolute; left: 0px; top: 80%; width: 100%; height: 21%; z-index: -1; background-color: rgb(3, 81, 200); "></div>
<div style="position: absolute; left: 0px; top: 82%; width: 100%; height: 19%; z-index: -1; background-color: rgb(3, 80, 199); "></div>
<div style="position: absolute; left: 0px; top: 84%; width: 100%; height: 17%; z-index: -1; background-color: rgb(2, 78, 197); "></div>
<div style="position: absolute; left: 0px; top: 86%; width: 100%; height: 15%; z-index: -1; background-color: rgb(2, 77, 196); "></div>
<div style="position: absolute; left: 0px; top: 88%; width: 100%; height: 13%; z-index: -1; background-color: rgb(2, 76, 195); "></div>
<div style="position: absolute; left: 0px; top: 90%; width: 100%; height: 11%; z-index: -1; background-color: rgb(1, 74, 193); "></div>
<div style="position: absolute; left: 0px; top: 92%; width: 100%; height: 9%; z-index: -1; background-color: rgb(1, 73, 192); "></div>
<div style="position: absolute; left: 0px; top: 94%; width: 100%; height: 7%; z-index: -1; background-color: rgb(1, 72, 191); "></div>
<div style="position: absolute; left: 0px; top: 96%; width: 100%; height: 5%; z-index: -1; background-color: rgb(0, 70, 189); "></div>
<div style="position: absolute; left: 0px; top: 98%; width: 100%; height: 3%; z-index: -1; background-color: rgb(0, 69, 188); "></div>
<div style="position: absolute; left: 0px; top: 100%; width: 100%; height: 1%; z-index: -1; background-color: rgb(0, 68, 187); "></div>
</div>

<div class="body_content">
<br />
<table>
<tr>
<td class="h" align="right">File</td>
<td align="left">/usr/local/lib/perl5/site_perl/5.10.1/XML/Simple.pm</td>
</tr>
<tr>
<td class="h" align="right">Statements Executed</td>
<td align="left">1797</td>
</tr>
<tr>
<td class="h" align="right">Statement Execution Time</td>
<td align="left">8.32ms</td>
</tr>
</table>

        
        <table id="subs_table" border="1" cellpadding="0" class="tablesorter">
        <caption>Subroutines &mdash; ordered by exclusive time</caption>
        <thead>
        <tr>
        <th>Calls</th>
        <th><span title="Number of Places sub is called from">P</span></th>
        <th><span title="Number of Files sub is called from">F</span></th>
        <th>Exclusive<br />Time</th>
        <th>Inclusive<br />Time</th>
        <th>Subroutine</th>
        </tr>
        </thead>
    <tbody>
<tr><td class="c3">3</td><td class="c3">1</td><td class="c3">1</td><td class="c0"><span title="0.1%">1.55ms</span></td><td class="c0"><span title="3.8%">46.7ms</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::build_tree</span>XML::Simple::<a href="XML-Simple-pm-block.html#334">build_tree</a></span></td></tr>
<tr><td class="c0">35</td><td class="c1">2</td><td class="c3">1</td><td class="c0"><span title="0.1%">796&micro;s</span></td><td class="c0"><span title="0.6%">7.18ms</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::collapse</span>XML::Simple::<a href="XML-Simple-pm-block.html#974">collapse</a></span></td></tr>
<tr><td class="c3">3</td><td class="c3">1</td><td class="c3">1</td><td class="c0"><span title="0.0%">347&micro;s</span></td><td class="c1"><span title="0.0%">350&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::handle_options</span>XML::Simple::<a href="XML-Simple-pm-block.html#674">handle_options</a></span></td></tr>
<tr><td class="c0">35</td><td class="c1">2</td><td class="c3">1</td><td class="c0"><span title="0.0%">337&micro;s</span></td><td class="c1"><span title="0.0%">337&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::start_element</span>XML::Simple::<a href="XML-Simple-pm-block.html#1768">start_element</a></span></td></tr>
<tr><td class="c3">1</td><td class="c3">1</td><td class="c3">1</td><td class="c0"><span title="0.0%">195&micro;s</span></td><td class="c3"><span title="0.0%">199&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::BEGIN@1687</span>XML::Simple::<a href="XML-Simple-pm-block.html#1687">BEGIN@1687</a></span></td></tr>
<tr><td class="c0">28</td><td class="c1">2</td><td class="c3">1</td><td class="c1"><span title="0.0%">176&micro;s</span></td><td class="c3"><span title="0.0%">176&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::characters</span>XML::Simple::<a href="XML-Simple-pm-block.html#1802">characters</a></span></td></tr>
<tr><td class="c3">3</td><td class="c3">1</td><td class="c3">1</td><td class="c1"><span title="0.0%">147&micro;s</span></td><td class="c3"><span title="0.0%">147&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::new</span>XML::Simple::<a href="XML-Simple-pm-block.html#108">new</a></span></td></tr>
<tr><td class="c0">33</td><td class="c0">4</td><td class="c1">2</td><td class="c2"><span title="0.0%">99&micro;s</span></td><td class="c0"><span title="0.5%">6.32ms</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::CORE:match</span>XML::Simple::<a href="XML-Simple-pm-block.html#XML__Simple__CORE_match">CORE:match</a>&nbsp;(opcode)</span></td></tr>
<tr><td class="c3">3</td><td class="c3">1</td><td class="c3">1</td><td class="c3"><span title="0.0%">81&micro;s</span></td><td class="c0"><span title="4.4%">53.9ms</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::build_simple_tree</span>XML::Simple::<a href="XML-Simple-pm-block.html#305">build_simple_tree</a></span></td></tr>
<tr><td class="c3">3</td><td class="c3">1</td><td class="c3">1</td><td class="c3"><span title="0.0%">71&micro;s</span></td><td class="c0"><span title="4.5%">54.6ms</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::XMLin</span>XML::Simple::<a href="XML-Simple-pm-block.html#163">XMLin</a></span></td></tr>
<tr><td class="c1">6</td><td class="c1">2</td><td class="c3">1</td><td class="c3"><span title="0.0%">70&micro;s</span></td><td class="c3"><span title="0.0%">245&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::_get_object</span>XML::Simple::<a href="XML-Simple-pm-block.html#139">_get_object</a></span></td></tr>
<tr><td class="c0">35</td><td class="c1">2</td><td class="c3">1</td><td class="c3"><span title="0.0%">67&micro;s</span></td><td class="c3"><span title="0.0%">67&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::end_element</span>XML::Simple::<a href="XML-Simple-pm-block.html#1819">end_element</a></span></td></tr>
<tr><td class="c3">3</td><td class="c3">1</td><td class="c3">1</td><td class="c3"><span title="0.0%">55&micro;s</span></td><td class="c0"><span title="4.5%">54.3ms</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::parse_string</span>XML::Simple::<a href="XML-Simple-pm-block.html#263">parse_string</a></span></td></tr>
<tr><td class="c3">1</td><td class="c3">1</td><td class="c3">1</td><td class="c3"><span title="0.0%">26&micro;s</span></td><td class="c3"><span title="0.0%">31&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::array_to_hash</span>XML::Simple::<a href="XML-Simple-pm-block.html#1215">array_to_hash</a></span></td></tr>
<tr><td class="c3">3</td><td class="c3">1</td><td class="c3">1</td><td class="c3"><span title="0.0%">20&micro;s</span></td><td class="c3"><span title="0.0%">20&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::start_document</span>XML::Simple::<a href="XML-Simple-pm-block.html#1758">start_document</a></span></td></tr>
<tr><td class="c3">1</td><td class="c3">1</td><td class="c3">1</td><td class="c3"><span title="0.0%">17&micro;s</span></td><td class="c3"><span title="0.0%">20&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::BEGIN@42</span>XML::Simple::<a href="XML-Simple-pm-block.html#42">BEGIN@42</a></span></td></tr>
<tr><td class="c3">3</td><td class="c3">1</td><td class="c3">1</td><td class="c3"><span title="0.0%">17&micro;s</span></td><td class="c3"><span title="0.0%">17&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::end_document</span>XML::Simple::<a href="XML-Simple-pm-block.html#1826">end_document</a></span></td></tr>
<tr><td class="c3">1</td><td class="c3">1</td><td class="c3">1</td><td class="c3"><span title="0.0%">14&micro;s</span></td><td class="c3"><span title="0.0%">52&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::BEGIN@43</span>XML::Simple::<a href="XML-Simple-pm-block.html#43">BEGIN@43</a></span></td></tr>
<tr><td class="c3">1</td><td class="c3">1</td><td class="c3">1</td><td class="c3"><span title="0.0%">13&micro;s</span></td><td class="c3"><span title="0.0%">15&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::import</span>XML::Simple::<a href="XML-Simple-pm-block.html#92">import</a></span></td></tr>
<tr><td class="c3">1</td><td class="c3">1</td><td class="c3">1</td><td class="c3"><span title="0.0%">6&micro;s</span></td><td class="c3"><span title="0.0%">67&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::BEGIN@51</span>XML::Simple::<a href="XML-Simple-pm-block.html#51">BEGIN@51</a></span></td></tr>
<tr><td class="c3">3</td><td class="c3">1</td><td class="c1">2</td><td class="c3"><span title="0.0%">3&micro;s</span></td><td class="c3"><span title="0.0%">3&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::CORE:subst</span>XML::Simple::<a href="XML-Simple-pm-block.html#XML__Simple__CORE_subst">CORE:subst</a>&nbsp;(opcode)</span></td></tr>
<tr><td class="c3">1</td><td class="c3">1</td><td class="c3">1</td><td class="c3"><span title="0.0%">3&micro;s</span></td><td class="c3"><span title="0.0%">3&micro;s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::new_hashref</span>XML::Simple::<a href="XML-Simple-pm-block.html#1322">new_hashref</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::XMLout</span>XML::Simple::<a href="XML-Simple-pm-block.html#564">XMLout</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::build_tree_xml_parser</span>XML::Simple::<a href="XML-Simple-pm-block.html#386">build_tree_xml_parser</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::cache_read_memcopy</span>XML::Simple::<a href="XML-Simple-pm-block.html#544">cache_read_memcopy</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::cache_read_memshare</span>XML::Simple::<a href="XML-Simple-pm-block.html#510">cache_read_memshare</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::cache_read_storable</span>XML::Simple::<a href="XML-Simple-pm-block.html#454">cache_read_storable</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::cache_write_memcopy</span>XML::Simple::<a href="XML-Simple-pm-block.html#528">cache_write_memcopy</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::cache_write_memshare</span>XML::Simple::<a href="XML-Simple-pm-block.html#497">cache_write_memshare</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::cache_write_storable</span>XML::Simple::<a href="XML-Simple-pm-block.html#428">cache_write_storable</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::collapse_content</span>XML::Simple::<a href="XML-Simple-pm-block.html#1348">collapse_content</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::copy_hash</span>XML::Simple::<a href="XML-Simple-pm-block.html#1748">copy_hash</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::default_config_file</span>XML::Simple::<a href="XML-Simple-pm-block.html#281">default_config_file</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::die_or_warn</span>XML::Simple::<a href="XML-Simple-pm-block.html#1306">die_or_warn</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::escape_value</span>XML::Simple::<a href="XML-Simple-pm-block.html#1669">escape_value</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::find_xml_file</span>XML::Simple::<a href="XML-Simple-pm-block.html#914">find_xml_file</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::get_var</span>XML::Simple::<a href="XML-Simple-pm-block.html#1178">get_var</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::hash_to_array</span>XML::Simple::<a href="XML-Simple-pm-block.html#1709">hash_to_array</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::normalise_space</span>XML::Simple::<a href="XML-Simple-pm-block.html#1195">normalise_space</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::numeric_escape</span>XML::Simple::<a href="XML-Simple-pm-block.html#1684">numeric_escape</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::parse_fh</span>XML::Simple::<a href="XML-Simple-pm-block.html#244">parse_fh</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::parse_file</span>XML::Simple::<a href="XML-Simple-pm-block.html#206">parse_file</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::set_var</span>XML::Simple::<a href="XML-Simple-pm-block.html#1165">set_var</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::sorted_keys</span>XML::Simple::<a href="XML-Simple-pm-block.html#1633">sorted_keys</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::storable_filename</span>XML::Simple::<a href="XML-Simple-pm-block.html#482">storable_filename</a></span></td></tr>
<tr><td class="c3">0</td><td class="c3">0</td><td class="c3">0</td><td class="c3"><span title="0.0%">0s</span></td><td class="c3"><span title="0.0%">0s</span></td><td class="sub_name"><span style="display: none;">XML::Simple::::value_to_xml</span>XML::Simple::<a href="XML-Simple-pm-block.html#1383">value_to_xml</a></span></td></tr>

        </tbody>
        </table>
    
        Call graph for these subroutines as a <a href="http://en.wikipedia.org/wiki/Graphviz">Graphviz</a> <a href="usr-local-lib-perl5-site_perl-5-10-1-XML-Simple-pm.dot">dot language file</a>.
      <table border="1" cellpadding="0">
      <thead>
      <tr><th>Line</th>
      <th><span title="Number of statements executed">State<br />ments</span></th>
      <th><span title="Time spend executing statements on the line,
        excluding time spent executing statements in any called subroutines">Time<br />on line</span></th>
      <th><span title="Number of subroutines calls">Calls</span></th>
      <th><span title="Time spent in subroutines called">Time<br />in subs</span></th>
      <th class="left_indent_header">Code</th>
      </tr>

      </thead>
      <tbody>
    <tr><td class="h"><a name="1"></a>1</td><td></td><td></td><td></td><td></td><td class="s"># $Id: Simple.pm,v 1.40 2007/08/15 10:36:48 grantm Exp $</td></tr>
<tr><td class="h"><a name="2"></a>2</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3"></a>3</td><td></td><td></td><td></td><td></td><td class="s">package XML::Simple;</td></tr>
<tr><td class="h"><a name="4"></a>4</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="5"></a>5</td><td></td><td></td><td></td><td></td><td class="s">=head1 NAME</td></tr>
<tr><td class="h"><a name="6"></a>6</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="7"></a>7</td><td></td><td></td><td></td><td></td><td class="s">XML::Simple - Easy API to maintain XML (esp config files)</td></tr>
<tr><td class="h"><a name="8"></a>8</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="9"></a>9</td><td></td><td></td><td></td><td></td><td class="s">=head1 SYNOPSIS</td></tr>
<tr><td class="h"><a name="10"></a>10</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="11"></a>11</td><td></td><td></td><td></td><td></td><td class="s">    use XML::Simple;</td></tr>
<tr><td class="h"><a name="12"></a>12</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="13"></a>13</td><td></td><td></td><td></td><td></td><td class="s">    my $ref = XMLin([&lt;xml file or string&gt;] [, &lt;options&gt;]);</td></tr>
<tr><td class="h"><a name="14"></a>14</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="15"></a>15</td><td></td><td></td><td></td><td></td><td class="s">    my $xml = XMLout($hashref [, &lt;options&gt;]);</td></tr>
<tr><td class="h"><a name="16"></a>16</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="17"></a>17</td><td></td><td></td><td></td><td></td><td class="s">Or the object oriented way:</td></tr>
<tr><td class="h"><a name="18"></a>18</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="19"></a>19</td><td></td><td></td><td></td><td></td><td class="s">    require XML::Simple;</td></tr>
<tr><td class="h"><a name="20"></a>20</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="21"></a>21</td><td></td><td></td><td></td><td></td><td class="s">    my $xs = XML::Simple-&gt;new(options);</td></tr>
<tr><td class="h"><a name="22"></a>22</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="23"></a>23</td><td></td><td></td><td></td><td></td><td class="s">    my $ref = $xs-&gt;XMLin([&lt;xml file or string&gt;] [, &lt;options&gt;]);</td></tr>
<tr><td class="h"><a name="24"></a>24</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="25"></a>25</td><td></td><td></td><td></td><td></td><td class="s">    my $xml = $xs-&gt;XMLout($hashref [, &lt;options&gt;]);</td></tr>
<tr><td class="h"><a name="26"></a>26</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="27"></a>27</td><td></td><td></td><td></td><td></td><td class="s">(or see L&lt;&quot;SAX SUPPORT&quot;&gt; for 'the SAX way').</td></tr>
<tr><td class="h"><a name="28"></a>28</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="29"></a>29</td><td></td><td></td><td></td><td></td><td class="s">To catch common errors:</td></tr>
<tr><td class="h"><a name="30"></a>30</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="31"></a>31</td><td></td><td></td><td></td><td></td><td class="s">    use XML::Simple qw(:strict);</td></tr>
<tr><td class="h"><a name="32"></a>32</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="33"></a>33</td><td></td><td></td><td></td><td></td><td class="s">(see L&lt;&quot;STRICT MODE&quot;&gt; for more details).</td></tr>
<tr><td class="h"><a name="34"></a>34</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="35"></a>35</td><td></td><td></td><td></td><td></td><td class="s">=cut</td></tr>
<tr><td class="h"><a name="36"></a>36</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="37"></a>37</td><td></td><td></td><td></td><td></td><td class="s"># See after __END__ for more POD documentation</td></tr>
<tr><td class="h"><a name="38"></a>38</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="39"></a>39</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="40"></a>40</td><td></td><td></td><td></td><td></td><td class="s"># Load essentials here, other modules loaded on demand later</td></tr>
<tr><td class="h"><a name="41"></a>41</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="42"></a>42</td><td class="c3">3</td><td class="c1"><span title="Avg 10&micro;s">29&micro;s</span></td><td class="c3">2</td><td class="c3">24&micro;s</td><td class="s"><div class="calls"><div class="calls_in"># spent 20&micro;s (17+3) within XML::Simple::BEGIN@42 which was called
#    once (17&micro;s+3&micro;s) by SimpleDB::Client::BEGIN@48 at <a href="XML-Simple-pm-block.html#42">line 42</a></div></div>use strict;<div class="calls"><div class="calls_out"># spent    20&micro;s making 1 call to <a href="XML-Simple-pm-block.html#42">XML::Simple::BEGIN@42</a>
# spent     3&micro;s making 1 call to <a href="strict-pm-block.html#34">strict::import</a></div></div></td></tr>
<tr><td class="h"><a name="43"></a>43</td><td class="c3">3</td><td class="c1"><span title="Avg 11&micro;s">32&micro;s</span></td><td class="c3">2</td><td class="c1">89&micro;s</td><td class="s"><div class="calls"><div class="calls_in"># spent 52&micro;s (14+37) within XML::Simple::BEGIN@43 which was called
#    once (14&micro;s+37&micro;s) by SimpleDB::Client::BEGIN@48 at <a href="XML-Simple-pm-block.html#43">line 43</a></div></div>use Carp;<div class="calls"><div class="calls_out"># spent    52&micro;s making 1 call to <a href="XML-Simple-pm-block.html#43">XML::Simple::BEGIN@43</a>
# spent    37&micro;s making 1 call to <a href="Exporter-pm-block.html#31">Exporter::import</a></div></div></td></tr>
<tr><td class="h"><a name="44"></a>44</td><td class="c3">1</td><td class="c3"><span title="Avg 700ns">700ns</span></td><td></td><td></td><td class="s">require Exporter;</td></tr>
<tr><td class="h"><a name="45"></a>45</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="46"></a>46</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="47"></a>47</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="48"></a>48</td><td></td><td></td><td></td><td></td><td class="s"># Define some constants</td></tr>
<tr><td class="h"><a name="49"></a>49</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="50"></a>50</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="51"></a>51</td><td class="c3">3</td><td class="c0"><span title="Avg 1.55ms">4.65ms</span></td><td class="c3">2</td><td class="c1">128&micro;s</td><td class="s"><div class="calls"><div class="calls_in"># spent 67&micro;s (6+61) within XML::Simple::BEGIN@51 which was called
#    once (6&micro;s+61&micro;s) by SimpleDB::Client::BEGIN@48 at <a href="XML-Simple-pm-block.html#51">line 51</a></div></div>use vars qw($VERSION @ISA @EXPORT @EXPORT_OK $PREFERRED_PARSER);<div class="calls"><div class="calls_out"># spent    67&micro;s making 1 call to <a href="XML-Simple-pm-block.html#51">XML::Simple::BEGIN@51</a>
# spent    61&micro;s making 1 call to <a href="vars-pm-block.html#10">vars::import</a></div></div></td></tr>
<tr><td class="h"><a name="52"></a>52</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="53"></a>53</td><td class="c3">1</td><td class="c3"><span title="Avg 9&micro;s">9&micro;s</span></td><td></td><td></td><td class="s">@ISA               = qw(Exporter);</td></tr>
<tr><td class="h"><a name="54"></a>54</td><td class="c3">1</td><td class="c3"><span title="Avg 800ns">800ns</span></td><td></td><td></td><td class="s">@EXPORT            = qw(XMLin XMLout);</td></tr>
<tr><td class="h"><a name="55"></a>55</td><td class="c3">1</td><td class="c3"><span title="Avg 500ns">500ns</span></td><td></td><td></td><td class="s">@EXPORT_OK         = qw(xml_in xml_out);</td></tr>
<tr><td class="h"><a name="56"></a>56</td><td class="c3">1</td><td class="c3"><span title="Avg 300ns">300ns</span></td><td></td><td></td><td class="s">$VERSION           = '2.18';</td></tr>
<tr><td class="h"><a name="57"></a>57</td><td class="c3">1</td><td class="c3"><span title="Avg 300ns">300ns</span></td><td></td><td></td><td class="s">$PREFERRED_PARSER  = undef;</td></tr>
<tr><td class="h"><a name="58"></a>58</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="59"></a>59</td><td class="c3">1</td><td class="c3"><span title="Avg 600ns">600ns</span></td><td></td><td></td><td class="s">my $StrictMode     = 0;</td></tr>
<tr><td class="h"><a name="60"></a>60</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="61"></a>61</td><td class="c3">1</td><td class="c3"><span title="Avg 3&micro;s">3&micro;s</span></td><td></td><td></td><td class="s">my @KnownOptIn     = qw(keyattr keeproot forcecontent contentkey noattr</td></tr>
<tr><td class="h"><a name="62"></a>62</td><td></td><td></td><td></td><td></td><td class="s">                        searchpath forcearray cache suppressempty parseropts</td></tr>
<tr><td class="h"><a name="63"></a>63</td><td></td><td></td><td></td><td></td><td class="s">                        grouptags nsexpand datahandler varattr variables</td></tr>
<tr><td class="h"><a name="64"></a>64</td><td></td><td></td><td></td><td></td><td class="s">                        normalisespace normalizespace valueattr);</td></tr>
<tr><td class="h"><a name="65"></a>65</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="66"></a>66</td><td class="c3">1</td><td class="c3"><span title="Avg 6&micro;s">6&micro;s</span></td><td></td><td></td><td class="s">my @KnownOptOut    = qw(keyattr keeproot contentkey noattr</td></tr>
<tr><td class="h"><a name="67"></a>67</td><td></td><td></td><td></td><td></td><td class="s">                        rootname xmldecl outputfile noescape suppressempty</td></tr>
<tr><td class="h"><a name="68"></a>68</td><td></td><td></td><td></td><td></td><td class="s">                        grouptags nsexpand handler noindent attrindent nosort</td></tr>
<tr><td class="h"><a name="69"></a>69</td><td></td><td></td><td></td><td></td><td class="s">                        valueattr numericescape);</td></tr>
<tr><td class="h"><a name="70"></a>70</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="71"></a>71</td><td class="c3">1</td><td class="c3"><span title="Avg 700ns">700ns</span></td><td></td><td></td><td class="s">my @DefKeyAttr     = qw(name key id);</td></tr>
<tr><td class="h"><a name="72"></a>72</td><td class="c3">1</td><td class="c3"><span title="Avg 200ns">200ns</span></td><td></td><td></td><td class="s">my $DefRootName    = qq(opt);</td></tr>
<tr><td class="h"><a name="73"></a>73</td><td class="c3">1</td><td class="c3"><span title="Avg 200ns">200ns</span></td><td></td><td></td><td class="s">my $DefContentKey  = qq(content);</td></tr>
<tr><td class="h"><a name="74"></a>74</td><td class="c3">1</td><td class="c3"><span title="Avg 200ns">200ns</span></td><td></td><td></td><td class="s">my $DefXmlDecl     = qq(&lt;?xml version='1.0' standalone='yes'?&gt;);</td></tr>
<tr><td class="h"><a name="75"></a>75</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="76"></a>76</td><td class="c3">1</td><td class="c3"><span title="Avg 200ns">200ns</span></td><td></td><td></td><td class="s">my $xmlns_ns       = 'http://www.w3.org/2000/xmlns/';</td></tr>
<tr><td class="h"><a name="77"></a>77</td><td class="c3">1</td><td class="c3"><span title="Avg 1&micro;s">1&micro;s</span></td><td></td><td></td><td class="s">my $bad_def_ns_jcn = '{' . $xmlns_ns . '}';     # LibXML::SAX workaround</td></tr>
<tr><td class="h"><a name="78"></a>78</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="79"></a>79</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="80"></a>80</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="81"></a>81</td><td></td><td></td><td></td><td></td><td class="s"># Globals for use by caching routines</td></tr>
<tr><td class="h"><a name="82"></a>82</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="83"></a>83</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="84"></a>84</td><td class="c3">1</td><td class="c3"><span title="Avg 400ns">400ns</span></td><td></td><td></td><td class="s">my %MemShareCache  = ();</td></tr>
<tr><td class="h"><a name="85"></a>85</td><td class="c3">1</td><td class="c3"><span title="Avg 100ns">100ns</span></td><td></td><td></td><td class="s">my %MemCopyCache   = ();</td></tr>
<tr><td class="h"><a name="86"></a>86</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="87"></a>87</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="88"></a>88</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="89"></a>89</td><td></td><td></td><td></td><td></td><td class="s"># Wrapper for Exporter - handles ':strict'</td></tr>
<tr><td class="h"><a name="90"></a>90</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="91"></a>91</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="92"></a>92</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 15&micro;s (13+2) within XML::Simple::import which was called
#    once (13&micro;s+2&micro;s) by SimpleDB::Client::BEGIN@48 at <a href="lib-SimpleDB-Client-pm-block.html#48">line 48 of ../lib/SimpleDB/Client.pm</a></div></div>sub import {</td></tr>
<tr><td class="h"><a name="93"></a>93</td><td></td><td></td><td></td><td></td><td class="s">  # Handle the :strict tag</td></tr>
<tr><td class="h"><a name="94"></a>94</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="95"></a>95</td><td class="c3">3</td><td class="c2"><span title="Avg 6&micro;s">17&micro;s</span></td><td class="c3">1</td><td class="c3">1&micro;s</td><td class="s">  $StrictMode = 1 if grep(/^:strict$/, @_);<div class="calls"><div class="calls_out">  # spent     1&micro;s making 1 call to <a href="XML-Simple-pm-block.html#XML__Simple__CORE_match">XML::Simple::CORE:match</a></div></div></td></tr>
<tr><td class="h"><a name="96"></a>96</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="97"></a>97</td><td></td><td></td><td></td><td></td><td class="s">  # Pass everything else to Exporter.pm</td></tr>
<tr><td class="h"><a name="98"></a>98</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="99"></a>99</td><td></td><td></td><td></td><td></td><td class="s">  @_ = grep(!/^:strict$/, @_);<div class="calls"><div class="calls_out">  # spent   300ns making 1 call to <a href="XML-Simple-pm-block.html#XML__Simple__CORE_match">XML::Simple::CORE:match</a></div></div></td></tr>
<tr><td class="h"><a name="100"></a>100</td><td></td><td></td><td></td><td></td><td class="s">  goto &amp;Exporter::import;<div class="calls"><div class="calls_out">  # spent    29&micro;s making 1 call to <a href="Exporter-pm-block.html#31">Exporter::import</a></div></div></td></tr>
<tr><td class="h"><a name="101"></a>101</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="102"></a>102</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="103"></a>103</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="104"></a>104</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="105"></a>105</td><td></td><td></td><td></td><td></td><td class="s"># Constructor for optional object interface.</td></tr>
<tr><td class="h"><a name="106"></a>106</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="107"></a>107</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="108"></a>108</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 147&micro;s within XML::Simple::new which was called 3 times, avg 49&micro;s/call:
# 3 times (147&micro;s+0s) by XML::Simple::_get_object at <a href="XML-Simple-pm-block.html#145">line 145</a>, avg 49&micro;s/call</div></div>sub new {</td></tr>
<tr><td class="h"><a name="109"></a>109</td><td class="c0">27</td><td class="c0"><span title="Avg 6&micro;s">152&micro;s</span></td><td></td><td></td><td class="s">  my $class = shift;</td></tr>
<tr><td class="h"><a name="110"></a>110</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="111"></a>111</td><td></td><td></td><td></td><td></td><td class="s">  if(@_ % 2) {</td></tr>
<tr><td class="h"><a name="112"></a>112</td><td></td><td></td><td></td><td></td><td class="s">    croak &quot;Default options must be name=&gt;value pairs (odd number supplied)&quot;;</td></tr>
<tr><td class="h"><a name="113"></a>113</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="114"></a>114</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="115"></a>115</td><td></td><td></td><td></td><td></td><td class="s">  my %known_opt;</td></tr>
<tr><td class="h"><a name="116"></a>116</td><td></td><td></td><td></td><td></td><td class="s">  @known_opt{@KnownOptIn, @KnownOptOut} = (undef) x 100;</td></tr>
<tr><td class="h"><a name="117"></a>117</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="118"></a>118</td><td></td><td></td><td></td><td></td><td class="s">  my %raw_opt = @_;</td></tr>
<tr><td class="h"><a name="119"></a>119</td><td></td><td></td><td></td><td></td><td class="s">  my %def_opt;</td></tr>
<tr><td class="h"><a name="120"></a>120</td><td></td><td></td><td></td><td></td><td class="s">  while(my($key, $val) = each %raw_opt) {</td></tr>
<tr><td class="h"><a name="121"></a>121</td><td></td><td></td><td></td><td></td><td class="s">    my $lkey = lc($key);</td></tr>
<tr><td class="h"><a name="122"></a>122</td><td></td><td></td><td></td><td></td><td class="s">    $lkey =~ s/_//g;</td></tr>
<tr><td class="h"><a name="123"></a>123</td><td></td><td></td><td></td><td></td><td class="s">    croak &quot;Unrecognised option: $key&quot; unless(exists($known_opt{$lkey}));</td></tr>
<tr><td class="h"><a name="124"></a>124</td><td></td><td></td><td></td><td></td><td class="s">    $def_opt{$lkey} = $val;</td></tr>
<tr><td class="h"><a name="125"></a>125</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="126"></a>126</td><td></td><td></td><td></td><td></td><td class="s">  my $self = { def_opt =&gt; \%def_opt };</td></tr>
<tr><td class="h"><a name="127"></a>127</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="128"></a>128</td><td></td><td></td><td></td><td></td><td class="s">  return(bless($self, $class));</td></tr>
<tr><td class="h"><a name="129"></a>129</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="130"></a>130</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="131"></a>131</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="132"></a>132</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="133"></a>133</td><td></td><td></td><td></td><td></td><td class="s"># Sub: _get_object()</td></tr>
<tr><td class="h"><a name="134"></a>134</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="135"></a>135</td><td></td><td></td><td></td><td></td><td class="s"># Helper routine called from XMLin() and XMLout() to create an object if none</td></tr>
<tr><td class="h"><a name="136"></a>136</td><td></td><td></td><td></td><td></td><td class="s"># was provided.  Note, this routine does mess with the caller's @_ array.</td></tr>
<tr><td class="h"><a name="137"></a>137</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="138"></a>138</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="139"></a>139</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 245&micro;s (70+175) within XML::Simple::_get_object which was called 6 times, avg 41&micro;s/call:
# 3 times (55&micro;s+170&micro;s) by XML::Simple::XMLin at <a href="XML-Simple-pm-block.html#164">line 164</a>, avg 75&micro;s/call
# 3 times (15&micro;s+5&micro;s) by XML::Simple::parse_string at <a href="XML-Simple-pm-block.html#264">line 264</a>, avg 7&micro;s/call</div></div>sub _get_object {</td></tr>
<tr><td class="h"><a name="140"></a>140</td><td class="c0">18</td><td class="c0"><span title="Avg 4&micro;s">80&micro;s</span></td><td></td><td></td><td class="s">  my $self;</td></tr>
<tr><td class="h"><a name="141"></a>141</td><td class="c3">3</td><td class="c2"><span title="Avg 6&micro;s">18&micro;s</span></td><td class="c0">6</td><td class="c3">29&micro;s</td><td class="s">  if($_[0]  and  UNIVERSAL::isa($_[0], 'XML::Simple')) {<div class="calls"><div class="calls_out">  # spent    29&micro;s making 6 calls to <a >UNIVERSAL::isa</a>, avg 5&micro;s/call</div></div></td></tr>
<tr><td class="h"><a name="142"></a>142</td><td></td><td></td><td></td><td></td><td class="s">    $self = shift;</td></tr>
<tr><td class="h"><a name="143"></a>143</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="144"></a>144</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="145"></a>145</td><td></td><td></td><td></td><td></td><td class="s">    $self = XML::Simple-&gt;new();<div class="calls"><div class="calls_out">    # spent   147&micro;s making 3 calls to <a href="XML-Simple-pm-block.html#108">XML::Simple::new</a>, avg 49&micro;s/call</div></div></td></tr>
<tr><td class="h"><a name="146"></a>146</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="147"></a>147</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="148"></a>148</td><td></td><td></td><td></td><td></td><td class="s">  return $self;</td></tr>
<tr><td class="h"><a name="149"></a>149</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="150"></a>150</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="151"></a>151</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="152"></a>152</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="153"></a>153</td><td></td><td></td><td></td><td></td><td class="s"># Sub/Method: XMLin()</td></tr>
<tr><td class="h"><a name="154"></a>154</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="155"></a>155</td><td></td><td></td><td></td><td></td><td class="s"># Exported routine for slurping XML into a hashref - see pod for info.</td></tr>
<tr><td class="h"><a name="156"></a>156</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="157"></a>157</td><td></td><td></td><td></td><td></td><td class="s"># May be called as object method or as a plain function.</td></tr>
<tr><td class="h"><a name="158"></a>158</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="159"></a>159</td><td></td><td></td><td></td><td></td><td class="s"># Expects one arg for the source XML, optionally followed by a number of</td></tr>
<tr><td class="h"><a name="160"></a>160</td><td></td><td></td><td></td><td></td><td class="s"># name =&gt; value option pairs.</td></tr>
<tr><td class="h"><a name="161"></a>161</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="162"></a>162</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="163"></a>163</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 54.6ms (71&micro;s+54.6) within XML::Simple::XMLin which was called 3 times, avg 18.2ms/call:
# 3 times (71&micro;s+54.6ms) by SimpleDB::Client::handle_response at <a href="lib-SimpleDB-Client-pm-block.html#245">line 245 of ../lib/SimpleDB/Client.pm</a>, avg 18.2ms/call</div></div>sub XMLin {</td></tr>
<tr><td class="h"><a name="164"></a>164</td><td class="c0">9</td><td class="c0"><span title="Avg 9&micro;s">77&micro;s</span></td><td class="c3">3</td><td class="c0">225&micro;s</td><td class="s">  my $self = &amp;_get_object;      # note, @_ is passed implicitly<div class="calls"><div class="calls_out">  # spent   225&micro;s making 3 calls to <a href="XML-Simple-pm-block.html#139">XML::Simple::_get_object</a>, avg 75&micro;s/call</div></div></td></tr>
<tr><td class="h"><a name="165"></a>165</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="166"></a>166</td><td></td><td></td><td></td><td></td><td class="s">  my $target = shift;</td></tr>
<tr><td class="h"><a name="167"></a>167</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="168"></a>168</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="169"></a>169</td><td></td><td></td><td></td><td></td><td class="s">  # Work out whether to parse a string, a file or a filehandle</td></tr>
<tr><td class="h"><a name="170"></a>170</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="171"></a>171</td><td></td><td></td><td></td><td></td><td class="s">  if(not defined $target) {<div class="calls"><div class="calls_out">  # spent  54.3ms making 3 calls to <a href="XML-Simple-pm-block.html#263">XML::Simple::parse_string</a>, avg 18.1ms/call
  # spent    12&micro;s making 3 calls to <a href="XML-Simple-pm-block.html#XML__Simple__CORE_match">XML::Simple::CORE:match</a>, avg 4&micro;s/call</div></div></td></tr>
<tr><td class="h"><a name="172"></a>172</td><td></td><td></td><td></td><td></td><td class="s">    return $self-&gt;parse_file(undef, @_);</td></tr>
<tr><td class="h"><a name="173"></a>173</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="174"></a>174</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="175"></a>175</td><td></td><td></td><td></td><td></td><td class="s">  elsif($target eq '-') {</td></tr>
<tr><td class="h"><a name="176"></a>176</td><td></td><td></td><td></td><td></td><td class="s">    local($/) = undef;</td></tr>
<tr><td class="h"><a name="177"></a>177</td><td></td><td></td><td></td><td></td><td class="s">    $target = &lt;STDIN&gt;;</td></tr>
<tr><td class="h"><a name="178"></a>178</td><td></td><td></td><td></td><td></td><td class="s">    return $self-&gt;parse_string(\$target, @_);</td></tr>
<tr><td class="h"><a name="179"></a>179</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="180"></a>180</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="181"></a>181</td><td></td><td></td><td></td><td></td><td class="s">  elsif(my $type = ref($target)) {</td></tr>
<tr><td class="h"><a name="182"></a>182</td><td></td><td></td><td></td><td></td><td class="s">    if($type eq 'SCALAR') {</td></tr>
<tr><td class="h"><a name="183"></a>183</td><td></td><td></td><td></td><td></td><td class="s">      return $self-&gt;parse_string($target, @_);</td></tr>
<tr><td class="h"><a name="184"></a>184</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="185"></a>185</td><td></td><td></td><td></td><td></td><td class="s">    else {</td></tr>
<tr><td class="h"><a name="186"></a>186</td><td></td><td></td><td></td><td></td><td class="s">      return $self-&gt;parse_fh($target, @_);</td></tr>
<tr><td class="h"><a name="187"></a>187</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="188"></a>188</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="189"></a>189</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="190"></a>190</td><td></td><td></td><td></td><td></td><td class="s">  elsif($target =~ m{&lt;.*?&gt;}s) {</td></tr>
<tr><td class="h"><a name="191"></a>191</td><td></td><td></td><td></td><td></td><td class="s">    return $self-&gt;parse_string(\$target, @_);</td></tr>
<tr><td class="h"><a name="192"></a>192</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="193"></a>193</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="194"></a>194</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="195"></a>195</td><td></td><td></td><td></td><td></td><td class="s">    return $self-&gt;parse_file($target, @_);</td></tr>
<tr><td class="h"><a name="196"></a>196</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="197"></a>197</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="198"></a>198</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="199"></a>199</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="200"></a>200</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="201"></a>201</td><td></td><td></td><td></td><td></td><td class="s"># Sub/Method: parse_file()</td></tr>
<tr><td class="h"><a name="202"></a>202</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="203"></a>203</td><td></td><td></td><td></td><td></td><td class="s"># Same as XMLin, but only parses from a named file.</td></tr>
<tr><td class="h"><a name="204"></a>204</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="205"></a>205</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="206"></a>206</td><td></td><td></td><td></td><td></td><td class="s">sub parse_file {</td></tr>
<tr><td class="h"><a name="207"></a>207</td><td></td><td></td><td></td><td></td><td class="s">  my $self = &amp;_get_object;      # note, @_ is passed implicitly</td></tr>
<tr><td class="h"><a name="208"></a>208</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="209"></a>209</td><td></td><td></td><td></td><td></td><td class="s">  my $filename = shift;</td></tr>
<tr><td class="h"><a name="210"></a>210</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="211"></a>211</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;handle_options('in', @_);</td></tr>
<tr><td class="h"><a name="212"></a>212</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="213"></a>213</td><td></td><td></td><td></td><td></td><td class="s">  $filename = $self-&gt;default_config_file if not defined $filename;</td></tr>
<tr><td class="h"><a name="214"></a>214</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="215"></a>215</td><td></td><td></td><td></td><td></td><td class="s">  $filename = $self-&gt;find_xml_file($filename, @{$self-&gt;{opt}-&gt;{searchpath}});</td></tr>
<tr><td class="h"><a name="216"></a>216</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="217"></a>217</td><td></td><td></td><td></td><td></td><td class="s">  # Check cache for previous parse</td></tr>
<tr><td class="h"><a name="218"></a>218</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="219"></a>219</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{cache}) {</td></tr>
<tr><td class="h"><a name="220"></a>220</td><td></td><td></td><td></td><td></td><td class="s">    foreach my $scheme (@{$self-&gt;{opt}-&gt;{cache}}) {</td></tr>
<tr><td class="h"><a name="221"></a>221</td><td></td><td></td><td></td><td></td><td class="s">      my $method = 'cache_read_' . $scheme;</td></tr>
<tr><td class="h"><a name="222"></a>222</td><td></td><td></td><td></td><td></td><td class="s">      my $opt = $self-&gt;$method($filename);</td></tr>
<tr><td class="h"><a name="223"></a>223</td><td></td><td></td><td></td><td></td><td class="s">      return($opt) if($opt);</td></tr>
<tr><td class="h"><a name="224"></a>224</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="225"></a>225</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="226"></a>226</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="227"></a>227</td><td></td><td></td><td></td><td></td><td class="s">  my $ref = $self-&gt;build_simple_tree($filename, undef);</td></tr>
<tr><td class="h"><a name="228"></a>228</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="229"></a>229</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{cache}) {</td></tr>
<tr><td class="h"><a name="230"></a>230</td><td></td><td></td><td></td><td></td><td class="s">    my $method = 'cache_write_' . $self-&gt;{opt}-&gt;{cache}-&gt;[0];</td></tr>
<tr><td class="h"><a name="231"></a>231</td><td></td><td></td><td></td><td></td><td class="s">    $self-&gt;$method($ref, $filename);</td></tr>
<tr><td class="h"><a name="232"></a>232</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="233"></a>233</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="234"></a>234</td><td></td><td></td><td></td><td></td><td class="s">  return $ref;</td></tr>
<tr><td class="h"><a name="235"></a>235</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="236"></a>236</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="237"></a>237</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="238"></a>238</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="239"></a>239</td><td></td><td></td><td></td><td></td><td class="s"># Sub/Method: parse_fh()</td></tr>
<tr><td class="h"><a name="240"></a>240</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="241"></a>241</td><td></td><td></td><td></td><td></td><td class="s"># Same as XMLin, but only parses from a filehandle.</td></tr>
<tr><td class="h"><a name="242"></a>242</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="243"></a>243</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="244"></a>244</td><td></td><td></td><td></td><td></td><td class="s">sub parse_fh {</td></tr>
<tr><td class="h"><a name="245"></a>245</td><td></td><td></td><td></td><td></td><td class="s">  my $self = &amp;_get_object;      # note, @_ is passed implicitly</td></tr>
<tr><td class="h"><a name="246"></a>246</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="247"></a>247</td><td></td><td></td><td></td><td></td><td class="s">  my $fh = shift;</td></tr>
<tr><td class="h"><a name="248"></a>248</td><td></td><td></td><td></td><td></td><td class="s">  croak &quot;Can't use &quot; . (defined $fh ? qq{string (&quot;$fh&quot;)} : 'undef') .</td></tr>
<tr><td class="h"><a name="249"></a>249</td><td></td><td></td><td></td><td></td><td class="s">        &quot; as a filehandle&quot; unless ref $fh;</td></tr>
<tr><td class="h"><a name="250"></a>250</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="251"></a>251</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;handle_options('in', @_);</td></tr>
<tr><td class="h"><a name="252"></a>252</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="253"></a>253</td><td></td><td></td><td></td><td></td><td class="s">  return $self-&gt;build_simple_tree(undef, $fh);</td></tr>
<tr><td class="h"><a name="254"></a>254</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="255"></a>255</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="256"></a>256</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="257"></a>257</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="258"></a>258</td><td></td><td></td><td></td><td></td><td class="s"># Sub/Method: parse_string()</td></tr>
<tr><td class="h"><a name="259"></a>259</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="260"></a>260</td><td></td><td></td><td></td><td></td><td class="s"># Same as XMLin, but only parses from a string or a reference to a string.</td></tr>
<tr><td class="h"><a name="261"></a>261</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="262"></a>262</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="263"></a>263</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 54.3ms (55&micro;s+54.3) within XML::Simple::parse_string which was called 3 times, avg 18.1ms/call:
# 3 times (55&micro;s+54.3ms) by XML::Simple::XMLin at <a href="XML-Simple-pm-block.html#171">line 171</a>, avg 18.1ms/call</div></div>sub parse_string {</td></tr>
<tr><td class="h"><a name="264"></a>264</td><td class="c0">12</td><td class="c0"><span title="Avg 3&micro;s">40&micro;s</span></td><td class="c3">3</td><td class="c3">20&micro;s</td><td class="s">  my $self = &amp;_get_object;      # note, @_ is passed implicitly<div class="calls"><div class="calls_out">  # spent    20&micro;s making 3 calls to <a href="XML-Simple-pm-block.html#139">XML::Simple::_get_object</a>, avg 7&micro;s/call</div></div></td></tr>
<tr><td class="h"><a name="265"></a>265</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="266"></a>266</td><td></td><td></td><td></td><td></td><td class="s">  my $string = shift;</td></tr>
<tr><td class="h"><a name="267"></a>267</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="268"></a>268</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;handle_options('in', @_);<div class="calls"><div class="calls_out">  # spent   350&micro;s making 3 calls to <a href="XML-Simple-pm-block.html#674">XML::Simple::handle_options</a>, avg 117&micro;s/call</div></div></td></tr>
<tr><td class="h"><a name="269"></a>269</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="270"></a>270</td><td></td><td></td><td></td><td></td><td class="s">  return $self-&gt;build_simple_tree(undef, ref $string ? $string : \$string);<div class="calls"><div class="calls_out">  # spent  53.9ms making 3 calls to <a href="XML-Simple-pm-block.html#305">XML::Simple::build_simple_tree</a>, avg 18.0ms/call</div></div></td></tr>
<tr><td class="h"><a name="271"></a>271</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="272"></a>272</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="273"></a>273</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="274"></a>274</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="275"></a>275</td><td></td><td></td><td></td><td></td><td class="s"># Method: default_config_file()</td></tr>
<tr><td class="h"><a name="276"></a>276</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="277"></a>277</td><td></td><td></td><td></td><td></td><td class="s"># Returns the name of the XML file to parse if no filename (or XML string) </td></tr>
<tr><td class="h"><a name="278"></a>278</td><td></td><td></td><td></td><td></td><td class="s"># was provided.</td></tr>
<tr><td class="h"><a name="279"></a>279</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="280"></a>280</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="281"></a>281</td><td></td><td></td><td></td><td></td><td class="s">sub default_config_file {</td></tr>
<tr><td class="h"><a name="282"></a>282</td><td></td><td></td><td></td><td></td><td class="s">  my $self = shift;</td></tr>
<tr><td class="h"><a name="283"></a>283</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="284"></a>284</td><td></td><td></td><td></td><td></td><td class="s">  require File::Basename;</td></tr>
<tr><td class="h"><a name="285"></a>285</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="286"></a>286</td><td></td><td></td><td></td><td></td><td class="s">  my($basename, $script_dir, $ext) = File::Basename::fileparse($0, '\.[^\.]+');</td></tr>
<tr><td class="h"><a name="287"></a>287</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="288"></a>288</td><td></td><td></td><td></td><td></td><td class="s">  # Add script directory to searchpath</td></tr>
<tr><td class="h"><a name="289"></a>289</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="290"></a>290</td><td></td><td></td><td></td><td></td><td class="s">  if($script_dir) {</td></tr>
<tr><td class="h"><a name="291"></a>291</td><td></td><td></td><td></td><td></td><td class="s">    unshift(@{$self-&gt;{opt}-&gt;{searchpath}}, $script_dir);</td></tr>
<tr><td class="h"><a name="292"></a>292</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="293"></a>293</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="294"></a>294</td><td></td><td></td><td></td><td></td><td class="s">  return $basename . '.xml';</td></tr>
<tr><td class="h"><a name="295"></a>295</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="296"></a>296</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="297"></a>297</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="298"></a>298</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="299"></a>299</td><td></td><td></td><td></td><td></td><td class="s"># Method: build_simple_tree()</td></tr>
<tr><td class="h"><a name="300"></a>300</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="301"></a>301</td><td></td><td></td><td></td><td></td><td class="s"># Builds a 'tree' data structure as provided by XML::Parser and then </td></tr>
<tr><td class="h"><a name="302"></a>302</td><td></td><td></td><td></td><td></td><td class="s"># 'simplifies' it as specified by the various options in effect.</td></tr>
<tr><td class="h"><a name="303"></a>303</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="304"></a>304</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="305"></a>305</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 53.9ms (81&micro;s+53.8) within XML::Simple::build_simple_tree which was called 3 times, avg 18.0ms/call:
# 3 times (81&micro;s+53.8ms) by XML::Simple::parse_string at <a href="XML-Simple-pm-block.html#270">line 270</a>, avg 18.0ms/call</div></div>sub build_simple_tree {</td></tr>
<tr><td class="h"><a name="306"></a>306</td><td class="c0">9</td><td class="c0"><span title="Avg 9&micro;s">77&micro;s</span></td><td></td><td></td><td class="s">  my $self = shift;</td></tr>
<tr><td class="h"><a name="307"></a>307</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="308"></a>308</td><td></td><td></td><td></td><td></td><td class="s">  my $tree = $self-&gt;build_tree(@_);<div class="calls"><div class="calls_out">  # spent  46.7ms making 3 calls to <a href="XML-Simple-pm-block.html#334">XML::Simple::build_tree</a>, avg 15.6ms/call</div></div></td></tr>
<tr><td class="h"><a name="309"></a>309</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="310"></a>310</td><td></td><td></td><td></td><td></td><td class="s">  return $self-&gt;{opt}-&gt;{keeproot}</td></tr>
<tr><td class="h"><a name="311"></a>311</td><td></td><td></td><td></td><td></td><td class="s">         ? $self-&gt;collapse({}, @$tree)</td></tr>
<tr><td class="h"><a name="312"></a>312</td><td></td><td></td><td></td><td></td><td class="s">         : $self-&gt;collapse(@{$tree-&gt;[1]});<div class="calls"><div class="calls_out">         # spent  7.18ms making 3 calls to <a href="XML-Simple-pm-block.html#974">XML::Simple::collapse</a>, avg 2.39ms/call</div></div></td></tr>
<tr><td class="h"><a name="313"></a>313</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="314"></a>314</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="315"></a>315</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="316"></a>316</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="317"></a>317</td><td></td><td></td><td></td><td></td><td class="s"># Method: build_tree()</td></tr>
<tr><td class="h"><a name="318"></a>318</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="319"></a>319</td><td></td><td></td><td></td><td></td><td class="s"># This routine will be called if there is no suitable pre-parsed tree in a</td></tr>
<tr><td class="h"><a name="320"></a>320</td><td></td><td></td><td></td><td></td><td class="s"># cache.  It parses the XML and returns an XML::Parser 'Tree' style data</td></tr>
<tr><td class="h"><a name="321"></a>321</td><td></td><td></td><td></td><td></td><td class="s"># structure (summarised in the comments for the collapse() routine below).</td></tr>
<tr><td class="h"><a name="322"></a>322</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="323"></a>323</td><td></td><td></td><td></td><td></td><td class="s"># XML::Simple requires the services of another module that knows how to parse</td></tr>
<tr><td class="h"><a name="324"></a>324</td><td></td><td></td><td></td><td></td><td class="s"># XML.  If XML::SAX is installed, the default SAX parser will be used,</td></tr>
<tr><td class="h"><a name="325"></a>325</td><td></td><td></td><td></td><td></td><td class="s"># otherwise XML::Parser will be used.</td></tr>
<tr><td class="h"><a name="326"></a>326</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="327"></a>327</td><td></td><td></td><td></td><td></td><td class="s"># This routine expects to be passed a filename as argument 1 or a 'string' as</td></tr>
<tr><td class="h"><a name="328"></a>328</td><td></td><td></td><td></td><td></td><td class="s"># argument 2.  The 'string' might be a string of XML (passed by reference to</td></tr>
<tr><td class="h"><a name="329"></a>329</td><td></td><td></td><td></td><td></td><td class="s"># save memory) or it might be a reference to an IO::Handle.  (This</td></tr>
<tr><td class="h"><a name="330"></a>330</td><td></td><td></td><td></td><td></td><td class="s"># non-intuitive mess results in part from the way XML::Parser works but that's</td></tr>
<tr><td class="h"><a name="331"></a>331</td><td></td><td></td><td></td><td></td><td class="s"># really no excuse).</td></tr>
<tr><td class="h"><a name="332"></a>332</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="333"></a>333</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="334"></a>334</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 46.7ms (1.55+45.1) within XML::Simple::build_tree which was called 3 times, avg 15.6ms/call:
# 3 times (1.55ms+45.1ms) by XML::Simple::build_simple_tree at <a href="XML-Simple-pm-block.html#308">line 308</a>, avg 15.6ms/call</div></div>sub build_tree {</td></tr>
<tr><td class="h"><a name="335"></a>335</td><td class="c0">42</td><td class="c0"><span title="Avg 3&micro;s">107&micro;s</span></td><td></td><td></td><td class="s">  my $self     = shift;</td></tr>
<tr><td class="h"><a name="336"></a>336</td><td></td><td></td><td></td><td></td><td class="s">  my $filename = shift;</td></tr>
<tr><td class="h"><a name="337"></a>337</td><td></td><td></td><td></td><td></td><td class="s">  my $string   = shift;</td></tr>
<tr><td class="h"><a name="338"></a>338</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="339"></a>339</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="340"></a>340</td><td></td><td></td><td></td><td></td><td class="s">  my $preferred_parser = $PREFERRED_PARSER;</td></tr>
<tr><td class="h"><a name="341"></a>341</td><td></td><td></td><td></td><td></td><td class="s">  unless(defined($preferred_parser)) {</td></tr>
<tr><td class="h"><a name="342"></a>342</td><td></td><td></td><td></td><td></td><td class="s">    $preferred_parser = $ENV{XML_SIMPLE_PREFERRED_PARSER} || '';</td></tr>
<tr><td class="h"><a name="343"></a>343</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="344"></a>344</td><td></td><td></td><td></td><td></td><td class="s">  if($preferred_parser eq 'XML::Parser') {</td></tr>
<tr><td class="h"><a name="345"></a>345</td><td></td><td></td><td></td><td></td><td class="s">    return($self-&gt;build_tree_xml_parser($filename, $string));</td></tr>
<tr><td class="h"><a name="346"></a>346</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="347"></a>347</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="348"></a>348</td><td class="c3">3</td><td class="c0"><span title="Avg 81&micro;s">243&micro;s</span></td><td></td><td></td><td class="s">  eval { require XML::SAX; };      # We didn't need it until now</td></tr>
<tr><td class="h"><a name="349"></a>349</td><td></td><td></td><td></td><td></td><td class="s">  if($@) {                         # No XML::SAX - fall back to XML::Parser</td></tr>
<tr><td class="h"><a name="350"></a>350</td><td></td><td></td><td></td><td></td><td class="s">    if($preferred_parser) {        # unless a SAX parser was expressly requested</td></tr>
<tr><td class="h"><a name="351"></a>351</td><td></td><td></td><td></td><td></td><td class="s">      croak &quot;XMLin() could not load XML::SAX&quot;;</td></tr>
<tr><td class="h"><a name="352"></a>352</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="353"></a>353</td><td></td><td></td><td></td><td></td><td class="s">    return($self-&gt;build_tree_xml_parser($filename, $string));</td></tr>
<tr><td class="h"><a name="354"></a>354</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="355"></a>355</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="356"></a>356</td><td></td><td></td><td></td><td></td><td class="s">  $XML::SAX::ParserPackage = $preferred_parser if($preferred_parser);</td></tr>
<tr><td class="h"><a name="357"></a>357</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="358"></a>358</td><td></td><td></td><td></td><td></td><td class="s">  my $sp = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $self);<div class="calls"><div class="calls_out">  # spent  36.9ms making 3 calls to <a href="XML-SAX-ParserFactory-pm-block.html#22">XML::SAX::ParserFactory::parser</a>, avg 12.3ms/call</div></div></td></tr>
<tr><td class="h"><a name="359"></a>359</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="360"></a>360</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;{nocollapse} = 1;</td></tr>
<tr><td class="h"><a name="361"></a>361</td><td></td><td></td><td></td><td></td><td class="s">  my($tree);</td></tr>
<tr><td class="h"><a name="362"></a>362</td><td class="c3">3</td><td class="c3"><span title="Avg 2&micro;s">6&micro;s</span></td><td></td><td></td><td class="s">  if($filename) {</td></tr>
<tr><td class="h"><a name="363"></a>363</td><td></td><td></td><td></td><td></td><td class="s">    $tree = $sp-&gt;parse_uri($filename);</td></tr>
<tr><td class="h"><a name="364"></a>364</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="365"></a>365</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="366"></a>366</td><td class="c3">3</td><td class="c3"><span title="Avg 4&micro;s">12&micro;s</span></td><td></td><td></td><td class="s">    if(ref($string) &amp;&amp; ref($string) ne 'SCALAR') {</td></tr>
<tr><td class="h"><a name="367"></a>367</td><td></td><td></td><td></td><td></td><td class="s">      $tree = $sp-&gt;parse_file($string);</td></tr>
<tr><td class="h"><a name="368"></a>368</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="369"></a>369</td><td></td><td></td><td></td><td></td><td class="s">    else {</td></tr>
<tr><td class="h"><a name="370"></a>370</td><td></td><td></td><td></td><td></td><td class="s">      $tree = $sp-&gt;parse_string($$string);<div class="calls"><div class="calls_out">      # spent  3.95ms making 3 calls to <a href="XML-SAX-Base-pm-block.html#2650">XML::SAX::Base::parse_string</a>, avg 1.32ms/call</div></div></td></tr>
<tr><td class="h"><a name="371"></a>371</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="372"></a>372</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="373"></a>373</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="374"></a>374</td><td></td><td></td><td></td><td></td><td class="s">  return($tree);</td></tr>
<tr><td class="h"><a name="375"></a>375</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="376"></a>376</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="377"></a>377</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="378"></a>378</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="379"></a>379</td><td></td><td></td><td></td><td></td><td class="s"># Method: build_tree_xml_parser()</td></tr>
<tr><td class="h"><a name="380"></a>380</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="381"></a>381</td><td></td><td></td><td></td><td></td><td class="s"># This routine will be called if XML::SAX is not installed, or if XML::Parser</td></tr>
<tr><td class="h"><a name="382"></a>382</td><td></td><td></td><td></td><td></td><td class="s"># was specifically requested.  It takes the same arguments as build_tree() and</td></tr>
<tr><td class="h"><a name="383"></a>383</td><td></td><td></td><td></td><td></td><td class="s"># returns the same data structure (XML::Parser 'Tree' style).</td></tr>
<tr><td class="h"><a name="384"></a>384</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="385"></a>385</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="386"></a>386</td><td></td><td></td><td></td><td></td><td class="s">sub build_tree_xml_parser {</td></tr>
<tr><td class="h"><a name="387"></a>387</td><td></td><td></td><td></td><td></td><td class="s">  my $self     = shift;</td></tr>
<tr><td class="h"><a name="388"></a>388</td><td></td><td></td><td></td><td></td><td class="s">  my $filename = shift;</td></tr>
<tr><td class="h"><a name="389"></a>389</td><td></td><td></td><td></td><td></td><td class="s">  my $string   = shift;</td></tr>
<tr><td class="h"><a name="390"></a>390</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="391"></a>391</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="392"></a>392</td><td></td><td></td><td></td><td></td><td class="s">  eval {</td></tr>
<tr><td class="h"><a name="393"></a>393</td><td></td><td></td><td></td><td></td><td class="s">    local($^W) = 0;      # Suppress warning from Expat.pm re File::Spec::load()</td></tr>
<tr><td class="h"><a name="394"></a>394</td><td></td><td></td><td></td><td></td><td class="s">    require XML::Parser; # We didn't need it until now</td></tr>
<tr><td class="h"><a name="395"></a>395</td><td></td><td></td><td></td><td></td><td class="s">  };</td></tr>
<tr><td class="h"><a name="396"></a>396</td><td></td><td></td><td></td><td></td><td class="s">  if($@) {</td></tr>
<tr><td class="h"><a name="397"></a>397</td><td></td><td></td><td></td><td></td><td class="s">    croak &quot;XMLin() requires either XML::SAX or XML::Parser&quot;;</td></tr>
<tr><td class="h"><a name="398"></a>398</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="399"></a>399</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="400"></a>400</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{nsexpand}) {</td></tr>
<tr><td class="h"><a name="401"></a>401</td><td></td><td></td><td></td><td></td><td class="s">    carp &quot;'nsexpand' option requires XML::SAX&quot;;</td></tr>
<tr><td class="h"><a name="402"></a>402</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="403"></a>403</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="404"></a>404</td><td></td><td></td><td></td><td></td><td class="s">  my $xp = XML::Parser-&gt;new(Style =&gt; 'Tree', @{$self-&gt;{opt}-&gt;{parseropts}});</td></tr>
<tr><td class="h"><a name="405"></a>405</td><td></td><td></td><td></td><td></td><td class="s">  my($tree);</td></tr>
<tr><td class="h"><a name="406"></a>406</td><td></td><td></td><td></td><td></td><td class="s">  if($filename) {</td></tr>
<tr><td class="h"><a name="407"></a>407</td><td></td><td></td><td></td><td></td><td class="s">    # $tree = $xp-&gt;parsefile($filename);  # Changed due to prob w/mod_perl</td></tr>
<tr><td class="h"><a name="408"></a>408</td><td></td><td></td><td></td><td></td><td class="s">    local(*XML_FILE);</td></tr>
<tr><td class="h"><a name="409"></a>409</td><td></td><td></td><td></td><td></td><td class="s">    open(XML_FILE, '&lt;', $filename) || croak qq($filename - $!);</td></tr>
<tr><td class="h"><a name="410"></a>410</td><td></td><td></td><td></td><td></td><td class="s">    $tree = $xp-&gt;parse(*XML_FILE);</td></tr>
<tr><td class="h"><a name="411"></a>411</td><td></td><td></td><td></td><td></td><td class="s">    close(XML_FILE);</td></tr>
<tr><td class="h"><a name="412"></a>412</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="413"></a>413</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="414"></a>414</td><td></td><td></td><td></td><td></td><td class="s">    $tree = $xp-&gt;parse($$string);</td></tr>
<tr><td class="h"><a name="415"></a>415</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="416"></a>416</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="417"></a>417</td><td></td><td></td><td></td><td></td><td class="s">  return($tree);</td></tr>
<tr><td class="h"><a name="418"></a>418</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="419"></a>419</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="420"></a>420</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="421"></a>421</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="422"></a>422</td><td></td><td></td><td></td><td></td><td class="s"># Method: cache_write_storable()</td></tr>
<tr><td class="h"><a name="423"></a>423</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="424"></a>424</td><td></td><td></td><td></td><td></td><td class="s"># Wrapper routine for invoking Storable::nstore() to cache a parsed data</td></tr>
<tr><td class="h"><a name="425"></a>425</td><td></td><td></td><td></td><td></td><td class="s"># structure.</td></tr>
<tr><td class="h"><a name="426"></a>426</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="427"></a>427</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="428"></a>428</td><td></td><td></td><td></td><td></td><td class="s">sub cache_write_storable {</td></tr>
<tr><td class="h"><a name="429"></a>429</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $data, $filename) = @_;</td></tr>
<tr><td class="h"><a name="430"></a>430</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="431"></a>431</td><td></td><td></td><td></td><td></td><td class="s">  my $cachefile = $self-&gt;storable_filename($filename);</td></tr>
<tr><td class="h"><a name="432"></a>432</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="433"></a>433</td><td></td><td></td><td></td><td></td><td class="s">  require Storable;           # We didn't need it until now</td></tr>
<tr><td class="h"><a name="434"></a>434</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="435"></a>435</td><td></td><td></td><td></td><td></td><td class="s">  if ('VMS' eq $^O) {</td></tr>
<tr><td class="h"><a name="436"></a>436</td><td></td><td></td><td></td><td></td><td class="s">    Storable::nstore($data, $cachefile);</td></tr>
<tr><td class="h"><a name="437"></a>437</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="438"></a>438</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="439"></a>439</td><td></td><td></td><td></td><td></td><td class="s">    # If the following line fails for you, your Storable.pm is old - upgrade</td></tr>
<tr><td class="h"><a name="440"></a>440</td><td></td><td></td><td></td><td></td><td class="s">    Storable::lock_nstore($data, $cachefile);</td></tr>
<tr><td class="h"><a name="441"></a>441</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="442"></a>442</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="443"></a>443</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="444"></a>444</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="445"></a>445</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="446"></a>446</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="447"></a>447</td><td></td><td></td><td></td><td></td><td class="s"># Method: cache_read_storable()</td></tr>
<tr><td class="h"><a name="448"></a>448</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="449"></a>449</td><td></td><td></td><td></td><td></td><td class="s"># Wrapper routine for invoking Storable::retrieve() to read a cached parsed</td></tr>
<tr><td class="h"><a name="450"></a>450</td><td></td><td></td><td></td><td></td><td class="s"># data structure.  Only returns cached data if the cache file exists and is</td></tr>
<tr><td class="h"><a name="451"></a>451</td><td></td><td></td><td></td><td></td><td class="s"># newer than the source XML file.</td></tr>
<tr><td class="h"><a name="452"></a>452</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="453"></a>453</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="454"></a>454</td><td></td><td></td><td></td><td></td><td class="s">sub cache_read_storable {</td></tr>
<tr><td class="h"><a name="455"></a>455</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $filename) = @_;</td></tr>
<tr><td class="h"><a name="456"></a>456</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="457"></a>457</td><td></td><td></td><td></td><td></td><td class="s">  my $cachefile = $self-&gt;storable_filename($filename);</td></tr>
<tr><td class="h"><a name="458"></a>458</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="459"></a>459</td><td></td><td></td><td></td><td></td><td class="s">  return unless(-r $cachefile);</td></tr>
<tr><td class="h"><a name="460"></a>460</td><td></td><td></td><td></td><td></td><td class="s">  return unless((stat($cachefile))[9] &gt; (stat($filename))[9]);</td></tr>
<tr><td class="h"><a name="461"></a>461</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="462"></a>462</td><td></td><td></td><td></td><td></td><td class="s">  require Storable;           # We didn't need it until now</td></tr>
<tr><td class="h"><a name="463"></a>463</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="464"></a>464</td><td></td><td></td><td></td><td></td><td class="s">  if ('VMS' eq $^O) {</td></tr>
<tr><td class="h"><a name="465"></a>465</td><td></td><td></td><td></td><td></td><td class="s">    return(Storable::retrieve($cachefile));</td></tr>
<tr><td class="h"><a name="466"></a>466</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="467"></a>467</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="468"></a>468</td><td></td><td></td><td></td><td></td><td class="s">    return(Storable::lock_retrieve($cachefile));</td></tr>
<tr><td class="h"><a name="469"></a>469</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="470"></a>470</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="471"></a>471</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="472"></a>472</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="473"></a>473</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="474"></a>474</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="475"></a>475</td><td></td><td></td><td></td><td></td><td class="s"># Method: storable_filename()</td></tr>
<tr><td class="h"><a name="476"></a>476</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="477"></a>477</td><td></td><td></td><td></td><td></td><td class="s"># Translates the supplied source XML filename into a filename for the storable</td></tr>
<tr><td class="h"><a name="478"></a>478</td><td></td><td></td><td></td><td></td><td class="s"># cached data.  A '.stor' suffix is added after stripping an optional '.xml'</td></tr>
<tr><td class="h"><a name="479"></a>479</td><td></td><td></td><td></td><td></td><td class="s"># suffix.</td></tr>
<tr><td class="h"><a name="480"></a>480</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="481"></a>481</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="482"></a>482</td><td></td><td></td><td></td><td></td><td class="s">sub storable_filename {</td></tr>
<tr><td class="h"><a name="483"></a>483</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $cachefile) = @_;</td></tr>
<tr><td class="h"><a name="484"></a>484</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="485"></a>485</td><td></td><td></td><td></td><td></td><td class="s">  $cachefile =~ s{(\.xml)?$}{.stor};</td></tr>
<tr><td class="h"><a name="486"></a>486</td><td></td><td></td><td></td><td></td><td class="s">  return $cachefile;</td></tr>
<tr><td class="h"><a name="487"></a>487</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="488"></a>488</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="489"></a>489</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="490"></a>490</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="491"></a>491</td><td></td><td></td><td></td><td></td><td class="s"># Method: cache_write_memshare()</td></tr>
<tr><td class="h"><a name="492"></a>492</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="493"></a>493</td><td></td><td></td><td></td><td></td><td class="s"># Takes the supplied data structure reference and stores it away in a global</td></tr>
<tr><td class="h"><a name="494"></a>494</td><td></td><td></td><td></td><td></td><td class="s"># hash structure.</td></tr>
<tr><td class="h"><a name="495"></a>495</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="496"></a>496</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="497"></a>497</td><td></td><td></td><td></td><td></td><td class="s">sub cache_write_memshare {</td></tr>
<tr><td class="h"><a name="498"></a>498</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $data, $filename) = @_;</td></tr>
<tr><td class="h"><a name="499"></a>499</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="500"></a>500</td><td></td><td></td><td></td><td></td><td class="s">  $MemShareCache{$filename} = [time(), $data];</td></tr>
<tr><td class="h"><a name="501"></a>501</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="502"></a>502</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="503"></a>503</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="504"></a>504</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="505"></a>505</td><td></td><td></td><td></td><td></td><td class="s"># Method: cache_read_memshare()</td></tr>
<tr><td class="h"><a name="506"></a>506</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="507"></a>507</td><td></td><td></td><td></td><td></td><td class="s"># Takes a filename and looks in a global hash for a cached parsed version.</td></tr>
<tr><td class="h"><a name="508"></a>508</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="509"></a>509</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="510"></a>510</td><td></td><td></td><td></td><td></td><td class="s">sub cache_read_memshare {</td></tr>
<tr><td class="h"><a name="511"></a>511</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $filename) = @_;</td></tr>
<tr><td class="h"><a name="512"></a>512</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="513"></a>513</td><td></td><td></td><td></td><td></td><td class="s">  return unless($MemShareCache{$filename});</td></tr>
<tr><td class="h"><a name="514"></a>514</td><td></td><td></td><td></td><td></td><td class="s">  return unless($MemShareCache{$filename}-&gt;[0] &gt; (stat($filename))[9]);</td></tr>
<tr><td class="h"><a name="515"></a>515</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="516"></a>516</td><td></td><td></td><td></td><td></td><td class="s">  return($MemShareCache{$filename}-&gt;[1]);</td></tr>
<tr><td class="h"><a name="517"></a>517</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="518"></a>518</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="519"></a>519</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="520"></a>520</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="521"></a>521</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="522"></a>522</td><td></td><td></td><td></td><td></td><td class="s"># Method: cache_write_memcopy()</td></tr>
<tr><td class="h"><a name="523"></a>523</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="524"></a>524</td><td></td><td></td><td></td><td></td><td class="s"># Takes the supplied data structure and stores a copy of it in a global hash</td></tr>
<tr><td class="h"><a name="525"></a>525</td><td></td><td></td><td></td><td></td><td class="s"># structure.</td></tr>
<tr><td class="h"><a name="526"></a>526</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="527"></a>527</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="528"></a>528</td><td></td><td></td><td></td><td></td><td class="s">sub cache_write_memcopy {</td></tr>
<tr><td class="h"><a name="529"></a>529</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $data, $filename) = @_;</td></tr>
<tr><td class="h"><a name="530"></a>530</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="531"></a>531</td><td></td><td></td><td></td><td></td><td class="s">  require Storable;           # We didn't need it until now</td></tr>
<tr><td class="h"><a name="532"></a>532</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="533"></a>533</td><td></td><td></td><td></td><td></td><td class="s">  $MemCopyCache{$filename} = [time(), Storable::dclone($data)];</td></tr>
<tr><td class="h"><a name="534"></a>534</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="535"></a>535</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="536"></a>536</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="537"></a>537</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="538"></a>538</td><td></td><td></td><td></td><td></td><td class="s"># Method: cache_read_memcopy()</td></tr>
<tr><td class="h"><a name="539"></a>539</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="540"></a>540</td><td></td><td></td><td></td><td></td><td class="s"># Takes a filename and looks in a global hash for a cached parsed version.</td></tr>
<tr><td class="h"><a name="541"></a>541</td><td></td><td></td><td></td><td></td><td class="s"># Returns a reference to a copy of that data structure.</td></tr>
<tr><td class="h"><a name="542"></a>542</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="543"></a>543</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="544"></a>544</td><td></td><td></td><td></td><td></td><td class="s">sub cache_read_memcopy {</td></tr>
<tr><td class="h"><a name="545"></a>545</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $filename) = @_;</td></tr>
<tr><td class="h"><a name="546"></a>546</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="547"></a>547</td><td></td><td></td><td></td><td></td><td class="s">  return unless($MemCopyCache{$filename});</td></tr>
<tr><td class="h"><a name="548"></a>548</td><td></td><td></td><td></td><td></td><td class="s">  return unless($MemCopyCache{$filename}-&gt;[0] &gt; (stat($filename))[9]);</td></tr>
<tr><td class="h"><a name="549"></a>549</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="550"></a>550</td><td></td><td></td><td></td><td></td><td class="s">  return(Storable::dclone($MemCopyCache{$filename}-&gt;[1]));</td></tr>
<tr><td class="h"><a name="551"></a>551</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="552"></a>552</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="553"></a>553</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="554"></a>554</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="555"></a>555</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="556"></a>556</td><td></td><td></td><td></td><td></td><td class="s"># Sub/Method: XMLout()</td></tr>
<tr><td class="h"><a name="557"></a>557</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="558"></a>558</td><td></td><td></td><td></td><td></td><td class="s"># Exported routine for 'unslurping' a data structure out to XML.</td></tr>
<tr><td class="h"><a name="559"></a>559</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="560"></a>560</td><td></td><td></td><td></td><td></td><td class="s"># Expects a reference to a data structure and an optional list of option</td></tr>
<tr><td class="h"><a name="561"></a>561</td><td></td><td></td><td></td><td></td><td class="s"># name =&gt; value pairs.</td></tr>
<tr><td class="h"><a name="562"></a>562</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="563"></a>563</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="564"></a>564</td><td></td><td></td><td></td><td></td><td class="s">sub XMLout {</td></tr>
<tr><td class="h"><a name="565"></a>565</td><td></td><td></td><td></td><td></td><td class="s">  my $self = &amp;_get_object;      # note, @_ is passed implicitly</td></tr>
<tr><td class="h"><a name="566"></a>566</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="567"></a>567</td><td></td><td></td><td></td><td></td><td class="s">  croak &quot;XMLout() requires at least one argument&quot; unless(@_);</td></tr>
<tr><td class="h"><a name="568"></a>568</td><td></td><td></td><td></td><td></td><td class="s">  my $ref = shift;</td></tr>
<tr><td class="h"><a name="569"></a>569</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="570"></a>570</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;handle_options('out', @_);</td></tr>
<tr><td class="h"><a name="571"></a>571</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="572"></a>572</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="573"></a>573</td><td></td><td></td><td></td><td></td><td class="s">  # If namespace expansion is set, XML::NamespaceSupport is required</td></tr>
<tr><td class="h"><a name="574"></a>574</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="575"></a>575</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{nsexpand}) {</td></tr>
<tr><td class="h"><a name="576"></a>576</td><td></td><td></td><td></td><td></td><td class="s">    require XML::NamespaceSupport;</td></tr>
<tr><td class="h"><a name="577"></a>577</td><td></td><td></td><td></td><td></td><td class="s">    $self-&gt;{nsup} = XML::NamespaceSupport-&gt;new();</td></tr>
<tr><td class="h"><a name="578"></a>578</td><td></td><td></td><td></td><td></td><td class="s">    $self-&gt;{ns_prefix} = 'aaa';</td></tr>
<tr><td class="h"><a name="579"></a>579</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="580"></a>580</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="581"></a>581</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="582"></a>582</td><td></td><td></td><td></td><td></td><td class="s">  # Wrap top level arrayref in a hash</td></tr>
<tr><td class="h"><a name="583"></a>583</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="584"></a>584</td><td></td><td></td><td></td><td></td><td class="s">  if(UNIVERSAL::isa($ref, 'ARRAY')) {</td></tr>
<tr><td class="h"><a name="585"></a>585</td><td></td><td></td><td></td><td></td><td class="s">    $ref = { anon =&gt; $ref };</td></tr>
<tr><td class="h"><a name="586"></a>586</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="587"></a>587</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="588"></a>588</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="589"></a>589</td><td></td><td></td><td></td><td></td><td class="s">  # Extract rootname from top level hash if keeproot enabled</td></tr>
<tr><td class="h"><a name="590"></a>590</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="591"></a>591</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{keeproot}) {</td></tr>
<tr><td class="h"><a name="592"></a>592</td><td></td><td></td><td></td><td></td><td class="s">    my(@keys) = keys(%$ref);</td></tr>
<tr><td class="h"><a name="593"></a>593</td><td></td><td></td><td></td><td></td><td class="s">    if(@keys == 1) {</td></tr>
<tr><td class="h"><a name="594"></a>594</td><td></td><td></td><td></td><td></td><td class="s">      $ref = $ref-&gt;{$keys[0]};</td></tr>
<tr><td class="h"><a name="595"></a>595</td><td></td><td></td><td></td><td></td><td class="s">      $self-&gt;{opt}-&gt;{rootname} = $keys[0];</td></tr>
<tr><td class="h"><a name="596"></a>596</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="597"></a>597</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="598"></a>598</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="599"></a>599</td><td></td><td></td><td></td><td></td><td class="s">  # Ensure there are no top level attributes if we're not adding root elements</td></tr>
<tr><td class="h"><a name="600"></a>600</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="601"></a>601</td><td></td><td></td><td></td><td></td><td class="s">  elsif($self-&gt;{opt}-&gt;{rootname} eq '') {</td></tr>
<tr><td class="h"><a name="602"></a>602</td><td></td><td></td><td></td><td></td><td class="s">    if(UNIVERSAL::isa($ref, 'HASH')) {</td></tr>
<tr><td class="h"><a name="603"></a>603</td><td></td><td></td><td></td><td></td><td class="s">      my $refsave = $ref;</td></tr>
<tr><td class="h"><a name="604"></a>604</td><td></td><td></td><td></td><td></td><td class="s">      $ref = {};</td></tr>
<tr><td class="h"><a name="605"></a>605</td><td></td><td></td><td></td><td></td><td class="s">      foreach (keys(%$refsave)) {</td></tr>
<tr><td class="h"><a name="606"></a>606</td><td></td><td></td><td></td><td></td><td class="s">        if(ref($refsave-&gt;{$_})) {</td></tr>
<tr><td class="h"><a name="607"></a>607</td><td></td><td></td><td></td><td></td><td class="s">          $ref-&gt;{$_} = $refsave-&gt;{$_};</td></tr>
<tr><td class="h"><a name="608"></a>608</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="609"></a>609</td><td></td><td></td><td></td><td></td><td class="s">        else {</td></tr>
<tr><td class="h"><a name="610"></a>610</td><td></td><td></td><td></td><td></td><td class="s">          $ref-&gt;{$_} = [ $refsave-&gt;{$_} ];</td></tr>
<tr><td class="h"><a name="611"></a>611</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="612"></a>612</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="613"></a>613</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="614"></a>614</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="615"></a>615</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="616"></a>616</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="617"></a>617</td><td></td><td></td><td></td><td></td><td class="s">  # Encode the hashref and write to file if necessary</td></tr>
<tr><td class="h"><a name="618"></a>618</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="619"></a>619</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;{_ancestors} = [];</td></tr>
<tr><td class="h"><a name="620"></a>620</td><td></td><td></td><td></td><td></td><td class="s">  my $xml = $self-&gt;value_to_xml($ref, $self-&gt;{opt}-&gt;{rootname}, '');</td></tr>
<tr><td class="h"><a name="621"></a>621</td><td></td><td></td><td></td><td></td><td class="s">  delete $self-&gt;{_ancestors};</td></tr>
<tr><td class="h"><a name="622"></a>622</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="623"></a>623</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{xmldecl}) {</td></tr>
<tr><td class="h"><a name="624"></a>624</td><td></td><td></td><td></td><td></td><td class="s">    $xml = $self-&gt;{opt}-&gt;{xmldecl} . &quot;\n&quot; . $xml;</td></tr>
<tr><td class="h"><a name="625"></a>625</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="626"></a>626</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="627"></a>627</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{outputfile}) {</td></tr>
<tr><td class="h"><a name="628"></a>628</td><td></td><td></td><td></td><td></td><td class="s">    if(ref($self-&gt;{opt}-&gt;{outputfile})) {</td></tr>
<tr><td class="h"><a name="629"></a>629</td><td></td><td></td><td></td><td></td><td class="s">      my $fh = $self-&gt;{opt}-&gt;{outputfile};</td></tr>
<tr><td class="h"><a name="630"></a>630</td><td></td><td></td><td></td><td></td><td class="s">      if(UNIVERSAL::isa($fh, 'GLOB') and !UNIVERSAL::can($fh, 'print')) {</td></tr>
<tr><td class="h"><a name="631"></a>631</td><td></td><td></td><td></td><td></td><td class="s">        eval { require IO::Handle; };</td></tr>
<tr><td class="h"><a name="632"></a>632</td><td></td><td></td><td></td><td></td><td class="s">        croak $@ if $@;</td></tr>
<tr><td class="h"><a name="633"></a>633</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="634"></a>634</td><td></td><td></td><td></td><td></td><td class="s">      return($fh-&gt;print($xml));</td></tr>
<tr><td class="h"><a name="635"></a>635</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="636"></a>636</td><td></td><td></td><td></td><td></td><td class="s">    else {</td></tr>
<tr><td class="h"><a name="637"></a>637</td><td></td><td></td><td></td><td></td><td class="s">      local(*OUT);</td></tr>
<tr><td class="h"><a name="638"></a>638</td><td></td><td></td><td></td><td></td><td class="s">      open(OUT, '&gt;', &quot;$self-&gt;{opt}-&gt;{outputfile}&quot;) ||</td></tr>
<tr><td class="h"><a name="639"></a>639</td><td></td><td></td><td></td><td></td><td class="s">        croak &quot;open($self-&gt;{opt}-&gt;{outputfile}): $!&quot;;</td></tr>
<tr><td class="h"><a name="640"></a>640</td><td></td><td></td><td></td><td></td><td class="s">      binmode(OUT, ':utf8') if($] &gt;= 5.008);</td></tr>
<tr><td class="h"><a name="641"></a>641</td><td></td><td></td><td></td><td></td><td class="s">      print OUT $xml || croak &quot;print: $!&quot;;</td></tr>
<tr><td class="h"><a name="642"></a>642</td><td></td><td></td><td></td><td></td><td class="s">      close(OUT);</td></tr>
<tr><td class="h"><a name="643"></a>643</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="644"></a>644</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="645"></a>645</td><td></td><td></td><td></td><td></td><td class="s">  elsif($self-&gt;{opt}-&gt;{handler}) {</td></tr>
<tr><td class="h"><a name="646"></a>646</td><td></td><td></td><td></td><td></td><td class="s">    require XML::SAX;</td></tr>
<tr><td class="h"><a name="647"></a>647</td><td></td><td></td><td></td><td></td><td class="s">    my $sp = XML::SAX::ParserFactory-&gt;parser(</td></tr>
<tr><td class="h"><a name="648"></a>648</td><td></td><td></td><td></td><td></td><td class="s">               Handler =&gt; $self-&gt;{opt}-&gt;{handler}</td></tr>
<tr><td class="h"><a name="649"></a>649</td><td></td><td></td><td></td><td></td><td class="s">             );</td></tr>
<tr><td class="h"><a name="650"></a>650</td><td></td><td></td><td></td><td></td><td class="s">    return($sp-&gt;parse_string($xml));</td></tr>
<tr><td class="h"><a name="651"></a>651</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="652"></a>652</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="653"></a>653</td><td></td><td></td><td></td><td></td><td class="s">    return($xml);</td></tr>
<tr><td class="h"><a name="654"></a>654</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="655"></a>655</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="656"></a>656</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="657"></a>657</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="658"></a>658</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="659"></a>659</td><td></td><td></td><td></td><td></td><td class="s"># Method: handle_options()</td></tr>
<tr><td class="h"><a name="660"></a>660</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="661"></a>661</td><td></td><td></td><td></td><td></td><td class="s"># Helper routine for both XMLin() and XMLout().  Both routines handle their</td></tr>
<tr><td class="h"><a name="662"></a>662</td><td></td><td></td><td></td><td></td><td class="s"># first argument and assume all other args are options handled by this routine.</td></tr>
<tr><td class="h"><a name="663"></a>663</td><td></td><td></td><td></td><td></td><td class="s"># Saves a hash of options in $self-&gt;{opt}.</td></tr>
<tr><td class="h"><a name="664"></a>664</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="665"></a>665</td><td></td><td></td><td></td><td></td><td class="s"># If default options were passed to the constructor, they will be retrieved</td></tr>
<tr><td class="h"><a name="666"></a>666</td><td></td><td></td><td></td><td></td><td class="s"># here and merged with options supplied to the method call.</td></tr>
<tr><td class="h"><a name="667"></a>667</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="668"></a>668</td><td></td><td></td><td></td><td></td><td class="s"># First argument should be the string 'in' or the string 'out'.</td></tr>
<tr><td class="h"><a name="669"></a>669</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="670"></a>670</td><td></td><td></td><td></td><td></td><td class="s"># Remaining arguments should be name=&gt;value pairs.  Sets up default values</td></tr>
<tr><td class="h"><a name="671"></a>671</td><td></td><td></td><td></td><td></td><td class="s"># for options not supplied.  Unrecognised options are a fatal error.</td></tr>
<tr><td class="h"><a name="672"></a>672</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="673"></a>673</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="674"></a>674</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 350&micro;s (347+3) within XML::Simple::handle_options which was called 3 times, avg 117&micro;s/call:
# 3 times (347&micro;s+3&micro;s) by XML::Simple::parse_string at <a href="XML-Simple-pm-block.html#268">line 268</a>, avg 117&micro;s/call</div></div>sub handle_options  {</td></tr>
<tr><td class="h"><a name="675"></a>675</td><td class="c0">75</td><td class="c0"><span title="Avg 3&micro;s">194&micro;s</span></td><td></td><td></td><td class="s">  my $self = shift;</td></tr>
<tr><td class="h"><a name="676"></a>676</td><td></td><td></td><td></td><td></td><td class="s">  my $dirn = shift;</td></tr>
<tr><td class="h"><a name="677"></a>677</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="678"></a>678</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="679"></a>679</td><td></td><td></td><td></td><td></td><td class="s">  # Determine valid options based on context</td></tr>
<tr><td class="h"><a name="680"></a>680</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="681"></a>681</td><td></td><td></td><td></td><td></td><td class="s">  my %known_opt; </td></tr>
<tr><td class="h"><a name="682"></a>682</td><td></td><td></td><td></td><td></td><td class="s">  if($dirn eq 'in') {</td></tr>
<tr><td class="h"><a name="683"></a>683</td><td></td><td></td><td></td><td></td><td class="s">    @known_opt{@KnownOptIn} = @KnownOptIn;</td></tr>
<tr><td class="h"><a name="684"></a>684</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="685"></a>685</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="686"></a>686</td><td></td><td></td><td></td><td></td><td class="s">    @known_opt{@KnownOptOut} = @KnownOptOut;</td></tr>
<tr><td class="h"><a name="687"></a>687</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="688"></a>688</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="689"></a>689</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="690"></a>690</td><td></td><td></td><td></td><td></td><td class="s">  # Store supplied options in hashref and weed out invalid ones</td></tr>
<tr><td class="h"><a name="691"></a>691</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="692"></a>692</td><td></td><td></td><td></td><td></td><td class="s">  if(@_ % 2) {</td></tr>
<tr><td class="h"><a name="693"></a>693</td><td></td><td></td><td></td><td></td><td class="s">    croak &quot;Options must be name=&gt;value pairs (odd number supplied)&quot;;</td></tr>
<tr><td class="h"><a name="694"></a>694</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="695"></a>695</td><td></td><td></td><td></td><td></td><td class="s">  my %raw_opt  = @_;</td></tr>
<tr><td class="h"><a name="696"></a>696</td><td></td><td></td><td></td><td></td><td class="s">  my $opt      = {};</td></tr>
<tr><td class="h"><a name="697"></a>697</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;{opt} = $opt;</td></tr>
<tr><td class="h"><a name="698"></a>698</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="699"></a>699</td><td class="c0">12</td><td class="c1"><span title="Avg 2&micro;s">27&micro;s</span></td><td></td><td></td><td class="s">  while(my($key, $val) = each %raw_opt) {</td></tr>
<tr><td class="h"><a name="700"></a>700</td><td class="c3">1</td><td class="c3"><span title="Avg 5&micro;s">5&micro;s</span></td><td></td><td></td><td class="s">    my $lkey = lc($key);</td></tr>
<tr><td class="h"><a name="701"></a>701</td><td></td><td></td><td></td><td></td><td class="s">    $lkey =~ s/_//g;<div class="calls"><div class="calls_out">    # spent     3&micro;s making 3 calls to <a href="XML-Simple-pm-block.html#XML__Simple__CORE_subst">XML::Simple::CORE:subst</a>, avg 1&micro;s/call</div></div></td></tr>
<tr><td class="h"><a name="702"></a>702</td><td></td><td></td><td></td><td></td><td class="s">    croak &quot;Unrecognised option: $key&quot; unless($known_opt{$lkey});</td></tr>
<tr><td class="h"><a name="703"></a>703</td><td></td><td></td><td></td><td></td><td class="s">    $opt-&gt;{$lkey} = $val;</td></tr>
<tr><td class="h"><a name="704"></a>704</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="705"></a>705</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="706"></a>706</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="707"></a>707</td><td></td><td></td><td></td><td></td><td class="s">  # Merge in options passed to constructor</td></tr>
<tr><td class="h"><a name="708"></a>708</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="709"></a>709</td><td></td><td></td><td></td><td></td><td class="s">  foreach (keys(%known_opt)) {</td></tr>
<tr><td class="h"><a name="710"></a>710</td><td class="c0">54</td><td class="c0"><span title="Avg 622ns">34&micro;s</span></td><td></td><td></td><td class="s">    unless(exists($opt-&gt;{$_})) {</td></tr>
<tr><td class="h"><a name="711"></a>711</td><td></td><td></td><td></td><td></td><td class="s">      if(exists($self-&gt;{def_opt}-&gt;{$_})) {</td></tr>
<tr><td class="h"><a name="712"></a>712</td><td></td><td></td><td></td><td></td><td class="s">        $opt-&gt;{$_} = $self-&gt;{def_opt}-&gt;{$_};</td></tr>
<tr><td class="h"><a name="713"></a>713</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="714"></a>714</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="715"></a>715</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="716"></a>716</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="717"></a>717</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="718"></a>718</td><td></td><td></td><td></td><td></td><td class="s">  # Set sensible defaults if not supplied</td></tr>
<tr><td class="h"><a name="719"></a>719</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="720"></a>720</td><td class="c3">3</td><td class="c3"><span title="Avg 2&micro;s">5&micro;s</span></td><td></td><td></td><td class="s">  if(exists($opt-&gt;{rootname})) {</td></tr>
<tr><td class="h"><a name="721"></a>721</td><td></td><td></td><td></td><td></td><td class="s">    unless(defined($opt-&gt;{rootname})) {</td></tr>
<tr><td class="h"><a name="722"></a>722</td><td></td><td></td><td></td><td></td><td class="s">      $opt-&gt;{rootname} = '';</td></tr>
<tr><td class="h"><a name="723"></a>723</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="724"></a>724</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="725"></a>725</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="726"></a>726</td><td></td><td></td><td></td><td></td><td class="s">    $opt-&gt;{rootname} = $DefRootName;</td></tr>
<tr><td class="h"><a name="727"></a>727</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="728"></a>728</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="729"></a>729</td><td></td><td></td><td></td><td></td><td class="s">  if($opt-&gt;{xmldecl}  and  $opt-&gt;{xmldecl} eq '1') {</td></tr>
<tr><td class="h"><a name="730"></a>730</td><td></td><td></td><td></td><td></td><td class="s">    $opt-&gt;{xmldecl} = $DefXmlDecl;</td></tr>
<tr><td class="h"><a name="731"></a>731</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="732"></a>732</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="733"></a>733</td><td class="c3">3</td><td class="c3"><span title="Avg 1&micro;s">4&micro;s</span></td><td></td><td></td><td class="s">  if(exists($opt-&gt;{contentkey})) {</td></tr>
<tr><td class="h"><a name="734"></a>734</td><td></td><td></td><td></td><td></td><td class="s">    if($opt-&gt;{contentkey} =~ m{^-(.*)$}) {</td></tr>
<tr><td class="h"><a name="735"></a>735</td><td></td><td></td><td></td><td></td><td class="s">      $opt-&gt;{contentkey} = $1;</td></tr>
<tr><td class="h"><a name="736"></a>736</td><td></td><td></td><td></td><td></td><td class="s">      $opt-&gt;{collapseagain} = 1;</td></tr>
<tr><td class="h"><a name="737"></a>737</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="738"></a>738</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="739"></a>739</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="740"></a>740</td><td></td><td></td><td></td><td></td><td class="s">    $opt-&gt;{contentkey} = $DefContentKey;</td></tr>
<tr><td class="h"><a name="741"></a>741</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="742"></a>742</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="743"></a>743</td><td></td><td></td><td></td><td></td><td class="s">  unless(exists($opt-&gt;{normalisespace})) {</td></tr>
<tr><td class="h"><a name="744"></a>744</td><td></td><td></td><td></td><td></td><td class="s">    $opt-&gt;{normalisespace} = $opt-&gt;{normalizespace};</td></tr>
<tr><td class="h"><a name="745"></a>745</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="746"></a>746</td><td></td><td></td><td></td><td></td><td class="s">  $opt-&gt;{normalisespace} = 0 unless(defined($opt-&gt;{normalisespace}));</td></tr>
<tr><td class="h"><a name="747"></a>747</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="748"></a>748</td><td></td><td></td><td></td><td></td><td class="s">  # Cleanups for values assumed to be arrays later</td></tr>
<tr><td class="h"><a name="749"></a>749</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="750"></a>750</td><td class="c3">3</td><td class="c3"><span title="Avg 3&micro;s">10&micro;s</span></td><td></td><td></td><td class="s">  if($opt-&gt;{searchpath}) {</td></tr>
<tr><td class="h"><a name="751"></a>751</td><td></td><td></td><td></td><td></td><td class="s">    unless(ref($opt-&gt;{searchpath})) {</td></tr>
<tr><td class="h"><a name="752"></a>752</td><td></td><td></td><td></td><td></td><td class="s">      $opt-&gt;{searchpath} = [ $opt-&gt;{searchpath} ];</td></tr>
<tr><td class="h"><a name="753"></a>753</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="754"></a>754</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="755"></a>755</td><td></td><td></td><td></td><td></td><td class="s">  else  {</td></tr>
<tr><td class="h"><a name="756"></a>756</td><td></td><td></td><td></td><td></td><td class="s">    $opt-&gt;{searchpath} = [ ];</td></tr>
<tr><td class="h"><a name="757"></a>757</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="758"></a>758</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="759"></a>759</td><td></td><td></td><td></td><td></td><td class="s">  if($opt-&gt;{cache}  and !ref($opt-&gt;{cache})) {</td></tr>
<tr><td class="h"><a name="760"></a>760</td><td></td><td></td><td></td><td></td><td class="s">    $opt-&gt;{cache} = [ $opt-&gt;{cache} ];</td></tr>
<tr><td class="h"><a name="761"></a>761</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="762"></a>762</td><td></td><td></td><td></td><td></td><td class="s">  if($opt-&gt;{cache}) {</td></tr>
<tr><td class="h"><a name="763"></a>763</td><td></td><td></td><td></td><td></td><td class="s">    $_ = lc($_) foreach (@{$opt-&gt;{cache}});</td></tr>
<tr><td class="h"><a name="764"></a>764</td><td></td><td></td><td></td><td></td><td class="s">    foreach my $scheme (@{$opt-&gt;{cache}}) {</td></tr>
<tr><td class="h"><a name="765"></a>765</td><td></td><td></td><td></td><td></td><td class="s">      my $method = 'cache_read_' . $scheme;</td></tr>
<tr><td class="h"><a name="766"></a>766</td><td></td><td></td><td></td><td></td><td class="s">      croak &quot;Unsupported caching scheme: $scheme&quot;</td></tr>
<tr><td class="h"><a name="767"></a>767</td><td></td><td></td><td></td><td></td><td class="s">        unless($self-&gt;can($method));</td></tr>
<tr><td class="h"><a name="768"></a>768</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="769"></a>769</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="770"></a>770</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="771"></a>771</td><td class="c3">3</td><td class="c3"><span title="Avg 800ns">2&micro;s</span></td><td></td><td></td><td class="s">  if(exists($opt-&gt;{parseropts})) {</td></tr>
<tr><td class="h"><a name="772"></a>772</td><td></td><td></td><td></td><td></td><td class="s">    if($^W) {</td></tr>
<tr><td class="h"><a name="773"></a>773</td><td></td><td></td><td></td><td></td><td class="s">      carp &quot;Warning: &quot; .</td></tr>
<tr><td class="h"><a name="774"></a>774</td><td></td><td></td><td></td><td></td><td class="s">           &quot;'ParserOpts' is deprecated, contact the author if you need it&quot;;</td></tr>
<tr><td class="h"><a name="775"></a>775</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="776"></a>776</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="777"></a>777</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="778"></a>778</td><td></td><td></td><td></td><td></td><td class="s">    $opt-&gt;{parseropts} = [ ];</td></tr>
<tr><td class="h"><a name="779"></a>779</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="780"></a>780</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="781"></a>781</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="782"></a>782</td><td></td><td></td><td></td><td></td><td class="s">  # Special cleanup for {forcearray} which could be regex, arrayref or boolean</td></tr>
<tr><td class="h"><a name="783"></a>783</td><td></td><td></td><td></td><td></td><td class="s">  # or left to default to 0</td></tr>
<tr><td class="h"><a name="784"></a>784</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="785"></a>785</td><td class="c1">6</td><td class="c3"><span title="Avg 2&micro;s">9&micro;s</span></td><td></td><td></td><td class="s">  if(exists($opt-&gt;{forcearray})) {</td></tr>
<tr><td class="h"><a name="786"></a>786</td><td></td><td></td><td></td><td></td><td class="s">    if(ref($opt-&gt;{forcearray}) eq 'Regexp') {</td></tr>
<tr><td class="h"><a name="787"></a>787</td><td></td><td></td><td></td><td></td><td class="s">      $opt-&gt;{forcearray} = [ $opt-&gt;{forcearray} ];</td></tr>
<tr><td class="h"><a name="788"></a>788</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="789"></a>789</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="790"></a>790</td><td class="c1">6</td><td class="c3"><span title="Avg 1&micro;s">8&micro;s</span></td><td></td><td></td><td class="s">    if(ref($opt-&gt;{forcearray}) eq 'ARRAY') {</td></tr>
<tr><td class="h"><a name="791"></a>791</td><td></td><td></td><td></td><td></td><td class="s">      my @force_list = @{$opt-&gt;{forcearray}};</td></tr>
<tr><td class="h"><a name="792"></a>792</td><td class="c1">6</td><td class="c3"><span title="Avg 917ns">6&micro;s</span></td><td></td><td></td><td class="s">      if(@force_list) {</td></tr>
<tr><td class="h"><a name="793"></a>793</td><td></td><td></td><td></td><td></td><td class="s">        $opt-&gt;{forcearray} = {};</td></tr>
<tr><td class="h"><a name="794"></a>794</td><td></td><td></td><td></td><td></td><td class="s">        foreach my $tag (@force_list) {</td></tr>
<tr><td class="h"><a name="795"></a>795</td><td class="c1">6</td><td class="c3"><span title="Avg 2&micro;s">11&micro;s</span></td><td></td><td></td><td class="s">          if(ref($tag) eq 'Regexp') {</td></tr>
<tr><td class="h"><a name="796"></a>796</td><td></td><td></td><td></td><td></td><td class="s">            push @{$opt-&gt;{forcearray}-&gt;{_regex}}, $tag;</td></tr>
<tr><td class="h"><a name="797"></a>797</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="798"></a>798</td><td></td><td></td><td></td><td></td><td class="s">          else {</td></tr>
<tr><td class="h"><a name="799"></a>799</td><td></td><td></td><td></td><td></td><td class="s">            $opt-&gt;{forcearray}-&gt;{$tag} = 1;</td></tr>
<tr><td class="h"><a name="800"></a>800</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="801"></a>801</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="802"></a>802</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="803"></a>803</td><td></td><td></td><td></td><td></td><td class="s">      else {</td></tr>
<tr><td class="h"><a name="804"></a>804</td><td></td><td></td><td></td><td></td><td class="s">        $opt-&gt;{forcearray} = 0;</td></tr>
<tr><td class="h"><a name="805"></a>805</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="806"></a>806</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="807"></a>807</td><td></td><td></td><td></td><td></td><td class="s">    else {</td></tr>
<tr><td class="h"><a name="808"></a>808</td><td></td><td></td><td></td><td></td><td class="s">      $opt-&gt;{forcearray} = ( $opt-&gt;{forcearray} ? 1 : 0 );</td></tr>
<tr><td class="h"><a name="809"></a>809</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="810"></a>810</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="811"></a>811</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="812"></a>812</td><td></td><td></td><td></td><td></td><td class="s">    if($StrictMode  and  $dirn eq 'in') {</td></tr>
<tr><td class="h"><a name="813"></a>813</td><td></td><td></td><td></td><td></td><td class="s">      croak &quot;No value specified for 'ForceArray' option in call to XML$dirn()&quot;;</td></tr>
<tr><td class="h"><a name="814"></a>814</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="815"></a>815</td><td></td><td></td><td></td><td></td><td class="s">    $opt-&gt;{forcearray} = 0;</td></tr>
<tr><td class="h"><a name="816"></a>816</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="817"></a>817</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="818"></a>818</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="819"></a>819</td><td></td><td></td><td></td><td></td><td class="s">  # Special cleanup for {keyattr} which could be arrayref or hashref or left</td></tr>
<tr><td class="h"><a name="820"></a>820</td><td></td><td></td><td></td><td></td><td class="s">  # to default to arrayref</td></tr>
<tr><td class="h"><a name="821"></a>821</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="822"></a>822</td><td class="c1">6</td><td class="c3"><span title="Avg 2&micro;s">11&micro;s</span></td><td></td><td></td><td class="s">  if(exists($opt-&gt;{keyattr}))  {</td></tr>
<tr><td class="h"><a name="823"></a>823</td><td></td><td></td><td></td><td></td><td class="s">    if(ref($opt-&gt;{keyattr})) {</td></tr>
<tr><td class="h"><a name="824"></a>824</td><td></td><td></td><td></td><td></td><td class="s">      if(ref($opt-&gt;{keyattr}) eq 'HASH') {</td></tr>
<tr><td class="h"><a name="825"></a>825</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="826"></a>826</td><td></td><td></td><td></td><td></td><td class="s">        # Make a copy so we can mess with it</td></tr>
<tr><td class="h"><a name="827"></a>827</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="828"></a>828</td><td></td><td></td><td></td><td></td><td class="s">        $opt-&gt;{keyattr} = { %{$opt-&gt;{keyattr}} };</td></tr>
<tr><td class="h"><a name="829"></a>829</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="830"></a>830</td><td></td><td></td><td></td><td></td><td class="s">        </td></tr>
<tr><td class="h"><a name="831"></a>831</td><td></td><td></td><td></td><td></td><td class="s">        # Convert keyattr =&gt; { elem =&gt; '+attr' }</td></tr>
<tr><td class="h"><a name="832"></a>832</td><td></td><td></td><td></td><td></td><td class="s">        # to keyattr =&gt; { elem =&gt; [ 'attr', '+' ] } </td></tr>
<tr><td class="h"><a name="833"></a>833</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="834"></a>834</td><td></td><td></td><td></td><td></td><td class="s">        foreach my $el (keys(%{$opt-&gt;{keyattr}})) {</td></tr>
<tr><td class="h"><a name="835"></a>835</td><td></td><td></td><td></td><td></td><td class="s">          if($opt-&gt;{keyattr}-&gt;{$el} =~ /^(\+|-)?(.*)$/) {</td></tr>
<tr><td class="h"><a name="836"></a>836</td><td></td><td></td><td></td><td></td><td class="s">            $opt-&gt;{keyattr}-&gt;{$el} = [ $2, ($1 ? $1 : '') ];</td></tr>
<tr><td class="h"><a name="837"></a>837</td><td></td><td></td><td></td><td></td><td class="s">            if($StrictMode  and  $dirn eq 'in') {</td></tr>
<tr><td class="h"><a name="838"></a>838</td><td></td><td></td><td></td><td></td><td class="s">              next if($opt-&gt;{forcearray} == 1);</td></tr>
<tr><td class="h"><a name="839"></a>839</td><td></td><td></td><td></td><td></td><td class="s">              next if(ref($opt-&gt;{forcearray}) eq 'HASH'</td></tr>
<tr><td class="h"><a name="840"></a>840</td><td></td><td></td><td></td><td></td><td class="s">                      and $opt-&gt;{forcearray}-&gt;{$el});</td></tr>
<tr><td class="h"><a name="841"></a>841</td><td></td><td></td><td></td><td></td><td class="s">              croak &quot;&lt;$el&gt; set in KeyAttr but not in ForceArray&quot;;</td></tr>
<tr><td class="h"><a name="842"></a>842</td><td></td><td></td><td></td><td></td><td class="s">            }</td></tr>
<tr><td class="h"><a name="843"></a>843</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="844"></a>844</td><td></td><td></td><td></td><td></td><td class="s">          else {</td></tr>
<tr><td class="h"><a name="845"></a>845</td><td></td><td></td><td></td><td></td><td class="s">            delete($opt-&gt;{keyattr}-&gt;{$el}); # Never reached (famous last words?)</td></tr>
<tr><td class="h"><a name="846"></a>846</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="847"></a>847</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="848"></a>848</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="849"></a>849</td><td></td><td></td><td></td><td></td><td class="s">      else {</td></tr>
<tr><td class="h"><a name="850"></a>850</td><td></td><td></td><td></td><td></td><td class="s">        if(@{$opt-&gt;{keyattr}} == 0) {</td></tr>
<tr><td class="h"><a name="851"></a>851</td><td></td><td></td><td></td><td></td><td class="s">          delete($opt-&gt;{keyattr});</td></tr>
<tr><td class="h"><a name="852"></a>852</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="853"></a>853</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="854"></a>854</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="855"></a>855</td><td></td><td></td><td></td><td></td><td class="s">    else {</td></tr>
<tr><td class="h"><a name="856"></a>856</td><td></td><td></td><td></td><td></td><td class="s">      $opt-&gt;{keyattr} = [ $opt-&gt;{keyattr} ];</td></tr>
<tr><td class="h"><a name="857"></a>857</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="858"></a>858</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="859"></a>859</td><td></td><td></td><td></td><td></td><td class="s">  else  {</td></tr>
<tr><td class="h"><a name="860"></a>860</td><td></td><td></td><td></td><td></td><td class="s">    if($StrictMode) {</td></tr>
<tr><td class="h"><a name="861"></a>861</td><td></td><td></td><td></td><td></td><td class="s">      croak &quot;No value specified for 'KeyAttr' option in call to XML$dirn()&quot;;</td></tr>
<tr><td class="h"><a name="862"></a>862</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="863"></a>863</td><td></td><td></td><td></td><td></td><td class="s">    $opt-&gt;{keyattr} = [ @DefKeyAttr ];</td></tr>
<tr><td class="h"><a name="864"></a>864</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="865"></a>865</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="866"></a>866</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="867"></a>867</td><td></td><td></td><td></td><td></td><td class="s">  # Special cleanup for {valueattr} which could be arrayref or hashref</td></tr>
<tr><td class="h"><a name="868"></a>868</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="869"></a>869</td><td></td><td></td><td></td><td></td><td class="s">  if(exists($opt-&gt;{valueattr})) {</td></tr>
<tr><td class="h"><a name="870"></a>870</td><td></td><td></td><td></td><td></td><td class="s">    if(ref($opt-&gt;{valueattr}) eq 'ARRAY') {</td></tr>
<tr><td class="h"><a name="871"></a>871</td><td></td><td></td><td></td><td></td><td class="s">      $opt-&gt;{valueattrlist} = {};</td></tr>
<tr><td class="h"><a name="872"></a>872</td><td></td><td></td><td></td><td></td><td class="s">      $opt-&gt;{valueattrlist}-&gt;{$_} = 1 foreach(@{ delete $opt-&gt;{valueattr} });</td></tr>
<tr><td class="h"><a name="873"></a>873</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="874"></a>874</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="875"></a>875</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="876"></a>876</td><td></td><td></td><td></td><td></td><td class="s">  # make sure there's nothing weird in {grouptags}</td></tr>
<tr><td class="h"><a name="877"></a>877</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="878"></a>878</td><td></td><td></td><td></td><td></td><td class="s">  if($opt-&gt;{grouptags}) {</td></tr>
<tr><td class="h"><a name="879"></a>879</td><td></td><td></td><td></td><td></td><td class="s">    croak &quot;Illegal value for 'GroupTags' option - expected a hashref&quot;</td></tr>
<tr><td class="h"><a name="880"></a>880</td><td></td><td></td><td></td><td></td><td class="s">      unless UNIVERSAL::isa($opt-&gt;{grouptags}, 'HASH');</td></tr>
<tr><td class="h"><a name="881"></a>881</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="882"></a>882</td><td></td><td></td><td></td><td></td><td class="s">    while(my($key, $val) = each %{$opt-&gt;{grouptags}}) {</td></tr>
<tr><td class="h"><a name="883"></a>883</td><td></td><td></td><td></td><td></td><td class="s">      next if $key ne $val;</td></tr>
<tr><td class="h"><a name="884"></a>884</td><td></td><td></td><td></td><td></td><td class="s">      croak &quot;Bad value in GroupTags: '$key' =&gt; '$val'&quot;;</td></tr>
<tr><td class="h"><a name="885"></a>885</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="886"></a>886</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="887"></a>887</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="888"></a>888</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="889"></a>889</td><td></td><td></td><td></td><td></td><td class="s">  # Check the {variables} option is valid and initialise variables hash</td></tr>
<tr><td class="h"><a name="890"></a>890</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="891"></a>891</td><td></td><td></td><td></td><td></td><td class="s">  if($opt-&gt;{variables} and !UNIVERSAL::isa($opt-&gt;{variables}, 'HASH')) {</td></tr>
<tr><td class="h"><a name="892"></a>892</td><td></td><td></td><td></td><td></td><td class="s">    croak &quot;Illegal value for 'Variables' option - expected a hashref&quot;;</td></tr>
<tr><td class="h"><a name="893"></a>893</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="894"></a>894</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="895"></a>895</td><td></td><td></td><td></td><td></td><td class="s">  if($opt-&gt;{variables}) { </td></tr>
<tr><td class="h"><a name="896"></a>896</td><td></td><td></td><td></td><td></td><td class="s">    $self-&gt;{_var_values} = { %{$opt-&gt;{variables}} };</td></tr>
<tr><td class="h"><a name="897"></a>897</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="898"></a>898</td><td></td><td></td><td></td><td></td><td class="s">  elsif($opt-&gt;{varattr}) { </td></tr>
<tr><td class="h"><a name="899"></a>899</td><td></td><td></td><td></td><td></td><td class="s">    $self-&gt;{_var_values} = {};</td></tr>
<tr><td class="h"><a name="900"></a>900</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="901"></a>901</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="902"></a>902</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="903"></a>903</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="904"></a>904</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="905"></a>905</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="906"></a>906</td><td></td><td></td><td></td><td></td><td class="s"># Method: find_xml_file()</td></tr>
<tr><td class="h"><a name="907"></a>907</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="908"></a>908</td><td></td><td></td><td></td><td></td><td class="s"># Helper routine for XMLin().</td></tr>
<tr><td class="h"><a name="909"></a>909</td><td></td><td></td><td></td><td></td><td class="s"># Takes a filename, and a list of directories, attempts to locate the file in</td></tr>
<tr><td class="h"><a name="910"></a>910</td><td></td><td></td><td></td><td></td><td class="s"># the directories listed.</td></tr>
<tr><td class="h"><a name="911"></a>911</td><td></td><td></td><td></td><td></td><td class="s"># Returns a full pathname on success; croaks on failure.</td></tr>
<tr><td class="h"><a name="912"></a>912</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="913"></a>913</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="914"></a>914</td><td></td><td></td><td></td><td></td><td class="s">sub find_xml_file  {</td></tr>
<tr><td class="h"><a name="915"></a>915</td><td></td><td></td><td></td><td></td><td class="s">  my $self = shift;</td></tr>
<tr><td class="h"><a name="916"></a>916</td><td></td><td></td><td></td><td></td><td class="s">  my $file = shift;</td></tr>
<tr><td class="h"><a name="917"></a>917</td><td></td><td></td><td></td><td></td><td class="s">  my @search_path = @_;</td></tr>
<tr><td class="h"><a name="918"></a>918</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="919"></a>919</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="920"></a>920</td><td></td><td></td><td></td><td></td><td class="s">  require File::Basename;</td></tr>
<tr><td class="h"><a name="921"></a>921</td><td></td><td></td><td></td><td></td><td class="s">  require File::Spec;</td></tr>
<tr><td class="h"><a name="922"></a>922</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="923"></a>923</td><td></td><td></td><td></td><td></td><td class="s">  my($filename, $filedir) = File::Basename::fileparse($file);</td></tr>
<tr><td class="h"><a name="924"></a>924</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="925"></a>925</td><td></td><td></td><td></td><td></td><td class="s">  if($filename ne $file) {        # Ignore searchpath if dir component</td></tr>
<tr><td class="h"><a name="926"></a>926</td><td></td><td></td><td></td><td></td><td class="s">    return($file) if(-e $file);</td></tr>
<tr><td class="h"><a name="927"></a>927</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="928"></a>928</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="929"></a>929</td><td></td><td></td><td></td><td></td><td class="s">    my($path);</td></tr>
<tr><td class="h"><a name="930"></a>930</td><td></td><td></td><td></td><td></td><td class="s">    foreach $path (@search_path)  {</td></tr>
<tr><td class="h"><a name="931"></a>931</td><td></td><td></td><td></td><td></td><td class="s">      my $fullpath = File::Spec-&gt;catfile($path, $file);</td></tr>
<tr><td class="h"><a name="932"></a>932</td><td></td><td></td><td></td><td></td><td class="s">      return($fullpath) if(-e $fullpath);</td></tr>
<tr><td class="h"><a name="933"></a>933</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="934"></a>934</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="935"></a>935</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="936"></a>936</td><td></td><td></td><td></td><td></td><td class="s">  # If user did not supply a search path, default to current directory</td></tr>
<tr><td class="h"><a name="937"></a>937</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="938"></a>938</td><td></td><td></td><td></td><td></td><td class="s">  if(!@search_path) {</td></tr>
<tr><td class="h"><a name="939"></a>939</td><td></td><td></td><td></td><td></td><td class="s">    return($file) if(-e $file);</td></tr>
<tr><td class="h"><a name="940"></a>940</td><td></td><td></td><td></td><td></td><td class="s">    croak &quot;File does not exist: $file&quot;;</td></tr>
<tr><td class="h"><a name="941"></a>941</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="942"></a>942</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="943"></a>943</td><td></td><td></td><td></td><td></td><td class="s">  croak &quot;Could not find $file in &quot;, join(':', @search_path);</td></tr>
<tr><td class="h"><a name="944"></a>944</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="945"></a>945</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="946"></a>946</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="947"></a>947</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="948"></a>948</td><td></td><td></td><td></td><td></td><td class="s"># Method: collapse()</td></tr>
<tr><td class="h"><a name="949"></a>949</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="950"></a>950</td><td></td><td></td><td></td><td></td><td class="s"># Helper routine for XMLin().  This routine really comprises the 'smarts' (or</td></tr>
<tr><td class="h"><a name="951"></a>951</td><td></td><td></td><td></td><td></td><td class="s"># value add) of this module.</td></tr>
<tr><td class="h"><a name="952"></a>952</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="953"></a>953</td><td></td><td></td><td></td><td></td><td class="s"># Takes the parse tree that XML::Parser produced from the supplied XML and</td></tr>
<tr><td class="h"><a name="954"></a>954</td><td></td><td></td><td></td><td></td><td class="s"># recurses through it 'collapsing' unnecessary levels of indirection (nested</td></tr>
<tr><td class="h"><a name="955"></a>955</td><td></td><td></td><td></td><td></td><td class="s"># arrays etc) to produce a data structure that is easier to work with.</td></tr>
<tr><td class="h"><a name="956"></a>956</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="957"></a>957</td><td></td><td></td><td></td><td></td><td class="s"># Elements in the original parser tree are represented as an element name</td></tr>
<tr><td class="h"><a name="958"></a>958</td><td></td><td></td><td></td><td></td><td class="s"># followed by an arrayref.  The first element of the array is a hashref</td></tr>
<tr><td class="h"><a name="959"></a>959</td><td></td><td></td><td></td><td></td><td class="s"># containing the attributes.  The rest of the array contains a list of any</td></tr>
<tr><td class="h"><a name="960"></a>960</td><td></td><td></td><td></td><td></td><td class="s"># nested elements as name+arrayref pairs:</td></tr>
<tr><td class="h"><a name="961"></a>961</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="962"></a>962</td><td></td><td></td><td></td><td></td><td class="s">#  &lt;element name&gt;, [ { &lt;attribute hashref&gt; }, &lt;element name&gt;, [ ... ], ... ]</td></tr>
<tr><td class="h"><a name="963"></a>963</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="964"></a>964</td><td></td><td></td><td></td><td></td><td class="s"># The special element name '0' (zero) flags text content.</td></tr>
<tr><td class="h"><a name="965"></a>965</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="966"></a>966</td><td></td><td></td><td></td><td></td><td class="s"># This routine cuts down the noise by discarding any text content consisting of</td></tr>
<tr><td class="h"><a name="967"></a>967</td><td></td><td></td><td></td><td></td><td class="s"># only whitespace and then moves the nested elements into the attribute hash</td></tr>
<tr><td class="h"><a name="968"></a>968</td><td></td><td></td><td></td><td></td><td class="s"># using the name of the nested element as the hash key and the collapsed</td></tr>
<tr><td class="h"><a name="969"></a>969</td><td></td><td></td><td></td><td></td><td class="s"># version of the nested element as the value.  Multiple nested elements with</td></tr>
<tr><td class="h"><a name="970"></a>970</td><td></td><td></td><td></td><td></td><td class="s"># the same name will initially be represented as an arrayref, but this may be</td></tr>
<tr><td class="h"><a name="971"></a>971</td><td></td><td></td><td></td><td></td><td class="s"># 'folded' into a hashref depending on the value of the keyattr option.</td></tr>
<tr><td class="h"><a name="972"></a>972</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="973"></a>973</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="974"></a>974</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 7.18ms (796&micro;s+6.38) within XML::Simple::collapse which was called 35 times, avg 205&micro;s/call:
# 32 times (652&micro;s+-652&micro;s) by XML::Simple::collapse at <a href="XML-Simple-pm-block.html#1019">line 1019</a>, avg 0s/call
#  3 times (144&micro;s+7.03ms) by XML::Simple::build_simple_tree at <a href="XML-Simple-pm-block.html#312">line 312</a>, avg 2.39ms/call</div></div>sub collapse {</td></tr>
<tr><td class="h"><a name="975"></a>975</td><td class="c0">294</td><td class="c0"><span title="Avg 557ns">164&micro;s</span></td><td></td><td></td><td class="s">  my $self = shift;</td></tr>
<tr><td class="h"><a name="976"></a>976</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="977"></a>977</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="978"></a>978</td><td></td><td></td><td></td><td></td><td class="s">  # Start with the hash of attributes</td></tr>
<tr><td class="h"><a name="979"></a>979</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="980"></a>980</td><td></td><td></td><td></td><td></td><td class="s">  my $attr  = shift;</td></tr>
<tr><td class="h"><a name="981"></a>981</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{noattr}) {                    # Discard if 'noattr' set</td></tr>
<tr><td class="h"><a name="982"></a>982</td><td></td><td></td><td></td><td></td><td class="s">    $attr = {};</td></tr>
<tr><td class="h"><a name="983"></a>983</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="984"></a>984</td><td></td><td></td><td></td><td></td><td class="s">  elsif($self-&gt;{opt}-&gt;{normalisespace} == 2) {</td></tr>
<tr><td class="h"><a name="985"></a>985</td><td></td><td></td><td></td><td></td><td class="s">    while(my($key, $value) = each %$attr) {</td></tr>
<tr><td class="h"><a name="986"></a>986</td><td></td><td></td><td></td><td></td><td class="s">      $attr-&gt;{$key} = $self-&gt;normalise_space($value)</td></tr>
<tr><td class="h"><a name="987"></a>987</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="988"></a>988</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="989"></a>989</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="990"></a>990</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="991"></a>991</td><td></td><td></td><td></td><td></td><td class="s">  # Do variable substitutions</td></tr>
<tr><td class="h"><a name="992"></a>992</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="993"></a>993</td><td></td><td></td><td></td><td></td><td class="s">  if(my $var = $self-&gt;{_var_values}) {</td></tr>
<tr><td class="h"><a name="994"></a>994</td><td></td><td></td><td></td><td></td><td class="s">    while(my($key, $val) = each(%$attr)) {</td></tr>
<tr><td class="h"><a name="995"></a>995</td><td></td><td></td><td></td><td></td><td class="s">      $val =~ s{\$\{([\w.]+)\}}{ $self-&gt;get_var($1) }ge;</td></tr>
<tr><td class="h"><a name="996"></a>996</td><td></td><td></td><td></td><td></td><td class="s">      $attr-&gt;{$key} = $val;</td></tr>
<tr><td class="h"><a name="997"></a>997</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="998"></a>998</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="999"></a>999</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1000"></a>1000</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1001"></a>1001</td><td></td><td></td><td></td><td></td><td class="s">  # Roll up 'value' attributes (but only if no nested elements)</td></tr>
<tr><td class="h"><a name="1002"></a>1002</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1003"></a>1003</td><td></td><td></td><td></td><td></td><td class="s">  if(!@_  and  keys %$attr == 1) {</td></tr>
<tr><td class="h"><a name="1004"></a>1004</td><td></td><td></td><td></td><td></td><td class="s">    my($k) = keys %$attr;</td></tr>
<tr><td class="h"><a name="1005"></a>1005</td><td></td><td></td><td></td><td></td><td class="s">    if($self-&gt;{opt}-&gt;{valueattrlist}  and $self-&gt;{opt}-&gt;{valueattrlist}-&gt;{$k}) {</td></tr>
<tr><td class="h"><a name="1006"></a>1006</td><td></td><td></td><td></td><td></td><td class="s">      return $attr-&gt;{$k};</td></tr>
<tr><td class="h"><a name="1007"></a>1007</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1008"></a>1008</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1009"></a>1009</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1010"></a>1010</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1011"></a>1011</td><td></td><td></td><td></td><td></td><td class="s">  # Add any nested elements</td></tr>
<tr><td class="h"><a name="1012"></a>1012</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1013"></a>1013</td><td></td><td></td><td></td><td></td><td class="s">  my($key, $val);</td></tr>
<tr><td class="h"><a name="1014"></a>1014</td><td></td><td></td><td></td><td></td><td class="s">  while(@_) {</td></tr>
<tr><td class="h"><a name="1015"></a>1015</td><td class="c0">212</td><td class="c0"><span title="Avg 966ns">205&micro;s</span></td><td></td><td></td><td class="s">    $key = shift;</td></tr>
<tr><td class="h"><a name="1016"></a>1016</td><td></td><td></td><td></td><td></td><td class="s">    $val = shift;</td></tr>
<tr><td class="h"><a name="1017"></a>1017</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1018"></a>1018</td><td class="c0">204</td><td class="c0"><span title="Avg 2&micro;s">313&micro;s</span></td><td></td><td></td><td class="s">    if(ref($val)) {</td></tr>
<tr><td class="h"><a name="1019"></a>1019</td><td></td><td></td><td></td><td></td><td class="s">      $val = $self-&gt;collapse(@$val);<div class="calls"><div class="calls_out">      # spent  13.6ms making 32 calls to <a href="XML-Simple-pm-block.html#974">XML::Simple::collapse</a>, avg 425&micro;s/call, recursion: max depth 2, time 13.6ms</div></div></td></tr>
<tr><td class="h"><a name="1020"></a>1020</td><td></td><td></td><td></td><td></td><td class="s">      next if(!defined($val)  and  $self-&gt;{opt}-&gt;{suppressempty});</td></tr>
<tr><td class="h"><a name="1021"></a>1021</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1022"></a>1022</td><td></td><td></td><td></td><td></td><td class="s">    elsif($key eq '0') {</td></tr>
<tr><td class="h"><a name="1023"></a>1023</td><td class="c3">3</td><td class="c3"><span title="Avg 5&micro;s">16&micro;s</span></td><td class="c0">29</td><td class="c0">7.74ms</td><td class="s">      next if($val =~ m{^\s*$}s);  # Skip all whitespace content<div class="calls"><div class="calls_out">      # spent  6.30ms making 28 calls to <a href="XML-Simple-pm-block.html#XML__Simple__CORE_match">XML::Simple::CORE:match</a>, avg 225&micro;s/call
      # spent  1.44ms making  1 call to <a href="utf8-pm-block.html#16">utf8::AUTOLOAD</a></div></div></td></tr>
<tr><td class="h"><a name="1024"></a>1024</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1025"></a>1025</td><td></td><td></td><td></td><td></td><td class="s">      $val = $self-&gt;normalise_space($val)</td></tr>
<tr><td class="h"><a name="1026"></a>1026</td><td></td><td></td><td></td><td></td><td class="s">        if($self-&gt;{opt}-&gt;{normalisespace} == 2);</td></tr>
<tr><td class="h"><a name="1027"></a>1027</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1028"></a>1028</td><td></td><td></td><td></td><td></td><td class="s">      # do variable substitutions</td></tr>
<tr><td class="h"><a name="1029"></a>1029</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1030"></a>1030</td><td></td><td></td><td></td><td></td><td class="s">      if(my $var = $self-&gt;{_var_values}) { </td></tr>
<tr><td class="h"><a name="1031"></a>1031</td><td></td><td></td><td></td><td></td><td class="s">        $val =~ s{\$\{(\w+)\}}{ $self-&gt;get_var($1) }ge;</td></tr>
<tr><td class="h"><a name="1032"></a>1032</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1033"></a>1033</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1034"></a>1034</td><td></td><td></td><td></td><td></td><td class="s">      </td></tr>
<tr><td class="h"><a name="1035"></a>1035</td><td></td><td></td><td></td><td></td><td class="s">      # look for variable definitions</td></tr>
<tr><td class="h"><a name="1036"></a>1036</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1037"></a>1037</td><td></td><td></td><td></td><td></td><td class="s">      if(my $var = $self-&gt;{opt}-&gt;{varattr}) { </td></tr>
<tr><td class="h"><a name="1038"></a>1038</td><td></td><td></td><td></td><td></td><td class="s">        if(exists $attr-&gt;{$var}) {</td></tr>
<tr><td class="h"><a name="1039"></a>1039</td><td></td><td></td><td></td><td></td><td class="s">          $self-&gt;set_var($attr-&gt;{$var}, $val);</td></tr>
<tr><td class="h"><a name="1040"></a>1040</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1041"></a>1041</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1042"></a>1042</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1043"></a>1043</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1044"></a>1044</td><td></td><td></td><td></td><td></td><td class="s">      # Collapse text content in element with no attributes to a string</td></tr>
<tr><td class="h"><a name="1045"></a>1045</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1046"></a>1046</td><td></td><td></td><td></td><td></td><td class="s">      if(!%$attr  and  !@_) {</td></tr>
<tr><td class="h"><a name="1047"></a>1047</td><td></td><td></td><td></td><td></td><td class="s">        return($self-&gt;{opt}-&gt;{forcecontent} ? </td></tr>
<tr><td class="h"><a name="1048"></a>1048</td><td></td><td></td><td></td><td></td><td class="s">          { $self-&gt;{opt}-&gt;{contentkey} =&gt; $val } : $val</td></tr>
<tr><td class="h"><a name="1049"></a>1049</td><td></td><td></td><td></td><td></td><td class="s">        );</td></tr>
<tr><td class="h"><a name="1050"></a>1050</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1051"></a>1051</td><td></td><td></td><td></td><td></td><td class="s">      $key = $self-&gt;{opt}-&gt;{contentkey};</td></tr>
<tr><td class="h"><a name="1052"></a>1052</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1053"></a>1053</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1054"></a>1054</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1055"></a>1055</td><td></td><td></td><td></td><td></td><td class="s">    # Combine duplicate attributes into arrayref if required</td></tr>
<tr><td class="h"><a name="1056"></a>1056</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1057"></a>1057</td><td class="c0">12</td><td class="c0"><span title="Avg 4&micro;s">45&micro;s</span></td><td class="c0">32</td><td class="c3">31&micro;s</td><td class="s">    if(exists($attr-&gt;{$key})) {<div class="calls"><div class="calls_out">    # spent    31&micro;s making 32 calls to <a >UNIVERSAL::isa</a>, avg 962ns/call</div></div></td></tr>
<tr><td class="h"><a name="1058"></a>1058</td><td></td><td></td><td></td><td></td><td class="s">      if(UNIVERSAL::isa($attr-&gt;{$key}, 'ARRAY')) {</td></tr>
<tr><td class="h"><a name="1059"></a>1059</td><td></td><td></td><td></td><td></td><td class="s">        push(@{$attr-&gt;{$key}}, $val);</td></tr>
<tr><td class="h"><a name="1060"></a>1060</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1061"></a>1061</td><td></td><td></td><td></td><td></td><td class="s">      else {</td></tr>
<tr><td class="h"><a name="1062"></a>1062</td><td></td><td></td><td></td><td></td><td class="s">        $attr-&gt;{$key} = [ $attr-&gt;{$key}, $val ];</td></tr>
<tr><td class="h"><a name="1063"></a>1063</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1064"></a>1064</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1065"></a>1065</td><td></td><td></td><td></td><td></td><td class="s">    elsif(defined($val)  and  UNIVERSAL::isa($val, 'ARRAY')) {</td></tr>
<tr><td class="h"><a name="1066"></a>1066</td><td></td><td></td><td></td><td></td><td class="s">      $attr-&gt;{$key} = [ $val ];</td></tr>
<tr><td class="h"><a name="1067"></a>1067</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1068"></a>1068</td><td></td><td></td><td></td><td></td><td class="s">    else {</td></tr>
<tr><td class="h"><a name="1069"></a>1069</td><td class="c0">11</td><td class="c3"><span title="Avg 1&micro;s">16&micro;s</span></td><td></td><td></td><td class="s">      if( $key ne $self-&gt;{opt}-&gt;{contentkey} </td></tr>
<tr><td class="h"><a name="1070"></a>1070</td><td></td><td></td><td></td><td></td><td class="s">          and (</td></tr>
<tr><td class="h"><a name="1071"></a>1071</td><td></td><td></td><td></td><td></td><td class="s">            ($self-&gt;{opt}-&gt;{forcearray} == 1)</td></tr>
<tr><td class="h"><a name="1072"></a>1072</td><td></td><td></td><td></td><td></td><td class="s">            or ( </td></tr>
<tr><td class="h"><a name="1073"></a>1073</td><td></td><td></td><td></td><td></td><td class="s">              (ref($self-&gt;{opt}-&gt;{forcearray}) eq 'HASH')</td></tr>
<tr><td class="h"><a name="1074"></a>1074</td><td></td><td></td><td></td><td></td><td class="s">              and (</td></tr>
<tr><td class="h"><a name="1075"></a>1075</td><td></td><td></td><td></td><td></td><td class="s">                $self-&gt;{opt}-&gt;{forcearray}-&gt;{$key}</td></tr>
<tr><td class="h"><a name="1076"></a>1076</td><td></td><td></td><td></td><td></td><td class="s">                or (grep $key =~ $_, @{$self-&gt;{opt}-&gt;{forcearray}-&gt;{_regex}})</td></tr>
<tr><td class="h"><a name="1077"></a>1077</td><td></td><td></td><td></td><td></td><td class="s">              )</td></tr>
<tr><td class="h"><a name="1078"></a>1078</td><td></td><td></td><td></td><td></td><td class="s">            )</td></tr>
<tr><td class="h"><a name="1079"></a>1079</td><td></td><td></td><td></td><td></td><td class="s">          )</td></tr>
<tr><td class="h"><a name="1080"></a>1080</td><td></td><td></td><td></td><td></td><td class="s">        ) {</td></tr>
<tr><td class="h"><a name="1081"></a>1081</td><td></td><td></td><td></td><td></td><td class="s">        $attr-&gt;{$key} = [ $val ];</td></tr>
<tr><td class="h"><a name="1082"></a>1082</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1083"></a>1083</td><td></td><td></td><td></td><td></td><td class="s">      else {</td></tr>
<tr><td class="h"><a name="1084"></a>1084</td><td></td><td></td><td></td><td></td><td class="s">        $attr-&gt;{$key} = $val;</td></tr>
<tr><td class="h"><a name="1085"></a>1085</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1086"></a>1086</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1087"></a>1087</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1088"></a>1088</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1089"></a>1089</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1090"></a>1090</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1091"></a>1091</td><td></td><td></td><td></td><td></td><td class="s">  # Turn arrayrefs into hashrefs if key fields present</td></tr>
<tr><td class="h"><a name="1092"></a>1092</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1093"></a>1093</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{keyattr}) {</td></tr>
<tr><td class="h"><a name="1094"></a>1094</td><td></td><td></td><td></td><td></td><td class="s">    while(($key,$val) = each %$attr) {</td></tr>
<tr><td class="h"><a name="1095"></a>1095</td><td class="c0">14</td><td class="c0"><span title="Avg 5&micro;s">74&micro;s</span></td><td class="c0">15</td><td class="c3">45&micro;s</td><td class="s">      if(defined($val)  and  UNIVERSAL::isa($val, 'ARRAY')) {<div class="calls"><div class="calls_out">      # spent    31&micro;s making  1 call to <a href="XML-Simple-pm-block.html#1215">XML::Simple::array_to_hash</a>
      # spent    14&micro;s making 14 calls to <a >UNIVERSAL::isa</a>, avg 1&micro;s/call</div></div></td></tr>
<tr><td class="h"><a name="1096"></a>1096</td><td></td><td></td><td></td><td></td><td class="s">        $attr-&gt;{$key} = $self-&gt;array_to_hash($key, $val);</td></tr>
<tr><td class="h"><a name="1097"></a>1097</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1098"></a>1098</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1099"></a>1099</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1100"></a>1100</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1101"></a>1101</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1102"></a>1102</td><td></td><td></td><td></td><td></td><td class="s">  # disintermediate grouped tags</td></tr>
<tr><td class="h"><a name="1103"></a>1103</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1104"></a>1104</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{grouptags}) {</td></tr>
<tr><td class="h"><a name="1105"></a>1105</td><td></td><td></td><td></td><td></td><td class="s">    while(my($key, $val) = each(%$attr)) {</td></tr>
<tr><td class="h"><a name="1106"></a>1106</td><td></td><td></td><td></td><td></td><td class="s">      next unless(UNIVERSAL::isa($val, 'HASH') and (keys %$val == 1));</td></tr>
<tr><td class="h"><a name="1107"></a>1107</td><td></td><td></td><td></td><td></td><td class="s">      next unless(exists($self-&gt;{opt}-&gt;{grouptags}-&gt;{$key}));</td></tr>
<tr><td class="h"><a name="1108"></a>1108</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1109"></a>1109</td><td></td><td></td><td></td><td></td><td class="s">      my($child_key, $child_val) =  %$val;</td></tr>
<tr><td class="h"><a name="1110"></a>1110</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1111"></a>1111</td><td></td><td></td><td></td><td></td><td class="s">      if($self-&gt;{opt}-&gt;{grouptags}-&gt;{$key} eq $child_key) {</td></tr>
<tr><td class="h"><a name="1112"></a>1112</td><td></td><td></td><td></td><td></td><td class="s">        $attr-&gt;{$key}= $child_val;</td></tr>
<tr><td class="h"><a name="1113"></a>1113</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1114"></a>1114</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1115"></a>1115</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1116"></a>1116</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1117"></a>1117</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1118"></a>1118</td><td></td><td></td><td></td><td></td><td class="s">  # Fold hashes containing a single anonymous array up into just the array</td></tr>
<tr><td class="h"><a name="1119"></a>1119</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1120"></a>1120</td><td></td><td></td><td></td><td></td><td class="s">  my $count = scalar keys %$attr;</td></tr>
<tr><td class="h"><a name="1121"></a>1121</td><td></td><td></td><td></td><td></td><td class="s">  if($count == 1 </td></tr>
<tr><td class="h"><a name="1122"></a>1122</td><td></td><td></td><td></td><td></td><td class="s">     and  exists $attr-&gt;{anon}  </td></tr>
<tr><td class="h"><a name="1123"></a>1123</td><td></td><td></td><td></td><td></td><td class="s">     and  UNIVERSAL::isa($attr-&gt;{anon}, 'ARRAY')</td></tr>
<tr><td class="h"><a name="1124"></a>1124</td><td></td><td></td><td></td><td></td><td class="s">  ) {</td></tr>
<tr><td class="h"><a name="1125"></a>1125</td><td></td><td></td><td></td><td></td><td class="s">    return($attr-&gt;{anon});</td></tr>
<tr><td class="h"><a name="1126"></a>1126</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1127"></a>1127</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1128"></a>1128</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1129"></a>1129</td><td></td><td></td><td></td><td></td><td class="s">  # Do the right thing if hash is empty, otherwise just return it</td></tr>
<tr><td class="h"><a name="1130"></a>1130</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1131"></a>1131</td><td></td><td></td><td></td><td></td><td class="s">  if(!%$attr  and  exists($self-&gt;{opt}-&gt;{suppressempty})) {</td></tr>
<tr><td class="h"><a name="1132"></a>1132</td><td></td><td></td><td></td><td></td><td class="s">    if(defined($self-&gt;{opt}-&gt;{suppressempty})  and</td></tr>
<tr><td class="h"><a name="1133"></a>1133</td><td></td><td></td><td></td><td></td><td class="s">       $self-&gt;{opt}-&gt;{suppressempty} eq '') {</td></tr>
<tr><td class="h"><a name="1134"></a>1134</td><td></td><td></td><td></td><td></td><td class="s">      return('');</td></tr>
<tr><td class="h"><a name="1135"></a>1135</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1136"></a>1136</td><td></td><td></td><td></td><td></td><td class="s">    return(undef);</td></tr>
<tr><td class="h"><a name="1137"></a>1137</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1138"></a>1138</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1139"></a>1139</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1140"></a>1140</td><td></td><td></td><td></td><td></td><td class="s">  # Roll up named elements with named nested 'value' attributes</td></tr>
<tr><td class="h"><a name="1141"></a>1141</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1142"></a>1142</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{valueattr}) {</td></tr>
<tr><td class="h"><a name="1143"></a>1143</td><td></td><td></td><td></td><td></td><td class="s">    while(my($key, $val) = each(%$attr)) {</td></tr>
<tr><td class="h"><a name="1144"></a>1144</td><td></td><td></td><td></td><td></td><td class="s">      next unless($self-&gt;{opt}-&gt;{valueattr}-&gt;{$key});</td></tr>
<tr><td class="h"><a name="1145"></a>1145</td><td></td><td></td><td></td><td></td><td class="s">      next unless(UNIVERSAL::isa($val, 'HASH') and (keys %$val == 1));</td></tr>
<tr><td class="h"><a name="1146"></a>1146</td><td></td><td></td><td></td><td></td><td class="s">      my($k) = keys %$val;</td></tr>
<tr><td class="h"><a name="1147"></a>1147</td><td></td><td></td><td></td><td></td><td class="s">      next unless($k eq $self-&gt;{opt}-&gt;{valueattr}-&gt;{$key});</td></tr>
<tr><td class="h"><a name="1148"></a>1148</td><td></td><td></td><td></td><td></td><td class="s">      $attr-&gt;{$key} = $val-&gt;{$k};</td></tr>
<tr><td class="h"><a name="1149"></a>1149</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1150"></a>1150</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1151"></a>1151</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1152"></a>1152</td><td></td><td></td><td></td><td></td><td class="s">  return($attr)</td></tr>
<tr><td class="h"><a name="1153"></a>1153</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1154"></a>1154</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1155"></a>1155</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1156"></a>1156</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1157"></a>1157</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1158"></a>1158</td><td></td><td></td><td></td><td></td><td class="s"># Method: set_var()</td></tr>
<tr><td class="h"><a name="1159"></a>1159</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1160"></a>1160</td><td></td><td></td><td></td><td></td><td class="s"># Called when a variable definition is encountered in the XML.  (A variable</td></tr>
<tr><td class="h"><a name="1161"></a>1161</td><td></td><td></td><td></td><td></td><td class="s"># definition looks like &lt;element attrname=&quot;name&quot;&gt;value&lt;/element&gt; where attrname</td></tr>
<tr><td class="h"><a name="1162"></a>1162</td><td></td><td></td><td></td><td></td><td class="s"># matches the varattr setting).</td></tr>
<tr><td class="h"><a name="1163"></a>1163</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1164"></a>1164</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1165"></a>1165</td><td></td><td></td><td></td><td></td><td class="s">sub set_var {</td></tr>
<tr><td class="h"><a name="1166"></a>1166</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $name, $value) = @_;</td></tr>
<tr><td class="h"><a name="1167"></a>1167</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1168"></a>1168</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;{_var_values}-&gt;{$name} = $value;</td></tr>
<tr><td class="h"><a name="1169"></a>1169</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1170"></a>1170</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1171"></a>1171</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1172"></a>1172</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1173"></a>1173</td><td></td><td></td><td></td><td></td><td class="s"># Method: get_var()</td></tr>
<tr><td class="h"><a name="1174"></a>1174</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1175"></a>1175</td><td></td><td></td><td></td><td></td><td class="s"># Called during variable substitution to get the value for the named variable.</td></tr>
<tr><td class="h"><a name="1176"></a>1176</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1177"></a>1177</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1178"></a>1178</td><td></td><td></td><td></td><td></td><td class="s">sub get_var {</td></tr>
<tr><td class="h"><a name="1179"></a>1179</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $name) = @_;</td></tr>
<tr><td class="h"><a name="1180"></a>1180</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1181"></a>1181</td><td></td><td></td><td></td><td></td><td class="s">  my $value = $self-&gt;{_var_values}-&gt;{$name};</td></tr>
<tr><td class="h"><a name="1182"></a>1182</td><td></td><td></td><td></td><td></td><td class="s">  return $value if(defined($value));</td></tr>
<tr><td class="h"><a name="1183"></a>1183</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1184"></a>1184</td><td></td><td></td><td></td><td></td><td class="s">  return '${' . $name . '}';</td></tr>
<tr><td class="h"><a name="1185"></a>1185</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1186"></a>1186</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1187"></a>1187</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1188"></a>1188</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1189"></a>1189</td><td></td><td></td><td></td><td></td><td class="s"># Method: normalise_space()</td></tr>
<tr><td class="h"><a name="1190"></a>1190</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1191"></a>1191</td><td></td><td></td><td></td><td></td><td class="s"># Strips leading and trailing whitespace and collapses sequences of whitespace</td></tr>
<tr><td class="h"><a name="1192"></a>1192</td><td></td><td></td><td></td><td></td><td class="s"># characters to a single space.</td></tr>
<tr><td class="h"><a name="1193"></a>1193</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1194"></a>1194</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1195"></a>1195</td><td></td><td></td><td></td><td></td><td class="s">sub normalise_space {</td></tr>
<tr><td class="h"><a name="1196"></a>1196</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $text) = @_;</td></tr>
<tr><td class="h"><a name="1197"></a>1197</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1198"></a>1198</td><td></td><td></td><td></td><td></td><td class="s">  $text =~ s/^\s+//s;</td></tr>
<tr><td class="h"><a name="1199"></a>1199</td><td></td><td></td><td></td><td></td><td class="s">  $text =~ s/\s+$//s;</td></tr>
<tr><td class="h"><a name="1200"></a>1200</td><td></td><td></td><td></td><td></td><td class="s">  $text =~ s/\s\s+/ /sg;</td></tr>
<tr><td class="h"><a name="1201"></a>1201</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1202"></a>1202</td><td></td><td></td><td></td><td></td><td class="s">  return $text;</td></tr>
<tr><td class="h"><a name="1203"></a>1203</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1204"></a>1204</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1205"></a>1205</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1206"></a>1206</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1207"></a>1207</td><td></td><td></td><td></td><td></td><td class="s"># Method: array_to_hash()</td></tr>
<tr><td class="h"><a name="1208"></a>1208</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1209"></a>1209</td><td></td><td></td><td></td><td></td><td class="s"># Helper routine for collapse().</td></tr>
<tr><td class="h"><a name="1210"></a>1210</td><td></td><td></td><td></td><td></td><td class="s"># Attempts to 'fold' an array of hashes into an hash of hashes.  Returns a</td></tr>
<tr><td class="h"><a name="1211"></a>1211</td><td></td><td></td><td></td><td></td><td class="s"># reference to the hash on success or the original array if folding is</td></tr>
<tr><td class="h"><a name="1212"></a>1212</td><td></td><td></td><td></td><td></td><td class="s"># not possible.  Behaviour is controlled by 'keyattr' option.</td></tr>
<tr><td class="h"><a name="1213"></a>1213</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1214"></a>1214</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1215"></a>1215</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 31&micro;s (26+4) within XML::Simple::array_to_hash which was called
#    once (26&micro;s+4&micro;s) by XML::Simple::collapse at <a href="XML-Simple-pm-block.html#1095">line 1095</a></div></div>sub array_to_hash {</td></tr>
<tr><td class="h"><a name="1216"></a>1216</td><td class="c1">6</td><td class="c3"><span title="Avg 983ns">6&micro;s</span></td><td></td><td></td><td class="s">  my $self     = shift;</td></tr>
<tr><td class="h"><a name="1217"></a>1217</td><td></td><td></td><td></td><td></td><td class="s">  my $name     = shift;</td></tr>
<tr><td class="h"><a name="1218"></a>1218</td><td></td><td></td><td></td><td></td><td class="s">  my $arrayref = shift;</td></tr>
<tr><td class="h"><a name="1219"></a>1219</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1220"></a>1220</td><td></td><td></td><td></td><td></td><td class="s">  my $hashref  = $self-&gt;new_hashref;<div class="calls"><div class="calls_out">  # spent     3&micro;s making 1 call to <a href="XML-Simple-pm-block.html#1322">XML::Simple::new_hashref</a></div></div></td></tr>
<tr><td class="h"><a name="1221"></a>1221</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1222"></a>1222</td><td></td><td></td><td></td><td></td><td class="s">  my($i, $key, $val, $flag);</td></tr>
<tr><td class="h"><a name="1223"></a>1223</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1224"></a>1224</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1225"></a>1225</td><td></td><td></td><td></td><td></td><td class="s">  # Handle keyattr =&gt; { .... }</td></tr>
<tr><td class="h"><a name="1226"></a>1226</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1227"></a>1227</td><td class="c3">3</td><td class="c3"><span title="Avg 2&micro;s">7&micro;s</span></td><td></td><td></td><td class="s">  if(ref($self-&gt;{opt}-&gt;{keyattr}) eq 'HASH') {</td></tr>
<tr><td class="h"><a name="1228"></a>1228</td><td></td><td></td><td></td><td></td><td class="s">    return($arrayref) unless(exists($self-&gt;{opt}-&gt;{keyattr}-&gt;{$name}));</td></tr>
<tr><td class="h"><a name="1229"></a>1229</td><td></td><td></td><td></td><td></td><td class="s">    ($key, $flag) = @{$self-&gt;{opt}-&gt;{keyattr}-&gt;{$name}};</td></tr>
<tr><td class="h"><a name="1230"></a>1230</td><td></td><td></td><td></td><td></td><td class="s">    for($i = 0; $i &lt; @$arrayref; $i++)  {</td></tr>
<tr><td class="h"><a name="1231"></a>1231</td><td></td><td></td><td></td><td></td><td class="s">      if(UNIVERSAL::isa($arrayref-&gt;[$i], 'HASH') and</td></tr>
<tr><td class="h"><a name="1232"></a>1232</td><td></td><td></td><td></td><td></td><td class="s">         exists($arrayref-&gt;[$i]-&gt;{$key})</td></tr>
<tr><td class="h"><a name="1233"></a>1233</td><td></td><td></td><td></td><td></td><td class="s">      ) {</td></tr>
<tr><td class="h"><a name="1234"></a>1234</td><td></td><td></td><td></td><td></td><td class="s">        $val = $arrayref-&gt;[$i]-&gt;{$key};</td></tr>
<tr><td class="h"><a name="1235"></a>1235</td><td></td><td></td><td></td><td></td><td class="s">        if(ref($val)) {</td></tr>
<tr><td class="h"><a name="1236"></a>1236</td><td></td><td></td><td></td><td></td><td class="s">          $self-&gt;die_or_warn(&quot;&lt;$name&gt; element has non-scalar '$key' key attribute&quot;);</td></tr>
<tr><td class="h"><a name="1237"></a>1237</td><td></td><td></td><td></td><td></td><td class="s">          return($arrayref);</td></tr>
<tr><td class="h"><a name="1238"></a>1238</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1239"></a>1239</td><td></td><td></td><td></td><td></td><td class="s">        $val = $self-&gt;normalise_space($val)</td></tr>
<tr><td class="h"><a name="1240"></a>1240</td><td></td><td></td><td></td><td></td><td class="s">          if($self-&gt;{opt}-&gt;{normalisespace} == 1);</td></tr>
<tr><td class="h"><a name="1241"></a>1241</td><td></td><td></td><td></td><td></td><td class="s">        $self-&gt;die_or_warn(&quot;&lt;$name&gt; element has non-unique value in '$key' key attribute: $val&quot;)</td></tr>
<tr><td class="h"><a name="1242"></a>1242</td><td></td><td></td><td></td><td></td><td class="s">          if(exists($hashref-&gt;{$val}));</td></tr>
<tr><td class="h"><a name="1243"></a>1243</td><td></td><td></td><td></td><td></td><td class="s">        $hashref-&gt;{$val} = { %{$arrayref-&gt;[$i]} };</td></tr>
<tr><td class="h"><a name="1244"></a>1244</td><td></td><td></td><td></td><td></td><td class="s">        $hashref-&gt;{$val}-&gt;{&quot;-$key&quot;} = $hashref-&gt;{$val}-&gt;{$key} if($flag eq '-');</td></tr>
<tr><td class="h"><a name="1245"></a>1245</td><td></td><td></td><td></td><td></td><td class="s">        delete $hashref-&gt;{$val}-&gt;{$key} unless($flag eq '+');</td></tr>
<tr><td class="h"><a name="1246"></a>1246</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1247"></a>1247</td><td></td><td></td><td></td><td></td><td class="s">      else {</td></tr>
<tr><td class="h"><a name="1248"></a>1248</td><td></td><td></td><td></td><td></td><td class="s">        $self-&gt;die_or_warn(&quot;&lt;$name&gt; element has no '$key' key attribute&quot;);</td></tr>
<tr><td class="h"><a name="1249"></a>1249</td><td></td><td></td><td></td><td></td><td class="s">        return($arrayref);</td></tr>
<tr><td class="h"><a name="1250"></a>1250</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1251"></a>1251</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1252"></a>1252</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1253"></a>1253</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1254"></a>1254</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1255"></a>1255</td><td></td><td></td><td></td><td></td><td class="s">  # Or assume keyattr =&gt; [ .... ]</td></tr>
<tr><td class="h"><a name="1256"></a>1256</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1257"></a>1257</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="1258"></a>1258</td><td></td><td></td><td></td><td></td><td class="s">    my $default_keys =</td></tr>
<tr><td class="h"><a name="1259"></a>1259</td><td></td><td></td><td></td><td></td><td class="s">      join(',', @DefKeyAttr) eq join(',', @{$self-&gt;{opt}-&gt;{keyattr}});</td></tr>
<tr><td class="h"><a name="1260"></a>1260</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1261"></a>1261</td><td class="c3">1</td><td class="c3"><span title="Avg 11&micro;s">11&micro;s</span></td><td></td><td></td><td class="s">    ELEMENT: for($i = 0; $i &lt; @$arrayref; $i++)  {</td></tr>
<tr><td class="h"><a name="1262"></a>1262</td><td></td><td></td><td></td><td></td><td class="s">      return($arrayref) unless(UNIVERSAL::isa($arrayref-&gt;[$i], 'HASH'));<div class="calls"><div class="calls_out">      # spent     1&micro;s making 1 call to <a >UNIVERSAL::isa</a></div></div></td></tr>
<tr><td class="h"><a name="1263"></a>1263</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1264"></a>1264</td><td></td><td></td><td></td><td></td><td class="s">      foreach $key (@{$self-&gt;{opt}-&gt;{keyattr}}) {</td></tr>
<tr><td class="h"><a name="1265"></a>1265</td><td></td><td></td><td></td><td></td><td class="s">        if(defined($arrayref-&gt;[$i]-&gt;{$key}))  {</td></tr>
<tr><td class="h"><a name="1266"></a>1266</td><td></td><td></td><td></td><td></td><td class="s">          $val = $arrayref-&gt;[$i]-&gt;{$key};</td></tr>
<tr><td class="h"><a name="1267"></a>1267</td><td></td><td></td><td></td><td></td><td class="s">          if(ref($val)) {</td></tr>
<tr><td class="h"><a name="1268"></a>1268</td><td></td><td></td><td></td><td></td><td class="s">            $self-&gt;die_or_warn(&quot;&lt;$name&gt; element has non-scalar '$key' key attribute&quot;)</td></tr>
<tr><td class="h"><a name="1269"></a>1269</td><td></td><td></td><td></td><td></td><td class="s">              if not $default_keys;</td></tr>
<tr><td class="h"><a name="1270"></a>1270</td><td></td><td></td><td></td><td></td><td class="s">            return($arrayref);</td></tr>
<tr><td class="h"><a name="1271"></a>1271</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="1272"></a>1272</td><td></td><td></td><td></td><td></td><td class="s">          $val = $self-&gt;normalise_space($val)</td></tr>
<tr><td class="h"><a name="1273"></a>1273</td><td></td><td></td><td></td><td></td><td class="s">            if($self-&gt;{opt}-&gt;{normalisespace} == 1);</td></tr>
<tr><td class="h"><a name="1274"></a>1274</td><td></td><td></td><td></td><td></td><td class="s">          $self-&gt;die_or_warn(&quot;&lt;$name&gt; element has non-unique value in '$key' key attribute: $val&quot;)</td></tr>
<tr><td class="h"><a name="1275"></a>1275</td><td></td><td></td><td></td><td></td><td class="s">            if(exists($hashref-&gt;{$val}));</td></tr>
<tr><td class="h"><a name="1276"></a>1276</td><td></td><td></td><td></td><td></td><td class="s">          $hashref-&gt;{$val} = { %{$arrayref-&gt;[$i]} };</td></tr>
<tr><td class="h"><a name="1277"></a>1277</td><td></td><td></td><td></td><td></td><td class="s">          delete $hashref-&gt;{$val}-&gt;{$key};</td></tr>
<tr><td class="h"><a name="1278"></a>1278</td><td></td><td></td><td></td><td></td><td class="s">          next ELEMENT;</td></tr>
<tr><td class="h"><a name="1279"></a>1279</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1280"></a>1280</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1281"></a>1281</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1282"></a>1282</td><td></td><td></td><td></td><td></td><td class="s">      return($arrayref);    # No keyfield matched</td></tr>
<tr><td class="h"><a name="1283"></a>1283</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1284"></a>1284</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1285"></a>1285</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="1286"></a>1286</td><td></td><td></td><td></td><td></td><td class="s">  # collapse any hashes which now only have a 'content' key</td></tr>
<tr><td class="h"><a name="1287"></a>1287</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1288"></a>1288</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{collapseagain}) {</td></tr>
<tr><td class="h"><a name="1289"></a>1289</td><td></td><td></td><td></td><td></td><td class="s">    $hashref = $self-&gt;collapse_content($hashref);</td></tr>
<tr><td class="h"><a name="1290"></a>1290</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1291"></a>1291</td><td></td><td></td><td></td><td></td><td class="s"> </td></tr>
<tr><td class="h"><a name="1292"></a>1292</td><td></td><td></td><td></td><td></td><td class="s">  return($hashref);</td></tr>
<tr><td class="h"><a name="1293"></a>1293</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1294"></a>1294</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1295"></a>1295</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1296"></a>1296</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1297"></a>1297</td><td></td><td></td><td></td><td></td><td class="s"># Method: die_or_warn()</td></tr>
<tr><td class="h"><a name="1298"></a>1298</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1299"></a>1299</td><td></td><td></td><td></td><td></td><td class="s"># Takes a diagnostic message and does one of three things:</td></tr>
<tr><td class="h"><a name="1300"></a>1300</td><td></td><td></td><td></td><td></td><td class="s"># 1. dies if strict mode is enabled</td></tr>
<tr><td class="h"><a name="1301"></a>1301</td><td></td><td></td><td></td><td></td><td class="s"># 2. warns if warnings are enabled but strict mode is not</td></tr>
<tr><td class="h"><a name="1302"></a>1302</td><td></td><td></td><td></td><td></td><td class="s"># 3. ignores message and resturns silently if neither strict mode nor warnings</td></tr>
<tr><td class="h"><a name="1303"></a>1303</td><td></td><td></td><td></td><td></td><td class="s">#    are enabled</td></tr>
<tr><td class="h"><a name="1304"></a>1304</td><td></td><td></td><td></td><td></td><td class="s"># </td></tr>
<tr><td class="h"><a name="1305"></a>1305</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1306"></a>1306</td><td></td><td></td><td></td><td></td><td class="s">sub die_or_warn {</td></tr>
<tr><td class="h"><a name="1307"></a>1307</td><td></td><td></td><td></td><td></td><td class="s">  my $self = shift;</td></tr>
<tr><td class="h"><a name="1308"></a>1308</td><td></td><td></td><td></td><td></td><td class="s">  my $msg  = shift;</td></tr>
<tr><td class="h"><a name="1309"></a>1309</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1310"></a>1310</td><td></td><td></td><td></td><td></td><td class="s">  croak $msg if($StrictMode);</td></tr>
<tr><td class="h"><a name="1311"></a>1311</td><td></td><td></td><td></td><td></td><td class="s">  carp &quot;Warning: $msg&quot; if($^W);</td></tr>
<tr><td class="h"><a name="1312"></a>1312</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1313"></a>1313</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1314"></a>1314</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1315"></a>1315</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1316"></a>1316</td><td></td><td></td><td></td><td></td><td class="s"># Method: new_hashref()</td></tr>
<tr><td class="h"><a name="1317"></a>1317</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1318"></a>1318</td><td></td><td></td><td></td><td></td><td class="s"># This is a hook routine for overriding in a sub-class.  Some people believe</td></tr>
<tr><td class="h"><a name="1319"></a>1319</td><td></td><td></td><td></td><td></td><td class="s"># that using Tie::IxHash here will solve order-loss problems.</td></tr>
<tr><td class="h"><a name="1320"></a>1320</td><td></td><td></td><td></td><td></td><td class="s"># </td></tr>
<tr><td class="h"><a name="1321"></a>1321</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1322"></a>1322</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 3&micro;s within XML::Simple::new_hashref which was called
#    once (3&micro;s+0s) by XML::Simple::array_to_hash at <a href="XML-Simple-pm-block.html#1220">line 1220</a></div></div>sub new_hashref {</td></tr>
<tr><td class="h"><a name="1323"></a>1323</td><td class="c3">2</td><td class="c3"><span title="Avg 4&micro;s">7&micro;s</span></td><td></td><td></td><td class="s">  my $self = shift;</td></tr>
<tr><td class="h"><a name="1324"></a>1324</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1325"></a>1325</td><td></td><td></td><td></td><td></td><td class="s">  return { @_ };</td></tr>
<tr><td class="h"><a name="1326"></a>1326</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1327"></a>1327</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1328"></a>1328</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1329"></a>1329</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1330"></a>1330</td><td></td><td></td><td></td><td></td><td class="s"># Method: collapse_content()</td></tr>
<tr><td class="h"><a name="1331"></a>1331</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1332"></a>1332</td><td></td><td></td><td></td><td></td><td class="s"># Helper routine for array_to_hash</td></tr>
<tr><td class="h"><a name="1333"></a>1333</td><td></td><td></td><td></td><td></td><td class="s"># </td></tr>
<tr><td class="h"><a name="1334"></a>1334</td><td></td><td></td><td></td><td></td><td class="s"># Arguments expected are:</td></tr>
<tr><td class="h"><a name="1335"></a>1335</td><td></td><td></td><td></td><td></td><td class="s"># - an XML::Simple object</td></tr>
<tr><td class="h"><a name="1336"></a>1336</td><td></td><td></td><td></td><td></td><td class="s"># - a hasref</td></tr>
<tr><td class="h"><a name="1337"></a>1337</td><td></td><td></td><td></td><td></td><td class="s"># the hashref is a former array, turned into a hash by array_to_hash because</td></tr>
<tr><td class="h"><a name="1338"></a>1338</td><td></td><td></td><td></td><td></td><td class="s"># of the presence of key attributes</td></tr>
<tr><td class="h"><a name="1339"></a>1339</td><td></td><td></td><td></td><td></td><td class="s"># at this point collapse_content avoids over-complicated structures like</td></tr>
<tr><td class="h"><a name="1340"></a>1340</td><td></td><td></td><td></td><td></td><td class="s"># dir =&gt; { libexecdir    =&gt; { content =&gt; '$exec_prefix/libexec' },</td></tr>
<tr><td class="h"><a name="1341"></a>1341</td><td></td><td></td><td></td><td></td><td class="s">#          localstatedir =&gt; { content =&gt; '$prefix' },</td></tr>
<tr><td class="h"><a name="1342"></a>1342</td><td></td><td></td><td></td><td></td><td class="s">#        }</td></tr>
<tr><td class="h"><a name="1343"></a>1343</td><td></td><td></td><td></td><td></td><td class="s"># into</td></tr>
<tr><td class="h"><a name="1344"></a>1344</td><td></td><td></td><td></td><td></td><td class="s"># dir =&gt; { libexecdir    =&gt; '$exec_prefix/libexec',</td></tr>
<tr><td class="h"><a name="1345"></a>1345</td><td></td><td></td><td></td><td></td><td class="s">#          localstatedir =&gt; '$prefix',</td></tr>
<tr><td class="h"><a name="1346"></a>1346</td><td></td><td></td><td></td><td></td><td class="s">#        }</td></tr>
<tr><td class="h"><a name="1347"></a>1347</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1348"></a>1348</td><td></td><td></td><td></td><td></td><td class="s">sub collapse_content {</td></tr>
<tr><td class="h"><a name="1349"></a>1349</td><td></td><td></td><td></td><td></td><td class="s">  my $self       = shift;</td></tr>
<tr><td class="h"><a name="1350"></a>1350</td><td></td><td></td><td></td><td></td><td class="s">  my $hashref    = shift; </td></tr>
<tr><td class="h"><a name="1351"></a>1351</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1352"></a>1352</td><td></td><td></td><td></td><td></td><td class="s">  my $contentkey = $self-&gt;{opt}-&gt;{contentkey};</td></tr>
<tr><td class="h"><a name="1353"></a>1353</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1354"></a>1354</td><td></td><td></td><td></td><td></td><td class="s">  # first go through the values,checking that they are fit to collapse</td></tr>
<tr><td class="h"><a name="1355"></a>1355</td><td></td><td></td><td></td><td></td><td class="s">  foreach my $val (values %$hashref) {</td></tr>
<tr><td class="h"><a name="1356"></a>1356</td><td></td><td></td><td></td><td></td><td class="s">    return $hashref unless (     (ref($val) eq 'HASH')</td></tr>
<tr><td class="h"><a name="1357"></a>1357</td><td></td><td></td><td></td><td></td><td class="s">                             and (keys %$val == 1)</td></tr>
<tr><td class="h"><a name="1358"></a>1358</td><td></td><td></td><td></td><td></td><td class="s">                             and (exists $val-&gt;{$contentkey})</td></tr>
<tr><td class="h"><a name="1359"></a>1359</td><td></td><td></td><td></td><td></td><td class="s">                           );</td></tr>
<tr><td class="h"><a name="1360"></a>1360</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1361"></a>1361</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1362"></a>1362</td><td></td><td></td><td></td><td></td><td class="s">  # now collapse them</td></tr>
<tr><td class="h"><a name="1363"></a>1363</td><td></td><td></td><td></td><td></td><td class="s">  foreach my $key (keys %$hashref) {</td></tr>
<tr><td class="h"><a name="1364"></a>1364</td><td></td><td></td><td></td><td></td><td class="s">    $hashref-&gt;{$key}=  $hashref-&gt;{$key}-&gt;{$contentkey};</td></tr>
<tr><td class="h"><a name="1365"></a>1365</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1366"></a>1366</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1367"></a>1367</td><td></td><td></td><td></td><td></td><td class="s">  return $hashref;</td></tr>
<tr><td class="h"><a name="1368"></a>1368</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1369"></a>1369</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="1370"></a>1370</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1371"></a>1371</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1372"></a>1372</td><td></td><td></td><td></td><td></td><td class="s"># Method: value_to_xml()</td></tr>
<tr><td class="h"><a name="1373"></a>1373</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1374"></a>1374</td><td></td><td></td><td></td><td></td><td class="s"># Helper routine for XMLout() - recurses through a data structure building up</td></tr>
<tr><td class="h"><a name="1375"></a>1375</td><td></td><td></td><td></td><td></td><td class="s"># and returning an XML representation of that structure as a string.</td></tr>
<tr><td class="h"><a name="1376"></a>1376</td><td></td><td></td><td></td><td></td><td class="s"># </td></tr>
<tr><td class="h"><a name="1377"></a>1377</td><td></td><td></td><td></td><td></td><td class="s"># Arguments expected are:</td></tr>
<tr><td class="h"><a name="1378"></a>1378</td><td></td><td></td><td></td><td></td><td class="s"># - the data structure to be encoded (usually a reference)</td></tr>
<tr><td class="h"><a name="1379"></a>1379</td><td></td><td></td><td></td><td></td><td class="s"># - the XML tag name to use for this item</td></tr>
<tr><td class="h"><a name="1380"></a>1380</td><td></td><td></td><td></td><td></td><td class="s"># - a string of spaces for use as the current indent level</td></tr>
<tr><td class="h"><a name="1381"></a>1381</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1382"></a>1382</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1383"></a>1383</td><td></td><td></td><td></td><td></td><td class="s">sub value_to_xml {</td></tr>
<tr><td class="h"><a name="1384"></a>1384</td><td></td><td></td><td></td><td></td><td class="s">  my $self = shift;;</td></tr>
<tr><td class="h"><a name="1385"></a>1385</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1386"></a>1386</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1387"></a>1387</td><td></td><td></td><td></td><td></td><td class="s">  # Grab the other arguments</td></tr>
<tr><td class="h"><a name="1388"></a>1388</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1389"></a>1389</td><td></td><td></td><td></td><td></td><td class="s">  my($ref, $name, $indent) = @_;</td></tr>
<tr><td class="h"><a name="1390"></a>1390</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1391"></a>1391</td><td></td><td></td><td></td><td></td><td class="s">  my $named = (defined($name) and $name ne '' ? 1 : 0);</td></tr>
<tr><td class="h"><a name="1392"></a>1392</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1393"></a>1393</td><td></td><td></td><td></td><td></td><td class="s">  my $nl = &quot;\n&quot;;</td></tr>
<tr><td class="h"><a name="1394"></a>1394</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1395"></a>1395</td><td></td><td></td><td></td><td></td><td class="s">  my $is_root = $indent eq '' ? 1 : 0;   # Warning, dirty hack!</td></tr>
<tr><td class="h"><a name="1396"></a>1396</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{noindent}) {</td></tr>
<tr><td class="h"><a name="1397"></a>1397</td><td></td><td></td><td></td><td></td><td class="s">    $indent = '';</td></tr>
<tr><td class="h"><a name="1398"></a>1398</td><td></td><td></td><td></td><td></td><td class="s">    $nl     = '';</td></tr>
<tr><td class="h"><a name="1399"></a>1399</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1400"></a>1400</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1401"></a>1401</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1402"></a>1402</td><td></td><td></td><td></td><td></td><td class="s">  # Convert to XML</td></tr>
<tr><td class="h"><a name="1403"></a>1403</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="1404"></a>1404</td><td></td><td></td><td></td><td></td><td class="s">  if(ref($ref)) {</td></tr>
<tr><td class="h"><a name="1405"></a>1405</td><td></td><td></td><td></td><td></td><td class="s">    croak &quot;circular data structures not supported&quot;</td></tr>
<tr><td class="h"><a name="1406"></a>1406</td><td></td><td></td><td></td><td></td><td class="s">      if(grep($_ == $ref, @{$self-&gt;{_ancestors}}));</td></tr>
<tr><td class="h"><a name="1407"></a>1407</td><td></td><td></td><td></td><td></td><td class="s">    push @{$self-&gt;{_ancestors}}, $ref;</td></tr>
<tr><td class="h"><a name="1408"></a>1408</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1409"></a>1409</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="1410"></a>1410</td><td></td><td></td><td></td><td></td><td class="s">    if($named) {</td></tr>
<tr><td class="h"><a name="1411"></a>1411</td><td></td><td></td><td></td><td></td><td class="s">      return(join('',</td></tr>
<tr><td class="h"><a name="1412"></a>1412</td><td></td><td></td><td></td><td></td><td class="s">              $indent, '&lt;', $name, '&gt;',</td></tr>
<tr><td class="h"><a name="1413"></a>1413</td><td></td><td></td><td></td><td></td><td class="s">              ($self-&gt;{opt}-&gt;{noescape} ? $ref : $self-&gt;escape_value($ref)),</td></tr>
<tr><td class="h"><a name="1414"></a>1414</td><td></td><td></td><td></td><td></td><td class="s">              '&lt;/', $name, &quot;&gt;&quot;, $nl</td></tr>
<tr><td class="h"><a name="1415"></a>1415</td><td></td><td></td><td></td><td></td><td class="s">            ));</td></tr>
<tr><td class="h"><a name="1416"></a>1416</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1417"></a>1417</td><td></td><td></td><td></td><td></td><td class="s">    else {</td></tr>
<tr><td class="h"><a name="1418"></a>1418</td><td></td><td></td><td></td><td></td><td class="s">      return(&quot;$ref$nl&quot;);</td></tr>
<tr><td class="h"><a name="1419"></a>1419</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1420"></a>1420</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1421"></a>1421</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1422"></a>1422</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1423"></a>1423</td><td></td><td></td><td></td><td></td><td class="s">  # Unfold hash to array if possible</td></tr>
<tr><td class="h"><a name="1424"></a>1424</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1425"></a>1425</td><td></td><td></td><td></td><td></td><td class="s">  if(UNIVERSAL::isa($ref, 'HASH')      # It is a hash</td></tr>
<tr><td class="h"><a name="1426"></a>1426</td><td></td><td></td><td></td><td></td><td class="s">     and keys %$ref                    # and it's not empty</td></tr>
<tr><td class="h"><a name="1427"></a>1427</td><td></td><td></td><td></td><td></td><td class="s">     and $self-&gt;{opt}-&gt;{keyattr}       # and folding is enabled</td></tr>
<tr><td class="h"><a name="1428"></a>1428</td><td></td><td></td><td></td><td></td><td class="s">     and !$is_root                     # and its not the root element</td></tr>
<tr><td class="h"><a name="1429"></a>1429</td><td></td><td></td><td></td><td></td><td class="s">  ) {</td></tr>
<tr><td class="h"><a name="1430"></a>1430</td><td></td><td></td><td></td><td></td><td class="s">    $ref = $self-&gt;hash_to_array($name, $ref);</td></tr>
<tr><td class="h"><a name="1431"></a>1431</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1432"></a>1432</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1433"></a>1433</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1434"></a>1434</td><td></td><td></td><td></td><td></td><td class="s">  my @result = ();</td></tr>
<tr><td class="h"><a name="1435"></a>1435</td><td></td><td></td><td></td><td></td><td class="s">  my($key, $value);</td></tr>
<tr><td class="h"><a name="1436"></a>1436</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1437"></a>1437</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1438"></a>1438</td><td></td><td></td><td></td><td></td><td class="s">  # Handle hashrefs</td></tr>
<tr><td class="h"><a name="1439"></a>1439</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1440"></a>1440</td><td></td><td></td><td></td><td></td><td class="s">  if(UNIVERSAL::isa($ref, 'HASH')) {</td></tr>
<tr><td class="h"><a name="1441"></a>1441</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1442"></a>1442</td><td></td><td></td><td></td><td></td><td class="s">    # Reintermediate grouped values if applicable</td></tr>
<tr><td class="h"><a name="1443"></a>1443</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1444"></a>1444</td><td></td><td></td><td></td><td></td><td class="s">    if($self-&gt;{opt}-&gt;{grouptags}) {</td></tr>
<tr><td class="h"><a name="1445"></a>1445</td><td></td><td></td><td></td><td></td><td class="s">      $ref = $self-&gt;copy_hash($ref);</td></tr>
<tr><td class="h"><a name="1446"></a>1446</td><td></td><td></td><td></td><td></td><td class="s">      while(my($key, $val) = each %$ref) {</td></tr>
<tr><td class="h"><a name="1447"></a>1447</td><td></td><td></td><td></td><td></td><td class="s">        if($self-&gt;{opt}-&gt;{grouptags}-&gt;{$key}) {</td></tr>
<tr><td class="h"><a name="1448"></a>1448</td><td></td><td></td><td></td><td></td><td class="s">          $ref-&gt;{$key} = { $self-&gt;{opt}-&gt;{grouptags}-&gt;{$key} =&gt; $val };</td></tr>
<tr><td class="h"><a name="1449"></a>1449</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1450"></a>1450</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1451"></a>1451</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1452"></a>1452</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1453"></a>1453</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1454"></a>1454</td><td></td><td></td><td></td><td></td><td class="s">    # Scan for namespace declaration attributes</td></tr>
<tr><td class="h"><a name="1455"></a>1455</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1456"></a>1456</td><td></td><td></td><td></td><td></td><td class="s">    my $nsdecls = '';</td></tr>
<tr><td class="h"><a name="1457"></a>1457</td><td></td><td></td><td></td><td></td><td class="s">    my $default_ns_uri;</td></tr>
<tr><td class="h"><a name="1458"></a>1458</td><td></td><td></td><td></td><td></td><td class="s">    if($self-&gt;{nsup}) {</td></tr>
<tr><td class="h"><a name="1459"></a>1459</td><td></td><td></td><td></td><td></td><td class="s">      $ref = $self-&gt;copy_hash($ref);</td></tr>
<tr><td class="h"><a name="1460"></a>1460</td><td></td><td></td><td></td><td></td><td class="s">      $self-&gt;{nsup}-&gt;push_context();</td></tr>
<tr><td class="h"><a name="1461"></a>1461</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1462"></a>1462</td><td></td><td></td><td></td><td></td><td class="s">      # Look for default namespace declaration first</td></tr>
<tr><td class="h"><a name="1463"></a>1463</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1464"></a>1464</td><td></td><td></td><td></td><td></td><td class="s">      if(exists($ref-&gt;{xmlns})) {</td></tr>
<tr><td class="h"><a name="1465"></a>1465</td><td></td><td></td><td></td><td></td><td class="s">        $self-&gt;{nsup}-&gt;declare_prefix('', $ref-&gt;{xmlns});</td></tr>
<tr><td class="h"><a name="1466"></a>1466</td><td></td><td></td><td></td><td></td><td class="s">        $nsdecls .= qq( xmlns=&quot;$ref-&gt;{xmlns}&quot;); </td></tr>
<tr><td class="h"><a name="1467"></a>1467</td><td></td><td></td><td></td><td></td><td class="s">        delete($ref-&gt;{xmlns});</td></tr>
<tr><td class="h"><a name="1468"></a>1468</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1469"></a>1469</td><td></td><td></td><td></td><td></td><td class="s">      $default_ns_uri = $self-&gt;{nsup}-&gt;get_uri('');</td></tr>
<tr><td class="h"><a name="1470"></a>1470</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1471"></a>1471</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1472"></a>1472</td><td></td><td></td><td></td><td></td><td class="s">      # Then check all the other keys</td></tr>
<tr><td class="h"><a name="1473"></a>1473</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1474"></a>1474</td><td></td><td></td><td></td><td></td><td class="s">      foreach my $qname (keys(%$ref)) {</td></tr>
<tr><td class="h"><a name="1475"></a>1475</td><td></td><td></td><td></td><td></td><td class="s">        my($uri, $lname) = $self-&gt;{nsup}-&gt;parse_jclark_notation($qname);</td></tr>
<tr><td class="h"><a name="1476"></a>1476</td><td></td><td></td><td></td><td></td><td class="s">        if($uri) {</td></tr>
<tr><td class="h"><a name="1477"></a>1477</td><td></td><td></td><td></td><td></td><td class="s">          if($uri eq $xmlns_ns) {</td></tr>
<tr><td class="h"><a name="1478"></a>1478</td><td></td><td></td><td></td><td></td><td class="s">            $self-&gt;{nsup}-&gt;declare_prefix($lname, $ref-&gt;{$qname});</td></tr>
<tr><td class="h"><a name="1479"></a>1479</td><td></td><td></td><td></td><td></td><td class="s">            $nsdecls .= qq( xmlns:$lname=&quot;$ref-&gt;{$qname}&quot;); </td></tr>
<tr><td class="h"><a name="1480"></a>1480</td><td></td><td></td><td></td><td></td><td class="s">            delete($ref-&gt;{$qname});</td></tr>
<tr><td class="h"><a name="1481"></a>1481</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="1482"></a>1482</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1483"></a>1483</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1484"></a>1484</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1485"></a>1485</td><td></td><td></td><td></td><td></td><td class="s">      # Translate any remaining Clarkian names</td></tr>
<tr><td class="h"><a name="1486"></a>1486</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1487"></a>1487</td><td></td><td></td><td></td><td></td><td class="s">      foreach my $qname (keys(%$ref)) {</td></tr>
<tr><td class="h"><a name="1488"></a>1488</td><td></td><td></td><td></td><td></td><td class="s">        my($uri, $lname) = $self-&gt;{nsup}-&gt;parse_jclark_notation($qname);</td></tr>
<tr><td class="h"><a name="1489"></a>1489</td><td></td><td></td><td></td><td></td><td class="s">        if($uri) {</td></tr>
<tr><td class="h"><a name="1490"></a>1490</td><td></td><td></td><td></td><td></td><td class="s">          if($default_ns_uri  and  $uri eq $default_ns_uri) {</td></tr>
<tr><td class="h"><a name="1491"></a>1491</td><td></td><td></td><td></td><td></td><td class="s">            $ref-&gt;{$lname} = $ref-&gt;{$qname};</td></tr>
<tr><td class="h"><a name="1492"></a>1492</td><td></td><td></td><td></td><td></td><td class="s">            delete($ref-&gt;{$qname});</td></tr>
<tr><td class="h"><a name="1493"></a>1493</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="1494"></a>1494</td><td></td><td></td><td></td><td></td><td class="s">          else {</td></tr>
<tr><td class="h"><a name="1495"></a>1495</td><td></td><td></td><td></td><td></td><td class="s">            my $prefix = $self-&gt;{nsup}-&gt;get_prefix($uri);</td></tr>
<tr><td class="h"><a name="1496"></a>1496</td><td></td><td></td><td></td><td></td><td class="s">            unless($prefix) {</td></tr>
<tr><td class="h"><a name="1497"></a>1497</td><td></td><td></td><td></td><td></td><td class="s">              # $self-&gt;{nsup}-&gt;declare_prefix(undef, $uri);</td></tr>
<tr><td class="h"><a name="1498"></a>1498</td><td></td><td></td><td></td><td></td><td class="s">              # $prefix = $self-&gt;{nsup}-&gt;get_prefix($uri);</td></tr>
<tr><td class="h"><a name="1499"></a>1499</td><td></td><td></td><td></td><td></td><td class="s">              $prefix = $self-&gt;{ns_prefix}++;</td></tr>
<tr><td class="h"><a name="1500"></a>1500</td><td></td><td></td><td></td><td></td><td class="s">              $self-&gt;{nsup}-&gt;declare_prefix($prefix, $uri);</td></tr>
<tr><td class="h"><a name="1501"></a>1501</td><td></td><td></td><td></td><td></td><td class="s">              $nsdecls .= qq( xmlns:$prefix=&quot;$uri&quot;); </td></tr>
<tr><td class="h"><a name="1502"></a>1502</td><td></td><td></td><td></td><td></td><td class="s">            }</td></tr>
<tr><td class="h"><a name="1503"></a>1503</td><td></td><td></td><td></td><td></td><td class="s">            $ref-&gt;{&quot;$prefix:$lname&quot;} = $ref-&gt;{$qname};</td></tr>
<tr><td class="h"><a name="1504"></a>1504</td><td></td><td></td><td></td><td></td><td class="s">            delete($ref-&gt;{$qname});</td></tr>
<tr><td class="h"><a name="1505"></a>1505</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="1506"></a>1506</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1507"></a>1507</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1508"></a>1508</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1509"></a>1509</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1510"></a>1510</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1511"></a>1511</td><td></td><td></td><td></td><td></td><td class="s">    my @nested = ();</td></tr>
<tr><td class="h"><a name="1512"></a>1512</td><td></td><td></td><td></td><td></td><td class="s">    my $text_content = undef;</td></tr>
<tr><td class="h"><a name="1513"></a>1513</td><td></td><td></td><td></td><td></td><td class="s">    if($named) {</td></tr>
<tr><td class="h"><a name="1514"></a>1514</td><td></td><td></td><td></td><td></td><td class="s">      push @result, $indent, '&lt;', $name, $nsdecls;</td></tr>
<tr><td class="h"><a name="1515"></a>1515</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1516"></a>1516</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1517"></a>1517</td><td></td><td></td><td></td><td></td><td class="s">    if(keys %$ref) {</td></tr>
<tr><td class="h"><a name="1518"></a>1518</td><td></td><td></td><td></td><td></td><td class="s">      my $first_arg = 1;</td></tr>
<tr><td class="h"><a name="1519"></a>1519</td><td></td><td></td><td></td><td></td><td class="s">      foreach my $key ($self-&gt;sorted_keys($name, $ref)) {</td></tr>
<tr><td class="h"><a name="1520"></a>1520</td><td></td><td></td><td></td><td></td><td class="s">        my $value = $ref-&gt;{$key};</td></tr>
<tr><td class="h"><a name="1521"></a>1521</td><td></td><td></td><td></td><td></td><td class="s">        next if(substr($key, 0, 1) eq '-');</td></tr>
<tr><td class="h"><a name="1522"></a>1522</td><td></td><td></td><td></td><td></td><td class="s">        if(!defined($value)) {</td></tr>
<tr><td class="h"><a name="1523"></a>1523</td><td></td><td></td><td></td><td></td><td class="s">          next if $self-&gt;{opt}-&gt;{suppressempty};</td></tr>
<tr><td class="h"><a name="1524"></a>1524</td><td></td><td></td><td></td><td></td><td class="s">          unless(exists($self-&gt;{opt}-&gt;{suppressempty})</td></tr>
<tr><td class="h"><a name="1525"></a>1525</td><td></td><td></td><td></td><td></td><td class="s">             and !defined($self-&gt;{opt}-&gt;{suppressempty})</td></tr>
<tr><td class="h"><a name="1526"></a>1526</td><td></td><td></td><td></td><td></td><td class="s">          ) {</td></tr>
<tr><td class="h"><a name="1527"></a>1527</td><td></td><td></td><td></td><td></td><td class="s">            carp 'Use of uninitialized value' if($^W);</td></tr>
<tr><td class="h"><a name="1528"></a>1528</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="1529"></a>1529</td><td></td><td></td><td></td><td></td><td class="s">          if($key eq $self-&gt;{opt}-&gt;{contentkey}) {</td></tr>
<tr><td class="h"><a name="1530"></a>1530</td><td></td><td></td><td></td><td></td><td class="s">            $text_content = '';</td></tr>
<tr><td class="h"><a name="1531"></a>1531</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="1532"></a>1532</td><td></td><td></td><td></td><td></td><td class="s">          else {</td></tr>
<tr><td class="h"><a name="1533"></a>1533</td><td></td><td></td><td></td><td></td><td class="s">            $value = exists($self-&gt;{opt}-&gt;{suppressempty}) ? {} : '';</td></tr>
<tr><td class="h"><a name="1534"></a>1534</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="1535"></a>1535</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1536"></a>1536</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1537"></a>1537</td><td></td><td></td><td></td><td></td><td class="s">        if(!ref($value)  </td></tr>
<tr><td class="h"><a name="1538"></a>1538</td><td></td><td></td><td></td><td></td><td class="s">           and $self-&gt;{opt}-&gt;{valueattr}</td></tr>
<tr><td class="h"><a name="1539"></a>1539</td><td></td><td></td><td></td><td></td><td class="s">           and $self-&gt;{opt}-&gt;{valueattr}-&gt;{$key}</td></tr>
<tr><td class="h"><a name="1540"></a>1540</td><td></td><td></td><td></td><td></td><td class="s">        ) {</td></tr>
<tr><td class="h"><a name="1541"></a>1541</td><td></td><td></td><td></td><td></td><td class="s">          $value = { $self-&gt;{opt}-&gt;{valueattr}-&gt;{$key} =&gt; $value };</td></tr>
<tr><td class="h"><a name="1542"></a>1542</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1543"></a>1543</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1544"></a>1544</td><td></td><td></td><td></td><td></td><td class="s">        if(ref($value)  or  $self-&gt;{opt}-&gt;{noattr}) {</td></tr>
<tr><td class="h"><a name="1545"></a>1545</td><td></td><td></td><td></td><td></td><td class="s">          push @nested,</td></tr>
<tr><td class="h"><a name="1546"></a>1546</td><td></td><td></td><td></td><td></td><td class="s">            $self-&gt;value_to_xml($value, $key, &quot;$indent  &quot;);</td></tr>
<tr><td class="h"><a name="1547"></a>1547</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1548"></a>1548</td><td></td><td></td><td></td><td></td><td class="s">        else {</td></tr>
<tr><td class="h"><a name="1549"></a>1549</td><td></td><td></td><td></td><td></td><td class="s">          $value = $self-&gt;escape_value($value) unless($self-&gt;{opt}-&gt;{noescape});</td></tr>
<tr><td class="h"><a name="1550"></a>1550</td><td></td><td></td><td></td><td></td><td class="s">          if($key eq $self-&gt;{opt}-&gt;{contentkey}) {</td></tr>
<tr><td class="h"><a name="1551"></a>1551</td><td></td><td></td><td></td><td></td><td class="s">            $text_content = $value;</td></tr>
<tr><td class="h"><a name="1552"></a>1552</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="1553"></a>1553</td><td></td><td></td><td></td><td></td><td class="s">          else {</td></tr>
<tr><td class="h"><a name="1554"></a>1554</td><td></td><td></td><td></td><td></td><td class="s">            push @result, &quot;\n$indent &quot; . ' ' x length($name)</td></tr>
<tr><td class="h"><a name="1555"></a>1555</td><td></td><td></td><td></td><td></td><td class="s">              if($self-&gt;{opt}-&gt;{attrindent}  and  !$first_arg);</td></tr>
<tr><td class="h"><a name="1556"></a>1556</td><td></td><td></td><td></td><td></td><td class="s">            push @result, ' ', $key, '=&quot;', $value , '&quot;';</td></tr>
<tr><td class="h"><a name="1557"></a>1557</td><td></td><td></td><td></td><td></td><td class="s">            $first_arg = 0;</td></tr>
<tr><td class="h"><a name="1558"></a>1558</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="1559"></a>1559</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1560"></a>1560</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1561"></a>1561</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1562"></a>1562</td><td></td><td></td><td></td><td></td><td class="s">    else {</td></tr>
<tr><td class="h"><a name="1563"></a>1563</td><td></td><td></td><td></td><td></td><td class="s">      $text_content = '';</td></tr>
<tr><td class="h"><a name="1564"></a>1564</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1565"></a>1565</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1566"></a>1566</td><td></td><td></td><td></td><td></td><td class="s">    if(@nested  or  defined($text_content)) {</td></tr>
<tr><td class="h"><a name="1567"></a>1567</td><td></td><td></td><td></td><td></td><td class="s">      if($named) {</td></tr>
<tr><td class="h"><a name="1568"></a>1568</td><td></td><td></td><td></td><td></td><td class="s">        push @result, &quot;&gt;&quot;;</td></tr>
<tr><td class="h"><a name="1569"></a>1569</td><td></td><td></td><td></td><td></td><td class="s">        if(defined($text_content)) {</td></tr>
<tr><td class="h"><a name="1570"></a>1570</td><td></td><td></td><td></td><td></td><td class="s">          push @result, $text_content;</td></tr>
<tr><td class="h"><a name="1571"></a>1571</td><td></td><td></td><td></td><td></td><td class="s">          $nested[0] =~ s/^\s+// if(@nested);</td></tr>
<tr><td class="h"><a name="1572"></a>1572</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1573"></a>1573</td><td></td><td></td><td></td><td></td><td class="s">        else {</td></tr>
<tr><td class="h"><a name="1574"></a>1574</td><td></td><td></td><td></td><td></td><td class="s">          push @result, $nl;</td></tr>
<tr><td class="h"><a name="1575"></a>1575</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1576"></a>1576</td><td></td><td></td><td></td><td></td><td class="s">        if(@nested) {</td></tr>
<tr><td class="h"><a name="1577"></a>1577</td><td></td><td></td><td></td><td></td><td class="s">          push @result, @nested, $indent;</td></tr>
<tr><td class="h"><a name="1578"></a>1578</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1579"></a>1579</td><td></td><td></td><td></td><td></td><td class="s">        push @result, '&lt;/', $name, &quot;&gt;&quot;, $nl;</td></tr>
<tr><td class="h"><a name="1580"></a>1580</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1581"></a>1581</td><td></td><td></td><td></td><td></td><td class="s">      else {</td></tr>
<tr><td class="h"><a name="1582"></a>1582</td><td></td><td></td><td></td><td></td><td class="s">        push @result, @nested;             # Special case if no root elements</td></tr>
<tr><td class="h"><a name="1583"></a>1583</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1584"></a>1584</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1585"></a>1585</td><td></td><td></td><td></td><td></td><td class="s">    else {</td></tr>
<tr><td class="h"><a name="1586"></a>1586</td><td></td><td></td><td></td><td></td><td class="s">      push @result, &quot; /&gt;&quot;, $nl;</td></tr>
<tr><td class="h"><a name="1587"></a>1587</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1588"></a>1588</td><td></td><td></td><td></td><td></td><td class="s">    $self-&gt;{nsup}-&gt;pop_context() if($self-&gt;{nsup});</td></tr>
<tr><td class="h"><a name="1589"></a>1589</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1590"></a>1590</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1591"></a>1591</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1592"></a>1592</td><td></td><td></td><td></td><td></td><td class="s">  # Handle arrayrefs</td></tr>
<tr><td class="h"><a name="1593"></a>1593</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1594"></a>1594</td><td></td><td></td><td></td><td></td><td class="s">  elsif(UNIVERSAL::isa($ref, 'ARRAY')) {</td></tr>
<tr><td class="h"><a name="1595"></a>1595</td><td></td><td></td><td></td><td></td><td class="s">    foreach $value (@$ref) {</td></tr>
<tr><td class="h"><a name="1596"></a>1596</td><td></td><td></td><td></td><td></td><td class="s">      next if !defined($value) and $self-&gt;{opt}-&gt;{suppressempty};</td></tr>
<tr><td class="h"><a name="1597"></a>1597</td><td></td><td></td><td></td><td></td><td class="s">      if(!ref($value)) {</td></tr>
<tr><td class="h"><a name="1598"></a>1598</td><td></td><td></td><td></td><td></td><td class="s">        push @result,</td></tr>
<tr><td class="h"><a name="1599"></a>1599</td><td></td><td></td><td></td><td></td><td class="s">             $indent, '&lt;', $name, '&gt;',</td></tr>
<tr><td class="h"><a name="1600"></a>1600</td><td></td><td></td><td></td><td></td><td class="s">             ($self-&gt;{opt}-&gt;{noescape} ? $value : $self-&gt;escape_value($value)),</td></tr>
<tr><td class="h"><a name="1601"></a>1601</td><td></td><td></td><td></td><td></td><td class="s">             '&lt;/', $name, &quot;&gt;$nl&quot;;</td></tr>
<tr><td class="h"><a name="1602"></a>1602</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1603"></a>1603</td><td></td><td></td><td></td><td></td><td class="s">      elsif(UNIVERSAL::isa($value, 'HASH')) {</td></tr>
<tr><td class="h"><a name="1604"></a>1604</td><td></td><td></td><td></td><td></td><td class="s">        push @result, $self-&gt;value_to_xml($value, $name, $indent);</td></tr>
<tr><td class="h"><a name="1605"></a>1605</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1606"></a>1606</td><td></td><td></td><td></td><td></td><td class="s">      else {</td></tr>
<tr><td class="h"><a name="1607"></a>1607</td><td></td><td></td><td></td><td></td><td class="s">        push @result,</td></tr>
<tr><td class="h"><a name="1608"></a>1608</td><td></td><td></td><td></td><td></td><td class="s">               $indent, '&lt;', $name, &quot;&gt;$nl&quot;,</td></tr>
<tr><td class="h"><a name="1609"></a>1609</td><td></td><td></td><td></td><td></td><td class="s">               $self-&gt;value_to_xml($value, 'anon', &quot;$indent  &quot;),</td></tr>
<tr><td class="h"><a name="1610"></a>1610</td><td></td><td></td><td></td><td></td><td class="s">               $indent, '&lt;/', $name, &quot;&gt;$nl&quot;;</td></tr>
<tr><td class="h"><a name="1611"></a>1611</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1612"></a>1612</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1613"></a>1613</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1614"></a>1614</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1615"></a>1615</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="1616"></a>1616</td><td></td><td></td><td></td><td></td><td class="s">    croak &quot;Can't encode a value of type: &quot; . ref($ref);</td></tr>
<tr><td class="h"><a name="1617"></a>1617</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1618"></a>1618</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1619"></a>1619</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1620"></a>1620</td><td></td><td></td><td></td><td></td><td class="s">  pop @{$self-&gt;{_ancestors}} if(ref($ref));</td></tr>
<tr><td class="h"><a name="1621"></a>1621</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1622"></a>1622</td><td></td><td></td><td></td><td></td><td class="s">  return(join('', @result));</td></tr>
<tr><td class="h"><a name="1623"></a>1623</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1624"></a>1624</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1625"></a>1625</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1626"></a>1626</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1627"></a>1627</td><td></td><td></td><td></td><td></td><td class="s"># Method: sorted_keys()</td></tr>
<tr><td class="h"><a name="1628"></a>1628</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1629"></a>1629</td><td></td><td></td><td></td><td></td><td class="s"># Returns the keys of the referenced hash sorted into alphabetical order, but</td></tr>
<tr><td class="h"><a name="1630"></a>1630</td><td></td><td></td><td></td><td></td><td class="s"># with the 'key' key (as in KeyAttr) first, if there is one.</td></tr>
<tr><td class="h"><a name="1631"></a>1631</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1632"></a>1632</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1633"></a>1633</td><td></td><td></td><td></td><td></td><td class="s">sub sorted_keys {</td></tr>
<tr><td class="h"><a name="1634"></a>1634</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $name, $ref) = @_;</td></tr>
<tr><td class="h"><a name="1635"></a>1635</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1636"></a>1636</td><td></td><td></td><td></td><td></td><td class="s">  return keys %$ref if $self-&gt;{opt}-&gt;{nosort};</td></tr>
<tr><td class="h"><a name="1637"></a>1637</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1638"></a>1638</td><td></td><td></td><td></td><td></td><td class="s">  my %hash = %$ref;</td></tr>
<tr><td class="h"><a name="1639"></a>1639</td><td></td><td></td><td></td><td></td><td class="s">  my $keyattr = $self-&gt;{opt}-&gt;{keyattr};</td></tr>
<tr><td class="h"><a name="1640"></a>1640</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1641"></a>1641</td><td></td><td></td><td></td><td></td><td class="s">  my @key;</td></tr>
<tr><td class="h"><a name="1642"></a>1642</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1643"></a>1643</td><td></td><td></td><td></td><td></td><td class="s">  if(ref $keyattr eq 'HASH') {</td></tr>
<tr><td class="h"><a name="1644"></a>1644</td><td></td><td></td><td></td><td></td><td class="s">    if(exists $keyattr-&gt;{$name} and exists $hash{$keyattr-&gt;{$name}-&gt;[0]}) {</td></tr>
<tr><td class="h"><a name="1645"></a>1645</td><td></td><td></td><td></td><td></td><td class="s">      push @key, $keyattr-&gt;{$name}-&gt;[0];</td></tr>
<tr><td class="h"><a name="1646"></a>1646</td><td></td><td></td><td></td><td></td><td class="s">      delete $hash{$keyattr-&gt;{$name}-&gt;[0]};</td></tr>
<tr><td class="h"><a name="1647"></a>1647</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1648"></a>1648</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1649"></a>1649</td><td></td><td></td><td></td><td></td><td class="s">  elsif(ref $keyattr eq 'ARRAY') {</td></tr>
<tr><td class="h"><a name="1650"></a>1650</td><td></td><td></td><td></td><td></td><td class="s">    foreach (@{$keyattr}) {</td></tr>
<tr><td class="h"><a name="1651"></a>1651</td><td></td><td></td><td></td><td></td><td class="s">      if(exists $hash{$_}) {</td></tr>
<tr><td class="h"><a name="1652"></a>1652</td><td></td><td></td><td></td><td></td><td class="s">        push @key, $_;</td></tr>
<tr><td class="h"><a name="1653"></a>1653</td><td></td><td></td><td></td><td></td><td class="s">        delete $hash{$_};</td></tr>
<tr><td class="h"><a name="1654"></a>1654</td><td></td><td></td><td></td><td></td><td class="s">        last;</td></tr>
<tr><td class="h"><a name="1655"></a>1655</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1656"></a>1656</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1657"></a>1657</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1658"></a>1658</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1659"></a>1659</td><td></td><td></td><td></td><td></td><td class="s">  return(@key, sort keys %hash);</td></tr>
<tr><td class="h"><a name="1660"></a>1660</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1661"></a>1661</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1662"></a>1662</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1663"></a>1663</td><td></td><td></td><td></td><td></td><td class="s"># Method: escape_value()</td></tr>
<tr><td class="h"><a name="1664"></a>1664</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1665"></a>1665</td><td></td><td></td><td></td><td></td><td class="s"># Helper routine for automatically escaping values for XMLout().</td></tr>
<tr><td class="h"><a name="1666"></a>1666</td><td></td><td></td><td></td><td></td><td class="s"># Expects a scalar data value.  Returns escaped version.</td></tr>
<tr><td class="h"><a name="1667"></a>1667</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1668"></a>1668</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1669"></a>1669</td><td></td><td></td><td></td><td></td><td class="s">sub escape_value {</td></tr>
<tr><td class="h"><a name="1670"></a>1670</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $data) = @_;</td></tr>
<tr><td class="h"><a name="1671"></a>1671</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1672"></a>1672</td><td></td><td></td><td></td><td></td><td class="s">  return '' unless(defined($data));</td></tr>
<tr><td class="h"><a name="1673"></a>1673</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1674"></a>1674</td><td></td><td></td><td></td><td></td><td class="s">  $data =~ s/&amp;/&amp;amp;/sg;</td></tr>
<tr><td class="h"><a name="1675"></a>1675</td><td></td><td></td><td></td><td></td><td class="s">  $data =~ s/&lt;/&amp;lt;/sg;</td></tr>
<tr><td class="h"><a name="1676"></a>1676</td><td></td><td></td><td></td><td></td><td class="s">  $data =~ s/&gt;/&amp;gt;/sg;</td></tr>
<tr><td class="h"><a name="1677"></a>1677</td><td></td><td></td><td></td><td></td><td class="s">  $data =~ s/&quot;/&amp;quot;/sg;</td></tr>
<tr><td class="h"><a name="1678"></a>1678</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1679"></a>1679</td><td></td><td></td><td></td><td></td><td class="s">  my $level = $self-&gt;{opt}-&gt;{numericescape} or return $data;</td></tr>
<tr><td class="h"><a name="1680"></a>1680</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1681"></a>1681</td><td></td><td></td><td></td><td></td><td class="s">  return $self-&gt;numeric_escape($data, $level);</td></tr>
<tr><td class="h"><a name="1682"></a>1682</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1683"></a>1683</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1684"></a>1684</td><td></td><td></td><td></td><td></td><td class="s">sub numeric_escape {</td></tr>
<tr><td class="h"><a name="1685"></a>1685</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $data, $level) = @_;</td></tr>
<tr><td class="h"><a name="1686"></a>1686</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1687"></a>1687</td><td class="c3">3</td><td class="c0"><span title="Avg 258&micro;s">775&micro;s</span></td><td class="c3">2</td><td class="c0">203&micro;s</td><td class="s"><div class="calls"><div class="calls_in"># spent 199&micro;s (195+4) within XML::Simple::BEGIN@1687 which was called
#    once (195&micro;s+4&micro;s) by SimpleDB::Client::BEGIN@48 at <a href="XML-Simple-pm-block.html#1687">line 1687</a></div></div>  use utf8; # required for 5.6<div class="calls"><div class="calls_out">  # spent   199&micro;s making 1 call to <a href="XML-Simple-pm-block.html#1687">XML::Simple::BEGIN@1687</a>
  # spent     4&micro;s making 1 call to <a href="utf8-pm-block.html#7">utf8::import</a></div></div></td></tr>
<tr><td class="h"><a name="1688"></a>1688</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1689"></a>1689</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{numericescape} eq '2') {</td></tr>
<tr><td class="h"><a name="1690"></a>1690</td><td></td><td></td><td></td><td></td><td class="s">    $data =~ s/([^\x00-\x7F])/'&amp;#' . ord($1) . ';'/gse;</td></tr>
<tr><td class="h"><a name="1691"></a>1691</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1692"></a>1692</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="1693"></a>1693</td><td></td><td></td><td></td><td></td><td class="s">    $data =~ s/([^\x00-\xFF])/'&amp;#' . ord($1) . ';'/gse;</td></tr>
<tr><td class="h"><a name="1694"></a>1694</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1695"></a>1695</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1696"></a>1696</td><td></td><td></td><td></td><td></td><td class="s">  return $data;</td></tr>
<tr><td class="h"><a name="1697"></a>1697</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1698"></a>1698</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1699"></a>1699</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1700"></a>1700</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1701"></a>1701</td><td></td><td></td><td></td><td></td><td class="s"># Method: hash_to_array()</td></tr>
<tr><td class="h"><a name="1702"></a>1702</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1703"></a>1703</td><td></td><td></td><td></td><td></td><td class="s"># Helper routine for value_to_xml().</td></tr>
<tr><td class="h"><a name="1704"></a>1704</td><td></td><td></td><td></td><td></td><td class="s"># Attempts to 'unfold' a hash of hashes into an array of hashes.  Returns a</td></tr>
<tr><td class="h"><a name="1705"></a>1705</td><td></td><td></td><td></td><td></td><td class="s"># reference to the array on success or the original hash if unfolding is</td></tr>
<tr><td class="h"><a name="1706"></a>1706</td><td></td><td></td><td></td><td></td><td class="s"># not possible.</td></tr>
<tr><td class="h"><a name="1707"></a>1707</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1708"></a>1708</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1709"></a>1709</td><td></td><td></td><td></td><td></td><td class="s">sub hash_to_array {</td></tr>
<tr><td class="h"><a name="1710"></a>1710</td><td></td><td></td><td></td><td></td><td class="s">  my $self    = shift;</td></tr>
<tr><td class="h"><a name="1711"></a>1711</td><td></td><td></td><td></td><td></td><td class="s">  my $parent  = shift;</td></tr>
<tr><td class="h"><a name="1712"></a>1712</td><td></td><td></td><td></td><td></td><td class="s">  my $hashref = shift;</td></tr>
<tr><td class="h"><a name="1713"></a>1713</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1714"></a>1714</td><td></td><td></td><td></td><td></td><td class="s">  my $arrayref = [];</td></tr>
<tr><td class="h"><a name="1715"></a>1715</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1716"></a>1716</td><td></td><td></td><td></td><td></td><td class="s">  my($key, $value);</td></tr>
<tr><td class="h"><a name="1717"></a>1717</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1718"></a>1718</td><td></td><td></td><td></td><td></td><td class="s">  my @keys = $self-&gt;{opt}-&gt;{nosort} ? keys %$hashref : sort keys %$hashref;</td></tr>
<tr><td class="h"><a name="1719"></a>1719</td><td></td><td></td><td></td><td></td><td class="s">  foreach $key (@keys) {</td></tr>
<tr><td class="h"><a name="1720"></a>1720</td><td></td><td></td><td></td><td></td><td class="s">    $value = $hashref-&gt;{$key};</td></tr>
<tr><td class="h"><a name="1721"></a>1721</td><td></td><td></td><td></td><td></td><td class="s">    return($hashref) unless(UNIVERSAL::isa($value, 'HASH'));</td></tr>
<tr><td class="h"><a name="1722"></a>1722</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1723"></a>1723</td><td></td><td></td><td></td><td></td><td class="s">    if(ref($self-&gt;{opt}-&gt;{keyattr}) eq 'HASH') {</td></tr>
<tr><td class="h"><a name="1724"></a>1724</td><td></td><td></td><td></td><td></td><td class="s">      return($hashref) unless(defined($self-&gt;{opt}-&gt;{keyattr}-&gt;{$parent}));</td></tr>
<tr><td class="h"><a name="1725"></a>1725</td><td></td><td></td><td></td><td></td><td class="s">      push @$arrayref, $self-&gt;copy_hash(</td></tr>
<tr><td class="h"><a name="1726"></a>1726</td><td></td><td></td><td></td><td></td><td class="s">        $value, $self-&gt;{opt}-&gt;{keyattr}-&gt;{$parent}-&gt;[0] =&gt; $key</td></tr>
<tr><td class="h"><a name="1727"></a>1727</td><td></td><td></td><td></td><td></td><td class="s">      );</td></tr>
<tr><td class="h"><a name="1728"></a>1728</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1729"></a>1729</td><td></td><td></td><td></td><td></td><td class="s">    else {</td></tr>
<tr><td class="h"><a name="1730"></a>1730</td><td></td><td></td><td></td><td></td><td class="s">      push(@$arrayref, { $self-&gt;{opt}-&gt;{keyattr}-&gt;[0] =&gt; $key, %$value });</td></tr>
<tr><td class="h"><a name="1731"></a>1731</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1732"></a>1732</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1733"></a>1733</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1734"></a>1734</td><td></td><td></td><td></td><td></td><td class="s">  return($arrayref);</td></tr>
<tr><td class="h"><a name="1735"></a>1735</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1736"></a>1736</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1737"></a>1737</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1738"></a>1738</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1739"></a>1739</td><td></td><td></td><td></td><td></td><td class="s"># Method: copy_hash()</td></tr>
<tr><td class="h"><a name="1740"></a>1740</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1741"></a>1741</td><td></td><td></td><td></td><td></td><td class="s"># Helper routine for hash_to_array().  When unfolding a hash of hashes into</td></tr>
<tr><td class="h"><a name="1742"></a>1742</td><td></td><td></td><td></td><td></td><td class="s"># an array of hashes, we need to copy the key from the outer hash into the</td></tr>
<tr><td class="h"><a name="1743"></a>1743</td><td></td><td></td><td></td><td></td><td class="s"># inner hash.  This routine makes a copy of the original hash so we don't</td></tr>
<tr><td class="h"><a name="1744"></a>1744</td><td></td><td></td><td></td><td></td><td class="s"># destroy the original data structure.  You might wish to override this</td></tr>
<tr><td class="h"><a name="1745"></a>1745</td><td></td><td></td><td></td><td></td><td class="s"># method if you're using tied hashes and don't want them to get untied.</td></tr>
<tr><td class="h"><a name="1746"></a>1746</td><td></td><td></td><td></td><td></td><td class="s">#</td></tr>
<tr><td class="h"><a name="1747"></a>1747</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1748"></a>1748</td><td></td><td></td><td></td><td></td><td class="s">sub copy_hash {</td></tr>
<tr><td class="h"><a name="1749"></a>1749</td><td></td><td></td><td></td><td></td><td class="s">  my($self, $orig, @extra) = @_;</td></tr>
<tr><td class="h"><a name="1750"></a>1750</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1751"></a>1751</td><td></td><td></td><td></td><td></td><td class="s">  return { @extra, %$orig };</td></tr>
<tr><td class="h"><a name="1752"></a>1752</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1753"></a>1753</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1754"></a>1754</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1755"></a>1755</td><td></td><td></td><td></td><td></td><td class="s"># Methods required for building trees from SAX events</td></tr>
<tr><td class="h"><a name="1756"></a>1756</td><td></td><td></td><td></td><td></td><td class="s">##############################################################################</td></tr>
<tr><td class="h"><a name="1757"></a>1757</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1758"></a>1758</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 20&micro;s within XML::Simple::start_document which was called 3 times, avg 7&micro;s/call:
# 3 times (20&micro;s+0s) by XML::SAX::Base::start_document at <a href="XML-SAX-Base-pm-block.html#1259">line 1259 of XML/SAX/Base.pm</a>, avg 7&micro;s/call</div></div>sub start_document {</td></tr>
<tr><td class="h"><a name="1759"></a>1759</td><td class="c0">12</td><td class="c1"><span title="Avg 2&micro;s">22&micro;s</span></td><td></td><td></td><td class="s">  my $self = shift;</td></tr>
<tr><td class="h"><a name="1760"></a>1760</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1761"></a>1761</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;handle_options('in') unless($self-&gt;{opt});</td></tr>
<tr><td class="h"><a name="1762"></a>1762</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1763"></a>1763</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;{lists} = [];</td></tr>
<tr><td class="h"><a name="1764"></a>1764</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;{curlist} = $self-&gt;{tree} = [];</td></tr>
<tr><td class="h"><a name="1765"></a>1765</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1766"></a>1766</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1767"></a>1767</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1768"></a>1768</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 337&micro;s within XML::Simple::start_element which was called 35 times, avg 10&micro;s/call:
# 32 times (272&micro;s+0s) by XML::SAX::Base::__ANON__[/usr/local/lib/perl5/site_perl/5.10.1/XML/SAX/Base.pm:292] at <a href="XML-SAX-Base-pm-block.html#292">line 292 of XML/SAX/Base.pm</a>, avg 9&micro;s/call
#  3 times (64&micro;s+0s) by XML::SAX::Base::start_element at <a href="XML-SAX-Base-pm-block.html#293">line 293 of XML/SAX/Base.pm</a>, avg 21&micro;s/call</div></div>sub start_element {</td></tr>
<tr><td class="h"><a name="1769"></a>1769</td><td class="c0">350</td><td class="c0"><span title="Avg 829ns">290&micro;s</span></td><td></td><td></td><td class="s">  my $self    = shift;</td></tr>
<tr><td class="h"><a name="1770"></a>1770</td><td></td><td></td><td></td><td></td><td class="s">  my $element = shift;</td></tr>
<tr><td class="h"><a name="1771"></a>1771</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1772"></a>1772</td><td></td><td></td><td></td><td></td><td class="s">  my $name = $element-&gt;{Name};</td></tr>
<tr><td class="h"><a name="1773"></a>1773</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{nsexpand}) {</td></tr>
<tr><td class="h"><a name="1774"></a>1774</td><td></td><td></td><td></td><td></td><td class="s">    $name = $element-&gt;{LocalName} || '';</td></tr>
<tr><td class="h"><a name="1775"></a>1775</td><td></td><td></td><td></td><td></td><td class="s">    if($element-&gt;{NamespaceURI}) {</td></tr>
<tr><td class="h"><a name="1776"></a>1776</td><td></td><td></td><td></td><td></td><td class="s">      $name = '{' . $element-&gt;{NamespaceURI} . '}' . $name;</td></tr>
<tr><td class="h"><a name="1777"></a>1777</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1778"></a>1778</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1779"></a>1779</td><td></td><td></td><td></td><td></td><td class="s">  my $attributes = {};</td></tr>
<tr><td class="h"><a name="1780"></a>1780</td><td class="c0">35</td><td class="c0"><span title="Avg 2&micro;s">68&micro;s</span></td><td></td><td></td><td class="s">  if($element-&gt;{Attributes}) {  # Might be undef</td></tr>
<tr><td class="h"><a name="1781"></a>1781</td><td></td><td></td><td></td><td></td><td class="s">    foreach my $attr (values %{$element-&gt;{Attributes}}) {</td></tr>
<tr><td class="h"><a name="1782"></a>1782</td><td class="c1">6</td><td class="c3"><span title="Avg 2&micro;s">15&micro;s</span></td><td></td><td></td><td class="s">      if($self-&gt;{opt}-&gt;{nsexpand}) {</td></tr>
<tr><td class="h"><a name="1783"></a>1783</td><td></td><td></td><td></td><td></td><td class="s">        my $name = $attr-&gt;{LocalName} || '';</td></tr>
<tr><td class="h"><a name="1784"></a>1784</td><td></td><td></td><td></td><td></td><td class="s">        if($attr-&gt;{NamespaceURI}) {</td></tr>
<tr><td class="h"><a name="1785"></a>1785</td><td></td><td></td><td></td><td></td><td class="s">          $name = '{' . $attr-&gt;{NamespaceURI} . '}' . $name</td></tr>
<tr><td class="h"><a name="1786"></a>1786</td><td></td><td></td><td></td><td></td><td class="s">        }</td></tr>
<tr><td class="h"><a name="1787"></a>1787</td><td></td><td></td><td></td><td></td><td class="s">        $name = 'xmlns' if($name eq $bad_def_ns_jcn);</td></tr>
<tr><td class="h"><a name="1788"></a>1788</td><td></td><td></td><td></td><td></td><td class="s">        $attributes-&gt;{$name} = $attr-&gt;{Value};</td></tr>
<tr><td class="h"><a name="1789"></a>1789</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1790"></a>1790</td><td></td><td></td><td></td><td></td><td class="s">      else {</td></tr>
<tr><td class="h"><a name="1791"></a>1791</td><td></td><td></td><td></td><td></td><td class="s">        $attributes-&gt;{$attr-&gt;{Name}} = $attr-&gt;{Value};</td></tr>
<tr><td class="h"><a name="1792"></a>1792</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1793"></a>1793</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="1794"></a>1794</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1795"></a>1795</td><td></td><td></td><td></td><td></td><td class="s">  my $newlist = [ $attributes ];</td></tr>
<tr><td class="h"><a name="1796"></a>1796</td><td></td><td></td><td></td><td></td><td class="s">  push @{ $self-&gt;{lists} }, $self-&gt;{curlist};</td></tr>
<tr><td class="h"><a name="1797"></a>1797</td><td></td><td></td><td></td><td></td><td class="s">  push @{ $self-&gt;{curlist} }, $name =&gt; $newlist;</td></tr>
<tr><td class="h"><a name="1798"></a>1798</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;{curlist} = $newlist;</td></tr>
<tr><td class="h"><a name="1799"></a>1799</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1800"></a>1800</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1801"></a>1801</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1802"></a>1802</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 176&micro;s within XML::Simple::characters which was called 28 times, avg 6&micro;s/call:
# 25 times (147&micro;s+0s) by XML::SAX::Base::__ANON__[/usr/local/lib/perl5/site_perl/5.10.1/XML/SAX/Base.pm:200] at <a href="XML-SAX-Base-pm-block.html#200">line 200 of XML/SAX/Base.pm</a>, avg 6&micro;s/call
#  3 times (29&micro;s+0s) by XML::SAX::Base::characters at <a href="XML-SAX-Base-pm-block.html#201">line 201 of XML/SAX/Base.pm</a>, avg 10&micro;s/call</div></div>sub characters {</td></tr>
<tr><td class="h"><a name="1803"></a>1803</td><td class="c0">168</td><td class="c0"><span title="Avg 1&micro;s">178&micro;s</span></td><td></td><td></td><td class="s">  my $self  = shift;</td></tr>
<tr><td class="h"><a name="1804"></a>1804</td><td></td><td></td><td></td><td></td><td class="s">  my $chars = shift;</td></tr>
<tr><td class="h"><a name="1805"></a>1805</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1806"></a>1806</td><td></td><td></td><td></td><td></td><td class="s">  my $text  = $chars-&gt;{Data};</td></tr>
<tr><td class="h"><a name="1807"></a>1807</td><td></td><td></td><td></td><td></td><td class="s">  my $clist = $self-&gt;{curlist};</td></tr>
<tr><td class="h"><a name="1808"></a>1808</td><td></td><td></td><td></td><td></td><td class="s">  my $pos = $#$clist;</td></tr>
<tr><td class="h"><a name="1809"></a>1809</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="1810"></a>1810</td><td class="c0">28</td><td class="c0"><span title="Avg 1&micro;s">40&micro;s</span></td><td></td><td></td><td class="s">  if ($pos &gt; 0 and $clist-&gt;[$pos - 1] eq '0') {</td></tr>
<tr><td class="h"><a name="1811"></a>1811</td><td></td><td></td><td></td><td></td><td class="s">    $clist-&gt;[$pos] .= $text;</td></tr>
<tr><td class="h"><a name="1812"></a>1812</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1813"></a>1813</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="1814"></a>1814</td><td></td><td></td><td></td><td></td><td class="s">    push @$clist, 0 =&gt; $text;</td></tr>
<tr><td class="h"><a name="1815"></a>1815</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1816"></a>1816</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1817"></a>1817</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1818"></a>1818</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1819"></a>1819</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 67&micro;s within XML::Simple::end_element which was called 35 times, avg 2&micro;s/call:
# 32 times (56&micro;s+0s) by XML::SAX::Base::__ANON__[/usr/local/lib/perl5/site_perl/5.10.1/XML/SAX/Base.pm:2201] at <a href="XML-SAX-Base-pm-block.html#2201">line 2201 of XML/SAX/Base.pm</a>, avg 2&micro;s/call
#  3 times (11&micro;s+0s) by XML::SAX::Base::end_element at <a href="XML-SAX-Base-pm-block.html#2202">line 2202 of XML/SAX/Base.pm</a>, avg 4&micro;s/call</div></div>sub end_element {</td></tr>
<tr><td class="h"><a name="1820"></a>1820</td><td class="c0">70</td><td class="c0"><span title="Avg 2&micro;s">129&micro;s</span></td><td></td><td></td><td class="s">  my $self    = shift;</td></tr>
<tr><td class="h"><a name="1821"></a>1821</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1822"></a>1822</td><td></td><td></td><td></td><td></td><td class="s">  $self-&gt;{curlist} = pop @{ $self-&gt;{lists} };</td></tr>
<tr><td class="h"><a name="1823"></a>1823</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1824"></a>1824</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1825"></a>1825</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1826"></a>1826</td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 17&micro;s within XML::Simple::end_document which was called 3 times, avg 6&micro;s/call:
# 3 times (17&micro;s+0s) by XML::SAX::Base::end_document at <a href="XML-SAX-Base-pm-block.html#1443">line 1443 of XML/SAX/Base.pm</a>, avg 6&micro;s/call</div></div>sub end_document {</td></tr>
<tr><td class="h"><a name="1827"></a>1827</td><td class="c0">18</td><td class="c2"><span title="Avg 1&micro;s">20&micro;s</span></td><td></td><td></td><td class="s">  my $self = shift;</td></tr>
<tr><td class="h"><a name="1828"></a>1828</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1829"></a>1829</td><td></td><td></td><td></td><td></td><td class="s">  delete($self-&gt;{curlist});</td></tr>
<tr><td class="h"><a name="1830"></a>1830</td><td></td><td></td><td></td><td></td><td class="s">  delete($self-&gt;{lists});</td></tr>
<tr><td class="h"><a name="1831"></a>1831</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1832"></a>1832</td><td></td><td></td><td></td><td></td><td class="s">  my $tree = $self-&gt;{tree};</td></tr>
<tr><td class="h"><a name="1833"></a>1833</td><td></td><td></td><td></td><td></td><td class="s">  delete($self-&gt;{tree});</td></tr>
<tr><td class="h"><a name="1834"></a>1834</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1835"></a>1835</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1836"></a>1836</td><td></td><td></td><td></td><td></td><td class="s">  # Return tree as-is to XMLin()</td></tr>
<tr><td class="h"><a name="1837"></a>1837</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1838"></a>1838</td><td></td><td></td><td></td><td></td><td class="s">  return($tree) if($self-&gt;{nocollapse});</td></tr>
<tr><td class="h"><a name="1839"></a>1839</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1840"></a>1840</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1841"></a>1841</td><td></td><td></td><td></td><td></td><td class="s">  # Or collapse it before returning it to SAX parser class</td></tr>
<tr><td class="h"><a name="1842"></a>1842</td><td></td><td></td><td></td><td></td><td class="s">  </td></tr>
<tr><td class="h"><a name="1843"></a>1843</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{keeproot}) {</td></tr>
<tr><td class="h"><a name="1844"></a>1844</td><td></td><td></td><td></td><td></td><td class="s">    $tree = $self-&gt;collapse({}, @$tree);</td></tr>
<tr><td class="h"><a name="1845"></a>1845</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1846"></a>1846</td><td></td><td></td><td></td><td></td><td class="s">  else {</td></tr>
<tr><td class="h"><a name="1847"></a>1847</td><td></td><td></td><td></td><td></td><td class="s">    $tree = $self-&gt;collapse(@{$tree-&gt;[1]});</td></tr>
<tr><td class="h"><a name="1848"></a>1848</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1849"></a>1849</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1850"></a>1850</td><td></td><td></td><td></td><td></td><td class="s">  if($self-&gt;{opt}-&gt;{datahandler}) {</td></tr>
<tr><td class="h"><a name="1851"></a>1851</td><td></td><td></td><td></td><td></td><td class="s">    return($self-&gt;{opt}-&gt;{datahandler}-&gt;($self, $tree));</td></tr>
<tr><td class="h"><a name="1852"></a>1852</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1853"></a>1853</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1854"></a>1854</td><td></td><td></td><td></td><td></td><td class="s">  return($tree);</td></tr>
<tr><td class="h"><a name="1855"></a>1855</td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h"><a name="1856"></a>1856</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1857"></a>1857</td><td class="c3">1</td><td class="c3"><span title="Avg 1&micro;s">1&micro;s</span></td><td></td><td></td><td class="s">*xml_in  = \&amp;XMLin;</td></tr>
<tr><td class="h"><a name="1858"></a>1858</td><td class="c3">1</td><td class="c3"><span title="Avg 300ns">300ns</span></td><td></td><td></td><td class="s">*xml_out = \&amp;XMLout;</td></tr>
<tr><td class="h"><a name="1859"></a>1859</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1860"></a>1860</td><td class="c3">1</td><td class="c1"><span title="Avg 28&micro;s">28&micro;s</span></td><td></td><td></td><td class="s">1;</td></tr>
<tr><td class="h"><a name="1861"></a>1861</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1862"></a>1862</td><td></td><td></td><td></td><td></td><td class="s">__END__</td></tr>
<tr><td class="h"><a name="1863"></a>1863</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1864"></a>1864</td><td></td><td></td><td></td><td></td><td class="s">=head1 QUICK START</td></tr>
<tr><td class="h"><a name="1865"></a>1865</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1866"></a>1866</td><td></td><td></td><td></td><td></td><td class="s">Say you have a script called B&lt;foo&gt; and a file of configuration options</td></tr>
<tr><td class="h"><a name="1867"></a>1867</td><td></td><td></td><td></td><td></td><td class="s">called B&lt;foo.xml&gt; containing this:</td></tr>
<tr><td class="h"><a name="1868"></a>1868</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1869"></a>1869</td><td></td><td></td><td></td><td></td><td class="s">  &lt;config logdir=&quot;/var/log/foo/&quot; debugfile=&quot;/tmp/foo.debug&quot;&gt;</td></tr>
<tr><td class="h"><a name="1870"></a>1870</td><td></td><td></td><td></td><td></td><td class="s">    &lt;server name=&quot;sahara&quot; osname=&quot;solaris&quot; osversion=&quot;2.6&quot;&gt;</td></tr>
<tr><td class="h"><a name="1871"></a>1871</td><td></td><td></td><td></td><td></td><td class="s">      &lt;address&gt;10.0.0.101&lt;/address&gt;</td></tr>
<tr><td class="h"><a name="1872"></a>1872</td><td></td><td></td><td></td><td></td><td class="s">      &lt;address&gt;10.0.1.101&lt;/address&gt;</td></tr>
<tr><td class="h"><a name="1873"></a>1873</td><td></td><td></td><td></td><td></td><td class="s">    &lt;/server&gt;</td></tr>
<tr><td class="h"><a name="1874"></a>1874</td><td></td><td></td><td></td><td></td><td class="s">    &lt;server name=&quot;gobi&quot; osname=&quot;irix&quot; osversion=&quot;6.5&quot;&gt;</td></tr>
<tr><td class="h"><a name="1875"></a>1875</td><td></td><td></td><td></td><td></td><td class="s">      &lt;address&gt;10.0.0.102&lt;/address&gt;</td></tr>
<tr><td class="h"><a name="1876"></a>1876</td><td></td><td></td><td></td><td></td><td class="s">    &lt;/server&gt;</td></tr>
<tr><td class="h"><a name="1877"></a>1877</td><td></td><td></td><td></td><td></td><td class="s">    &lt;server name=&quot;kalahari&quot; osname=&quot;linux&quot; osversion=&quot;2.0.34&quot;&gt;</td></tr>
<tr><td class="h"><a name="1878"></a>1878</td><td></td><td></td><td></td><td></td><td class="s">      &lt;address&gt;10.0.0.103&lt;/address&gt;</td></tr>
<tr><td class="h"><a name="1879"></a>1879</td><td></td><td></td><td></td><td></td><td class="s">      &lt;address&gt;10.0.1.103&lt;/address&gt;</td></tr>
<tr><td class="h"><a name="1880"></a>1880</td><td></td><td></td><td></td><td></td><td class="s">    &lt;/server&gt;</td></tr>
<tr><td class="h"><a name="1881"></a>1881</td><td></td><td></td><td></td><td></td><td class="s">  &lt;/config&gt;</td></tr>
<tr><td class="h"><a name="1882"></a>1882</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1883"></a>1883</td><td></td><td></td><td></td><td></td><td class="s">The following lines of code in B&lt;foo&gt;:</td></tr>
<tr><td class="h"><a name="1884"></a>1884</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1885"></a>1885</td><td></td><td></td><td></td><td></td><td class="s">  use XML::Simple;</td></tr>
<tr><td class="h"><a name="1886"></a>1886</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1887"></a>1887</td><td></td><td></td><td></td><td></td><td class="s">  my $config = XMLin();</td></tr>
<tr><td class="h"><a name="1888"></a>1888</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1889"></a>1889</td><td></td><td></td><td></td><td></td><td class="s">will 'slurp' the configuration options into the hashref $config (because no</td></tr>
<tr><td class="h"><a name="1890"></a>1890</td><td></td><td></td><td></td><td></td><td class="s">arguments are passed to C&lt;XMLin()&gt; the name and location of the XML file will</td></tr>
<tr><td class="h"><a name="1891"></a>1891</td><td></td><td></td><td></td><td></td><td class="s">be inferred from name and location of the script).  You can dump out the</td></tr>
<tr><td class="h"><a name="1892"></a>1892</td><td></td><td></td><td></td><td></td><td class="s">contents of the hashref using Data::Dumper:</td></tr>
<tr><td class="h"><a name="1893"></a>1893</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1894"></a>1894</td><td></td><td></td><td></td><td></td><td class="s">  use Data::Dumper;</td></tr>
<tr><td class="h"><a name="1895"></a>1895</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1896"></a>1896</td><td></td><td></td><td></td><td></td><td class="s">  print Dumper($config);</td></tr>
<tr><td class="h"><a name="1897"></a>1897</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1898"></a>1898</td><td></td><td></td><td></td><td></td><td class="s">which will produce something like this (formatting has been adjusted for</td></tr>
<tr><td class="h"><a name="1899"></a>1899</td><td></td><td></td><td></td><td></td><td class="s">brevity):</td></tr>
<tr><td class="h"><a name="1900"></a>1900</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1901"></a>1901</td><td></td><td></td><td></td><td></td><td class="s">  {</td></tr>
<tr><td class="h"><a name="1902"></a>1902</td><td></td><td></td><td></td><td></td><td class="s">      'logdir'        =&gt; '/var/log/foo/',</td></tr>
<tr><td class="h"><a name="1903"></a>1903</td><td></td><td></td><td></td><td></td><td class="s">      'debugfile'     =&gt; '/tmp/foo.debug',</td></tr>
<tr><td class="h"><a name="1904"></a>1904</td><td></td><td></td><td></td><td></td><td class="s">      'server'        =&gt; {</td></tr>
<tr><td class="h"><a name="1905"></a>1905</td><td></td><td></td><td></td><td></td><td class="s">          'sahara'        =&gt; {</td></tr>
<tr><td class="h"><a name="1906"></a>1906</td><td></td><td></td><td></td><td></td><td class="s">              'osversion'     =&gt; '2.6',</td></tr>
<tr><td class="h"><a name="1907"></a>1907</td><td></td><td></td><td></td><td></td><td class="s">              'osname'        =&gt; 'solaris',</td></tr>
<tr><td class="h"><a name="1908"></a>1908</td><td></td><td></td><td></td><td></td><td class="s">              'address'       =&gt; [ '10.0.0.101', '10.0.1.101' ]</td></tr>
<tr><td class="h"><a name="1909"></a>1909</td><td></td><td></td><td></td><td></td><td class="s">          },</td></tr>
<tr><td class="h"><a name="1910"></a>1910</td><td></td><td></td><td></td><td></td><td class="s">          'gobi'          =&gt; {</td></tr>
<tr><td class="h"><a name="1911"></a>1911</td><td></td><td></td><td></td><td></td><td class="s">              'osversion'     =&gt; '6.5',</td></tr>
<tr><td class="h"><a name="1912"></a>1912</td><td></td><td></td><td></td><td></td><td class="s">              'osname'        =&gt; 'irix',</td></tr>
<tr><td class="h"><a name="1913"></a>1913</td><td></td><td></td><td></td><td></td><td class="s">              'address'       =&gt; '10.0.0.102'</td></tr>
<tr><td class="h"><a name="1914"></a>1914</td><td></td><td></td><td></td><td></td><td class="s">          },</td></tr>
<tr><td class="h"><a name="1915"></a>1915</td><td></td><td></td><td></td><td></td><td class="s">          'kalahari'      =&gt; {</td></tr>
<tr><td class="h"><a name="1916"></a>1916</td><td></td><td></td><td></td><td></td><td class="s">              'osversion'     =&gt; '2.0.34',</td></tr>
<tr><td class="h"><a name="1917"></a>1917</td><td></td><td></td><td></td><td></td><td class="s">              'osname'        =&gt; 'linux',</td></tr>
<tr><td class="h"><a name="1918"></a>1918</td><td></td><td></td><td></td><td></td><td class="s">              'address'       =&gt; [ '10.0.0.103', '10.0.1.103' ]</td></tr>
<tr><td class="h"><a name="1919"></a>1919</td><td></td><td></td><td></td><td></td><td class="s">          }</td></tr>
<tr><td class="h"><a name="1920"></a>1920</td><td></td><td></td><td></td><td></td><td class="s">      }</td></tr>
<tr><td class="h"><a name="1921"></a>1921</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="1922"></a>1922</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1923"></a>1923</td><td></td><td></td><td></td><td></td><td class="s">Your script could then access the name of the log directory like this:</td></tr>
<tr><td class="h"><a name="1924"></a>1924</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1925"></a>1925</td><td></td><td></td><td></td><td></td><td class="s">  print $config-&gt;{logdir};</td></tr>
<tr><td class="h"><a name="1926"></a>1926</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1927"></a>1927</td><td></td><td></td><td></td><td></td><td class="s">similarly, the second address on the server 'kalahari' could be referenced as:</td></tr>
<tr><td class="h"><a name="1928"></a>1928</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1929"></a>1929</td><td></td><td></td><td></td><td></td><td class="s">  print $config-&gt;{server}-&gt;{kalahari}-&gt;{address}-&gt;[1];</td></tr>
<tr><td class="h"><a name="1930"></a>1930</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1931"></a>1931</td><td></td><td></td><td></td><td></td><td class="s">What could be simpler?  (Rhetorical).</td></tr>
<tr><td class="h"><a name="1932"></a>1932</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1933"></a>1933</td><td></td><td></td><td></td><td></td><td class="s">For simple requirements, that's really all there is to it.  If you want to</td></tr>
<tr><td class="h"><a name="1934"></a>1934</td><td></td><td></td><td></td><td></td><td class="s">store your XML in a different directory or file, or pass it in as a string or</td></tr>
<tr><td class="h"><a name="1935"></a>1935</td><td></td><td></td><td></td><td></td><td class="s">even pass it in via some derivative of an IO::Handle, you'll need to check out</td></tr>
<tr><td class="h"><a name="1936"></a>1936</td><td></td><td></td><td></td><td></td><td class="s">L&lt;&quot;OPTIONS&quot;&gt;.  If you want to turn off or tweak the array folding feature (that</td></tr>
<tr><td class="h"><a name="1937"></a>1937</td><td></td><td></td><td></td><td></td><td class="s">neat little transformation that produced $config-&gt;{server}) you'll find options</td></tr>
<tr><td class="h"><a name="1938"></a>1938</td><td></td><td></td><td></td><td></td><td class="s">for that as well.</td></tr>
<tr><td class="h"><a name="1939"></a>1939</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1940"></a>1940</td><td></td><td></td><td></td><td></td><td class="s">If you want to generate XML (for example to write a modified version of</td></tr>
<tr><td class="h"><a name="1941"></a>1941</td><td></td><td></td><td></td><td></td><td class="s">$config back out as XML), check out C&lt;XMLout()&gt;.</td></tr>
<tr><td class="h"><a name="1942"></a>1942</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1943"></a>1943</td><td></td><td></td><td></td><td></td><td class="s">If your needs are not so simple, this may not be the module for you.  In that</td></tr>
<tr><td class="h"><a name="1944"></a>1944</td><td></td><td></td><td></td><td></td><td class="s">case, you might want to read L&lt;&quot;WHERE TO FROM HERE?&quot;&gt;.</td></tr>
<tr><td class="h"><a name="1945"></a>1945</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1946"></a>1946</td><td></td><td></td><td></td><td></td><td class="s">=head1 DESCRIPTION</td></tr>
<tr><td class="h"><a name="1947"></a>1947</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1948"></a>1948</td><td></td><td></td><td></td><td></td><td class="s">The XML::Simple module provides a simple API layer on top of an underlying XML</td></tr>
<tr><td class="h"><a name="1949"></a>1949</td><td></td><td></td><td></td><td></td><td class="s">parsing module (either XML::Parser or one of the SAX2 parser modules).  Two</td></tr>
<tr><td class="h"><a name="1950"></a>1950</td><td></td><td></td><td></td><td></td><td class="s">functions are exported: C&lt;XMLin()&gt; and C&lt;XMLout()&gt;.  Note: you can explicity</td></tr>
<tr><td class="h"><a name="1951"></a>1951</td><td></td><td></td><td></td><td></td><td class="s">request the lower case versions of the function names: C&lt;xml_in()&gt; and</td></tr>
<tr><td class="h"><a name="1952"></a>1952</td><td></td><td></td><td></td><td></td><td class="s">C&lt;xml_out()&gt;.</td></tr>
<tr><td class="h"><a name="1953"></a>1953</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1954"></a>1954</td><td></td><td></td><td></td><td></td><td class="s">The simplest approach is to call these two functions directly, but an</td></tr>
<tr><td class="h"><a name="1955"></a>1955</td><td></td><td></td><td></td><td></td><td class="s">optional object oriented interface (see L&lt;&quot;OPTIONAL OO INTERFACE&quot;&gt; below)</td></tr>
<tr><td class="h"><a name="1956"></a>1956</td><td></td><td></td><td></td><td></td><td class="s">allows them to be called as methods of an B&lt;XML::Simple&gt; object.  The object</td></tr>
<tr><td class="h"><a name="1957"></a>1957</td><td></td><td></td><td></td><td></td><td class="s">interface can also be used at either end of a SAX pipeline.</td></tr>
<tr><td class="h"><a name="1958"></a>1958</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1959"></a>1959</td><td></td><td></td><td></td><td></td><td class="s">=head2 XMLin()</td></tr>
<tr><td class="h"><a name="1960"></a>1960</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1961"></a>1961</td><td></td><td></td><td></td><td></td><td class="s">Parses XML formatted data and returns a reference to a data structure which</td></tr>
<tr><td class="h"><a name="1962"></a>1962</td><td></td><td></td><td></td><td></td><td class="s">contains the same information in a more readily accessible form.  (Skip</td></tr>
<tr><td class="h"><a name="1963"></a>1963</td><td></td><td></td><td></td><td></td><td class="s">down to L&lt;&quot;EXAMPLES&quot;&gt; below, for more sample code).</td></tr>
<tr><td class="h"><a name="1964"></a>1964</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1965"></a>1965</td><td></td><td></td><td></td><td></td><td class="s">C&lt;XMLin()&gt; accepts an optional XML specifier followed by zero or more 'name =&gt;</td></tr>
<tr><td class="h"><a name="1966"></a>1966</td><td></td><td></td><td></td><td></td><td class="s">value' option pairs.  The XML specifier can be one of the following:</td></tr>
<tr><td class="h"><a name="1967"></a>1967</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1968"></a>1968</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="1969"></a>1969</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1970"></a>1970</td><td></td><td></td><td></td><td></td><td class="s">=item A filename</td></tr>
<tr><td class="h"><a name="1971"></a>1971</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1972"></a>1972</td><td></td><td></td><td></td><td></td><td class="s">If the filename contains no directory components C&lt;XMLin()&gt; will look for the</td></tr>
<tr><td class="h"><a name="1973"></a>1973</td><td></td><td></td><td></td><td></td><td class="s">file in each directory in the SearchPath (see L&lt;&quot;OPTIONS&quot;&gt; below) or in the</td></tr>
<tr><td class="h"><a name="1974"></a>1974</td><td></td><td></td><td></td><td></td><td class="s">current directory if the SearchPath option is not defined.  eg:</td></tr>
<tr><td class="h"><a name="1975"></a>1975</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1976"></a>1976</td><td></td><td></td><td></td><td></td><td class="s">  $ref = XMLin('/etc/params.xml');</td></tr>
<tr><td class="h"><a name="1977"></a>1977</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1978"></a>1978</td><td></td><td></td><td></td><td></td><td class="s">Note, the filename '-' can be used to parse from STDIN.</td></tr>
<tr><td class="h"><a name="1979"></a>1979</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1980"></a>1980</td><td></td><td></td><td></td><td></td><td class="s">=item undef</td></tr>
<tr><td class="h"><a name="1981"></a>1981</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1982"></a>1982</td><td></td><td></td><td></td><td></td><td class="s">If there is no XML specifier, C&lt;XMLin()&gt; will check the script directory and</td></tr>
<tr><td class="h"><a name="1983"></a>1983</td><td></td><td></td><td></td><td></td><td class="s">each of the SearchPath directories for a file with the same name as the script</td></tr>
<tr><td class="h"><a name="1984"></a>1984</td><td></td><td></td><td></td><td></td><td class="s">but with the extension '.xml'.  Note: if you wish to specify options, you</td></tr>
<tr><td class="h"><a name="1985"></a>1985</td><td></td><td></td><td></td><td></td><td class="s">must specify the value 'undef'.  eg:</td></tr>
<tr><td class="h"><a name="1986"></a>1986</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1987"></a>1987</td><td></td><td></td><td></td><td></td><td class="s">  $ref = XMLin(undef, ForceArray =&gt; 1);</td></tr>
<tr><td class="h"><a name="1988"></a>1988</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1989"></a>1989</td><td></td><td></td><td></td><td></td><td class="s">=item A string of XML</td></tr>
<tr><td class="h"><a name="1990"></a>1990</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1991"></a>1991</td><td></td><td></td><td></td><td></td><td class="s">A string containing XML (recognised by the presence of '&lt;' and '&gt;' characters)</td></tr>
<tr><td class="h"><a name="1992"></a>1992</td><td></td><td></td><td></td><td></td><td class="s">will be parsed directly.  eg:</td></tr>
<tr><td class="h"><a name="1993"></a>1993</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1994"></a>1994</td><td></td><td></td><td></td><td></td><td class="s">  $ref = XMLin('&lt;opt username=&quot;bob&quot; password=&quot;flurp&quot; /&gt;');</td></tr>
<tr><td class="h"><a name="1995"></a>1995</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1996"></a>1996</td><td></td><td></td><td></td><td></td><td class="s">=item An IO::Handle object</td></tr>
<tr><td class="h"><a name="1997"></a>1997</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="1998"></a>1998</td><td></td><td></td><td></td><td></td><td class="s">An IO::Handle object will be read to EOF and its contents parsed. eg:</td></tr>
<tr><td class="h"><a name="1999"></a>1999</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2000"></a>2000</td><td></td><td></td><td></td><td></td><td class="s">  $fh = IO::File-&gt;new('/etc/params.xml');</td></tr>
<tr><td class="h"><a name="2001"></a>2001</td><td></td><td></td><td></td><td></td><td class="s">  $ref = XMLin($fh);</td></tr>
<tr><td class="h"><a name="2002"></a>2002</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2003"></a>2003</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="2004"></a>2004</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2005"></a>2005</td><td></td><td></td><td></td><td></td><td class="s">=head2 XMLout()</td></tr>
<tr><td class="h"><a name="2006"></a>2006</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2007"></a>2007</td><td></td><td></td><td></td><td></td><td class="s">Takes a data structure (generally a hashref) and returns an XML encoding of</td></tr>
<tr><td class="h"><a name="2008"></a>2008</td><td></td><td></td><td></td><td></td><td class="s">that structure.  If the resulting XML is parsed using C&lt;XMLin()&gt;, it should</td></tr>
<tr><td class="h"><a name="2009"></a>2009</td><td></td><td></td><td></td><td></td><td class="s">return a data structure equivalent to the original (see caveats below). </td></tr>
<tr><td class="h"><a name="2010"></a>2010</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2011"></a>2011</td><td></td><td></td><td></td><td></td><td class="s">The C&lt;XMLout()&gt; function can also be used to output the XML as SAX events</td></tr>
<tr><td class="h"><a name="2012"></a>2012</td><td></td><td></td><td></td><td></td><td class="s">see the C&lt;Handler&gt; option and L&lt;&quot;SAX SUPPORT&quot;&gt; for more details).</td></tr>
<tr><td class="h"><a name="2013"></a>2013</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2014"></a>2014</td><td></td><td></td><td></td><td></td><td class="s">When translating hashes to XML, hash keys which have a leading '-' will be</td></tr>
<tr><td class="h"><a name="2015"></a>2015</td><td></td><td></td><td></td><td></td><td class="s">silently skipped.  This is the approved method for marking elements of a</td></tr>
<tr><td class="h"><a name="2016"></a>2016</td><td></td><td></td><td></td><td></td><td class="s">data structure which should be ignored by C&lt;XMLout&gt;.  (Note: If these items</td></tr>
<tr><td class="h"><a name="2017"></a>2017</td><td></td><td></td><td></td><td></td><td class="s">were not skipped the key names would be emitted as element or attribute names</td></tr>
<tr><td class="h"><a name="2018"></a>2018</td><td></td><td></td><td></td><td></td><td class="s">with a leading '-' which would not be valid XML).</td></tr>
<tr><td class="h"><a name="2019"></a>2019</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2020"></a>2020</td><td></td><td></td><td></td><td></td><td class="s">=head2 Caveats</td></tr>
<tr><td class="h"><a name="2021"></a>2021</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2022"></a>2022</td><td></td><td></td><td></td><td></td><td class="s">Some care is required in creating data structures which will be passed to</td></tr>
<tr><td class="h"><a name="2023"></a>2023</td><td></td><td></td><td></td><td></td><td class="s">C&lt;XMLout()&gt;.  Hash keys from the data structure will be encoded as either XML</td></tr>
<tr><td class="h"><a name="2024"></a>2024</td><td></td><td></td><td></td><td></td><td class="s">element names or attribute names.  Therefore, you should use hash key names </td></tr>
<tr><td class="h"><a name="2025"></a>2025</td><td></td><td></td><td></td><td></td><td class="s">which conform to the relatively strict XML naming rules:</td></tr>
<tr><td class="h"><a name="2026"></a>2026</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2027"></a>2027</td><td></td><td></td><td></td><td></td><td class="s">Names in XML must begin with a letter.  The remaining characters may be</td></tr>
<tr><td class="h"><a name="2028"></a>2028</td><td></td><td></td><td></td><td></td><td class="s">letters, digits, hyphens (-), underscores (_) or full stops (.).  It is also</td></tr>
<tr><td class="h"><a name="2029"></a>2029</td><td></td><td></td><td></td><td></td><td class="s">allowable to include one colon (:) in an element name but this should only be</td></tr>
<tr><td class="h"><a name="2030"></a>2030</td><td></td><td></td><td></td><td></td><td class="s">used when working with namespaces (B&lt;XML::Simple&gt; can only usefully work with</td></tr>
<tr><td class="h"><a name="2031"></a>2031</td><td></td><td></td><td></td><td></td><td class="s">namespaces when teamed with a SAX Parser).</td></tr>
<tr><td class="h"><a name="2032"></a>2032</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2033"></a>2033</td><td></td><td></td><td></td><td></td><td class="s">You can use other punctuation characters in hash values (just not in hash</td></tr>
<tr><td class="h"><a name="2034"></a>2034</td><td></td><td></td><td></td><td></td><td class="s">keys) however B&lt;XML::Simple&gt; does not support dumping binary data.</td></tr>
<tr><td class="h"><a name="2035"></a>2035</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2036"></a>2036</td><td></td><td></td><td></td><td></td><td class="s">If you break these rules, the current implementation of C&lt;XMLout()&gt; will </td></tr>
<tr><td class="h"><a name="2037"></a>2037</td><td></td><td></td><td></td><td></td><td class="s">simply emit non-compliant XML which will be rejected if you try to read it</td></tr>
<tr><td class="h"><a name="2038"></a>2038</td><td></td><td></td><td></td><td></td><td class="s">back in.  (A later version of B&lt;XML::Simple&gt; might take a more proactive</td></tr>
<tr><td class="h"><a name="2039"></a>2039</td><td></td><td></td><td></td><td></td><td class="s">approach).</td></tr>
<tr><td class="h"><a name="2040"></a>2040</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2041"></a>2041</td><td></td><td></td><td></td><td></td><td class="s">Note also that although you can nest hashes and arrays to arbitrary levels,</td></tr>
<tr><td class="h"><a name="2042"></a>2042</td><td></td><td></td><td></td><td></td><td class="s">circular data structures are not supported and will cause C&lt;XMLout()&gt; to die.</td></tr>
<tr><td class="h"><a name="2043"></a>2043</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2044"></a>2044</td><td></td><td></td><td></td><td></td><td class="s">If you wish to 'round-trip' arbitrary data structures from Perl to XML and back </td></tr>
<tr><td class="h"><a name="2045"></a>2045</td><td></td><td></td><td></td><td></td><td class="s">to Perl, then you should probably disable array folding (using the KeyAttr</td></tr>
<tr><td class="h"><a name="2046"></a>2046</td><td></td><td></td><td></td><td></td><td class="s">option) both with C&lt;XMLout()&gt; and with C&lt;XMLin()&gt;.  If you still don't get the </td></tr>
<tr><td class="h"><a name="2047"></a>2047</td><td></td><td></td><td></td><td></td><td class="s">expected results, you may prefer to use L&lt;XML::Dumper&gt; which is designed for</td></tr>
<tr><td class="h"><a name="2048"></a>2048</td><td></td><td></td><td></td><td></td><td class="s">exactly that purpose.</td></tr>
<tr><td class="h"><a name="2049"></a>2049</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2050"></a>2050</td><td></td><td></td><td></td><td></td><td class="s">Refer to L&lt;&quot;WHERE TO FROM HERE?&quot;&gt; if C&lt;XMLout()&gt; is too simple for your needs.</td></tr>
<tr><td class="h"><a name="2051"></a>2051</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2052"></a>2052</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2053"></a>2053</td><td></td><td></td><td></td><td></td><td class="s">=head1 OPTIONS</td></tr>
<tr><td class="h"><a name="2054"></a>2054</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2055"></a>2055</td><td></td><td></td><td></td><td></td><td class="s">B&lt;XML::Simple&gt; supports a number of options (in fact as each release of</td></tr>
<tr><td class="h"><a name="2056"></a>2056</td><td></td><td></td><td></td><td></td><td class="s">B&lt;XML::Simple&gt; adds more options, the module's claim to the name 'Simple'</td></tr>
<tr><td class="h"><a name="2057"></a>2057</td><td></td><td></td><td></td><td></td><td class="s">becomes increasingly tenuous).  If you find yourself repeatedly having to</td></tr>
<tr><td class="h"><a name="2058"></a>2058</td><td></td><td></td><td></td><td></td><td class="s">specify the same options, you might like to investigate L&lt;&quot;OPTIONAL OO</td></tr>
<tr><td class="h"><a name="2059"></a>2059</td><td></td><td></td><td></td><td></td><td class="s">INTERFACE&quot;&gt; below.</td></tr>
<tr><td class="h"><a name="2060"></a>2060</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2061"></a>2061</td><td></td><td></td><td></td><td></td><td class="s">If you can't be bothered reading the documentation, refer to</td></tr>
<tr><td class="h"><a name="2062"></a>2062</td><td></td><td></td><td></td><td></td><td class="s">L&lt;&quot;STRICT MODE&quot;&gt; to automatically catch common mistakes.</td></tr>
<tr><td class="h"><a name="2063"></a>2063</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2064"></a>2064</td><td></td><td></td><td></td><td></td><td class="s">Because there are so many options, it's hard for new users to know which ones</td></tr>
<tr><td class="h"><a name="2065"></a>2065</td><td></td><td></td><td></td><td></td><td class="s">are important, so here are the two you really need to know about:</td></tr>
<tr><td class="h"><a name="2066"></a>2066</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2067"></a>2067</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="2068"></a>2068</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2069"></a>2069</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2070"></a>2070</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2071"></a>2071</td><td></td><td></td><td></td><td></td><td class="s">check out C&lt;ForceArray&gt; because you'll almost certainly want to turn it on</td></tr>
<tr><td class="h"><a name="2072"></a>2072</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2073"></a>2073</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2074"></a>2074</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2075"></a>2075</td><td></td><td></td><td></td><td></td><td class="s">make sure you know what the C&lt;KeyAttr&gt; option does and what its default value is</td></tr>
<tr><td class="h"><a name="2076"></a>2076</td><td></td><td></td><td></td><td></td><td class="s">because it may surprise you otherwise (note in particular that 'KeyAttr'</td></tr>
<tr><td class="h"><a name="2077"></a>2077</td><td></td><td></td><td></td><td></td><td class="s">affects both C&lt;XMLin&gt; and C&lt;XMLout&gt;)</td></tr>
<tr><td class="h"><a name="2078"></a>2078</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2079"></a>2079</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="2080"></a>2080</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2081"></a>2081</td><td></td><td></td><td></td><td></td><td class="s">The option name headings below have a trailing 'comment' - a hash followed by</td></tr>
<tr><td class="h"><a name="2082"></a>2082</td><td></td><td></td><td></td><td></td><td class="s">two pieces of metadata:</td></tr>
<tr><td class="h"><a name="2083"></a>2083</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2084"></a>2084</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="2085"></a>2085</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2086"></a>2086</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2087"></a>2087</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2088"></a>2088</td><td></td><td></td><td></td><td></td><td class="s">Options are marked with 'I&lt;in&gt;' if they are recognised by C&lt;XMLin()&gt; and</td></tr>
<tr><td class="h"><a name="2089"></a>2089</td><td></td><td></td><td></td><td></td><td class="s">'I&lt;out&gt;' if they are recognised by C&lt;XMLout()&gt;.</td></tr>
<tr><td class="h"><a name="2090"></a>2090</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2091"></a>2091</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2092"></a>2092</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2093"></a>2093</td><td></td><td></td><td></td><td></td><td class="s">Each option is also flagged to indicate whether it is:</td></tr>
<tr><td class="h"><a name="2094"></a>2094</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2095"></a>2095</td><td></td><td></td><td></td><td></td><td class="s"> 'important'   - don't use the module until you understand this one</td></tr>
<tr><td class="h"><a name="2096"></a>2096</td><td></td><td></td><td></td><td></td><td class="s"> 'handy'       - you can skip this on the first time through</td></tr>
<tr><td class="h"><a name="2097"></a>2097</td><td></td><td></td><td></td><td></td><td class="s"> 'advanced'    - you can skip this on the second time through</td></tr>
<tr><td class="h"><a name="2098"></a>2098</td><td></td><td></td><td></td><td></td><td class="s"> 'SAX only'    - don't worry about this unless you're using SAX (or</td></tr>
<tr><td class="h"><a name="2099"></a>2099</td><td></td><td></td><td></td><td></td><td class="s">                 alternatively if you need this, you also need SAX)</td></tr>
<tr><td class="h"><a name="2100"></a>2100</td><td></td><td></td><td></td><td></td><td class="s"> 'seldom used' - you'll probably never use this unless you were the</td></tr>
<tr><td class="h"><a name="2101"></a>2101</td><td></td><td></td><td></td><td></td><td class="s">                 person that requested the feature</td></tr>
<tr><td class="h"><a name="2102"></a>2102</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2103"></a>2103</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="2104"></a>2104</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2105"></a>2105</td><td></td><td></td><td></td><td></td><td class="s">The options are listed alphabetically:</td></tr>
<tr><td class="h"><a name="2106"></a>2106</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2107"></a>2107</td><td></td><td></td><td></td><td></td><td class="s">Note: option names are no longer case sensitive so you can use the mixed case</td></tr>
<tr><td class="h"><a name="2108"></a>2108</td><td></td><td></td><td></td><td></td><td class="s">versions shown here; all lower case as required by versions 2.03 and earlier;</td></tr>
<tr><td class="h"><a name="2109"></a>2109</td><td></td><td></td><td></td><td></td><td class="s">or you can add underscores between the words (eg: key_attr).</td></tr>
<tr><td class="h"><a name="2110"></a>2110</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2111"></a>2111</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2112"></a>2112</td><td></td><td></td><td></td><td></td><td class="s">=head2 AttrIndent =&gt; 1 I&lt;# out - handy&gt;</td></tr>
<tr><td class="h"><a name="2113"></a>2113</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2114"></a>2114</td><td></td><td></td><td></td><td></td><td class="s">When you are using C&lt;XMLout()&gt;, enable this option to have attributes printed</td></tr>
<tr><td class="h"><a name="2115"></a>2115</td><td></td><td></td><td></td><td></td><td class="s">one-per-line with sensible indentation rather than all on one line.</td></tr>
<tr><td class="h"><a name="2116"></a>2116</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2117"></a>2117</td><td></td><td></td><td></td><td></td><td class="s">=head2 Cache =&gt; [ cache schemes ] I&lt;# in - advanced&gt;</td></tr>
<tr><td class="h"><a name="2118"></a>2118</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2119"></a>2119</td><td></td><td></td><td></td><td></td><td class="s">Because loading the B&lt;XML::Parser&gt; module and parsing an XML file can consume a</td></tr>
<tr><td class="h"><a name="2120"></a>2120</td><td></td><td></td><td></td><td></td><td class="s">significant number of CPU cycles, it is often desirable to cache the output of</td></tr>
<tr><td class="h"><a name="2121"></a>2121</td><td></td><td></td><td></td><td></td><td class="s">C&lt;XMLin()&gt; for later reuse.</td></tr>
<tr><td class="h"><a name="2122"></a>2122</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2123"></a>2123</td><td></td><td></td><td></td><td></td><td class="s">When parsing from a named file, B&lt;XML::Simple&gt; supports a number of caching</td></tr>
<tr><td class="h"><a name="2124"></a>2124</td><td></td><td></td><td></td><td></td><td class="s">schemes.  The 'Cache' option may be used to specify one or more schemes (using</td></tr>
<tr><td class="h"><a name="2125"></a>2125</td><td></td><td></td><td></td><td></td><td class="s">an anonymous array).  Each scheme will be tried in turn in the hope of finding</td></tr>
<tr><td class="h"><a name="2126"></a>2126</td><td></td><td></td><td></td><td></td><td class="s">a cached pre-parsed representation of the XML file.  If no cached copy is</td></tr>
<tr><td class="h"><a name="2127"></a>2127</td><td></td><td></td><td></td><td></td><td class="s">found, the file will be parsed and the first cache scheme in the list will be</td></tr>
<tr><td class="h"><a name="2128"></a>2128</td><td></td><td></td><td></td><td></td><td class="s">used to save a copy of the results.  The following cache schemes have been</td></tr>
<tr><td class="h"><a name="2129"></a>2129</td><td></td><td></td><td></td><td></td><td class="s">implemented:</td></tr>
<tr><td class="h"><a name="2130"></a>2130</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2131"></a>2131</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="2132"></a>2132</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2133"></a>2133</td><td></td><td></td><td></td><td></td><td class="s">=item storable</td></tr>
<tr><td class="h"><a name="2134"></a>2134</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2135"></a>2135</td><td></td><td></td><td></td><td></td><td class="s">Utilises B&lt;Storable.pm&gt; to read/write a cache file with the same name as the</td></tr>
<tr><td class="h"><a name="2136"></a>2136</td><td></td><td></td><td></td><td></td><td class="s">XML file but with the extension .stor</td></tr>
<tr><td class="h"><a name="2137"></a>2137</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2138"></a>2138</td><td></td><td></td><td></td><td></td><td class="s">=item memshare</td></tr>
<tr><td class="h"><a name="2139"></a>2139</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2140"></a>2140</td><td></td><td></td><td></td><td></td><td class="s">When a file is first parsed, a copy of the resulting data structure is retained</td></tr>
<tr><td class="h"><a name="2141"></a>2141</td><td></td><td></td><td></td><td></td><td class="s">in memory in the B&lt;XML::Simple&gt; module's namespace.  Subsequent calls to parse</td></tr>
<tr><td class="h"><a name="2142"></a>2142</td><td></td><td></td><td></td><td></td><td class="s">the same file will return a reference to this structure.  This cached version</td></tr>
<tr><td class="h"><a name="2143"></a>2143</td><td></td><td></td><td></td><td></td><td class="s">will persist only for the life of the Perl interpreter (which in the case of</td></tr>
<tr><td class="h"><a name="2144"></a>2144</td><td></td><td></td><td></td><td></td><td class="s">mod_perl for example, may be some significant time).</td></tr>
<tr><td class="h"><a name="2145"></a>2145</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2146"></a>2146</td><td></td><td></td><td></td><td></td><td class="s">Because each caller receives a reference to the same data structure, a change</td></tr>
<tr><td class="h"><a name="2147"></a>2147</td><td></td><td></td><td></td><td></td><td class="s">made by one caller will be visible to all.  For this reason, the reference</td></tr>
<tr><td class="h"><a name="2148"></a>2148</td><td></td><td></td><td></td><td></td><td class="s">returned should be treated as read-only.</td></tr>
<tr><td class="h"><a name="2149"></a>2149</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2150"></a>2150</td><td></td><td></td><td></td><td></td><td class="s">=item memcopy</td></tr>
<tr><td class="h"><a name="2151"></a>2151</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2152"></a>2152</td><td></td><td></td><td></td><td></td><td class="s">This scheme works identically to 'memshare' (above) except that each caller</td></tr>
<tr><td class="h"><a name="2153"></a>2153</td><td></td><td></td><td></td><td></td><td class="s">receives a reference to a new data structure which is a copy of the cached</td></tr>
<tr><td class="h"><a name="2154"></a>2154</td><td></td><td></td><td></td><td></td><td class="s">version.  Copying the data structure will add a little processing overhead,</td></tr>
<tr><td class="h"><a name="2155"></a>2155</td><td></td><td></td><td></td><td></td><td class="s">therefore this scheme should only be used where the caller intends to modify</td></tr>
<tr><td class="h"><a name="2156"></a>2156</td><td></td><td></td><td></td><td></td><td class="s">the data structure (or wishes to protect itself from others who might).  This</td></tr>
<tr><td class="h"><a name="2157"></a>2157</td><td></td><td></td><td></td><td></td><td class="s">scheme uses B&lt;Storable.pm&gt; to perform the copy.</td></tr>
<tr><td class="h"><a name="2158"></a>2158</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2159"></a>2159</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="2160"></a>2160</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2161"></a>2161</td><td></td><td></td><td></td><td></td><td class="s">Warning! The memory-based caching schemes compare the timestamp on the file to</td></tr>
<tr><td class="h"><a name="2162"></a>2162</td><td></td><td></td><td></td><td></td><td class="s">the time when it was last parsed.  If the file is stored on an NFS filesystem</td></tr>
<tr><td class="h"><a name="2163"></a>2163</td><td></td><td></td><td></td><td></td><td class="s">(or other network share) and the clock on the file server is not exactly</td></tr>
<tr><td class="h"><a name="2164"></a>2164</td><td></td><td></td><td></td><td></td><td class="s">synchronised with the clock where your script is run, updates to the source XML</td></tr>
<tr><td class="h"><a name="2165"></a>2165</td><td></td><td></td><td></td><td></td><td class="s">file may appear to be ignored.</td></tr>
<tr><td class="h"><a name="2166"></a>2166</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2167"></a>2167</td><td></td><td></td><td></td><td></td><td class="s">=head2 ContentKey =&gt; 'keyname' I&lt;# in+out - seldom used&gt;</td></tr>
<tr><td class="h"><a name="2168"></a>2168</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2169"></a>2169</td><td></td><td></td><td></td><td></td><td class="s">When text content is parsed to a hash value, this option let's you specify a</td></tr>
<tr><td class="h"><a name="2170"></a>2170</td><td></td><td></td><td></td><td></td><td class="s">name for the hash key to override the default 'content'.  So for example:</td></tr>
<tr><td class="h"><a name="2171"></a>2171</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2172"></a>2172</td><td></td><td></td><td></td><td></td><td class="s">  XMLin('&lt;opt one=&quot;1&quot;&gt;Text&lt;/opt&gt;', ContentKey =&gt; 'text')</td></tr>
<tr><td class="h"><a name="2173"></a>2173</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2174"></a>2174</td><td></td><td></td><td></td><td></td><td class="s">will parse to:</td></tr>
<tr><td class="h"><a name="2175"></a>2175</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2176"></a>2176</td><td></td><td></td><td></td><td></td><td class="s">  { 'one' =&gt; 1, 'text' =&gt; 'Text' }</td></tr>
<tr><td class="h"><a name="2177"></a>2177</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2178"></a>2178</td><td></td><td></td><td></td><td></td><td class="s">instead of:</td></tr>
<tr><td class="h"><a name="2179"></a>2179</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2180"></a>2180</td><td></td><td></td><td></td><td></td><td class="s">  { 'one' =&gt; 1, 'content' =&gt; 'Text' }</td></tr>
<tr><td class="h"><a name="2181"></a>2181</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2182"></a>2182</td><td></td><td></td><td></td><td></td><td class="s">C&lt;XMLout()&gt; will also honour the value of this option when converting a hashref</td></tr>
<tr><td class="h"><a name="2183"></a>2183</td><td></td><td></td><td></td><td></td><td class="s">to XML.</td></tr>
<tr><td class="h"><a name="2184"></a>2184</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2185"></a>2185</td><td></td><td></td><td></td><td></td><td class="s">You can also prefix your selected key name with a '-' character to have </td></tr>
<tr><td class="h"><a name="2186"></a>2186</td><td></td><td></td><td></td><td></td><td class="s">C&lt;XMLin()&gt; try a little harder to eliminate unnecessary 'content' keys after</td></tr>
<tr><td class="h"><a name="2187"></a>2187</td><td></td><td></td><td></td><td></td><td class="s">array folding.  For example:</td></tr>
<tr><td class="h"><a name="2188"></a>2188</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2189"></a>2189</td><td></td><td></td><td></td><td></td><td class="s">  XMLin(</td></tr>
<tr><td class="h"><a name="2190"></a>2190</td><td></td><td></td><td></td><td></td><td class="s">    '&lt;opt&gt;&lt;item name=&quot;one&quot;&gt;First&lt;/item&gt;&lt;item name=&quot;two&quot;&gt;Second&lt;/item&gt;&lt;/opt&gt;', </td></tr>
<tr><td class="h"><a name="2191"></a>2191</td><td></td><td></td><td></td><td></td><td class="s">    KeyAttr =&gt; {item =&gt; 'name'}, </td></tr>
<tr><td class="h"><a name="2192"></a>2192</td><td></td><td></td><td></td><td></td><td class="s">    ForceArray =&gt; [ 'item' ],</td></tr>
<tr><td class="h"><a name="2193"></a>2193</td><td></td><td></td><td></td><td></td><td class="s">    ContentKey =&gt; '-content'</td></tr>
<tr><td class="h"><a name="2194"></a>2194</td><td></td><td></td><td></td><td></td><td class="s">  )</td></tr>
<tr><td class="h"><a name="2195"></a>2195</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2196"></a>2196</td><td></td><td></td><td></td><td></td><td class="s">will parse to:</td></tr>
<tr><td class="h"><a name="2197"></a>2197</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2198"></a>2198</td><td></td><td></td><td></td><td></td><td class="s">  {</td></tr>
<tr><td class="h"><a name="2199"></a>2199</td><td></td><td></td><td></td><td></td><td class="s">    'item' =&gt; {</td></tr>
<tr><td class="h"><a name="2200"></a>2200</td><td></td><td></td><td></td><td></td><td class="s">      'one' =&gt;  'First'</td></tr>
<tr><td class="h"><a name="2201"></a>2201</td><td></td><td></td><td></td><td></td><td class="s">      'two' =&gt;  'Second'</td></tr>
<tr><td class="h"><a name="2202"></a>2202</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="2203"></a>2203</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="2204"></a>2204</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2205"></a>2205</td><td></td><td></td><td></td><td></td><td class="s">rather than this (without the '-'):</td></tr>
<tr><td class="h"><a name="2206"></a>2206</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2207"></a>2207</td><td></td><td></td><td></td><td></td><td class="s">  {</td></tr>
<tr><td class="h"><a name="2208"></a>2208</td><td></td><td></td><td></td><td></td><td class="s">    'item' =&gt; {</td></tr>
<tr><td class="h"><a name="2209"></a>2209</td><td></td><td></td><td></td><td></td><td class="s">      'one' =&gt; { 'content' =&gt; 'First' }</td></tr>
<tr><td class="h"><a name="2210"></a>2210</td><td></td><td></td><td></td><td></td><td class="s">      'two' =&gt; { 'content' =&gt; 'Second' }</td></tr>
<tr><td class="h"><a name="2211"></a>2211</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="2212"></a>2212</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="2213"></a>2213</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2214"></a>2214</td><td></td><td></td><td></td><td></td><td class="s">=head2 DataHandler =&gt; code_ref I&lt;# in - SAX only&gt;</td></tr>
<tr><td class="h"><a name="2215"></a>2215</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2216"></a>2216</td><td></td><td></td><td></td><td></td><td class="s">When you use an B&lt;XML::Simple&gt; object as a SAX handler, it will return a</td></tr>
<tr><td class="h"><a name="2217"></a>2217</td><td></td><td></td><td></td><td></td><td class="s">'simple tree' data structure in the same format as C&lt;XMLin()&gt; would return.  If</td></tr>
<tr><td class="h"><a name="2218"></a>2218</td><td></td><td></td><td></td><td></td><td class="s">this option is set (to a subroutine reference), then when the tree is built the</td></tr>
<tr><td class="h"><a name="2219"></a>2219</td><td></td><td></td><td></td><td></td><td class="s">subroutine will be called and passed two arguments: a reference to the</td></tr>
<tr><td class="h"><a name="2220"></a>2220</td><td></td><td></td><td></td><td></td><td class="s">B&lt;XML::Simple&gt; object and a reference to the data tree.  The return value from</td></tr>
<tr><td class="h"><a name="2221"></a>2221</td><td></td><td></td><td></td><td></td><td class="s">the subroutine will be returned to the SAX driver.  (See L&lt;&quot;SAX SUPPORT&quot;&gt; for</td></tr>
<tr><td class="h"><a name="2222"></a>2222</td><td></td><td></td><td></td><td></td><td class="s">more details).</td></tr>
<tr><td class="h"><a name="2223"></a>2223</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2224"></a>2224</td><td></td><td></td><td></td><td></td><td class="s">=head2 ForceArray =&gt; 1 I&lt;# in - important&gt;</td></tr>
<tr><td class="h"><a name="2225"></a>2225</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2226"></a>2226</td><td></td><td></td><td></td><td></td><td class="s">This option should be set to '1' to force nested elements to be represented</td></tr>
<tr><td class="h"><a name="2227"></a>2227</td><td></td><td></td><td></td><td></td><td class="s">as arrays even when there is only one.  Eg, with ForceArray enabled, this</td></tr>
<tr><td class="h"><a name="2228"></a>2228</td><td></td><td></td><td></td><td></td><td class="s">XML:</td></tr>
<tr><td class="h"><a name="2229"></a>2229</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2230"></a>2230</td><td></td><td></td><td></td><td></td><td class="s">    &lt;opt&gt;</td></tr>
<tr><td class="h"><a name="2231"></a>2231</td><td></td><td></td><td></td><td></td><td class="s">      &lt;name&gt;value&lt;/name&gt;</td></tr>
<tr><td class="h"><a name="2232"></a>2232</td><td></td><td></td><td></td><td></td><td class="s">    &lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="2233"></a>2233</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2234"></a>2234</td><td></td><td></td><td></td><td></td><td class="s">would parse to this:</td></tr>
<tr><td class="h"><a name="2235"></a>2235</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2236"></a>2236</td><td></td><td></td><td></td><td></td><td class="s">    {</td></tr>
<tr><td class="h"><a name="2237"></a>2237</td><td></td><td></td><td></td><td></td><td class="s">      'name' =&gt; [</td></tr>
<tr><td class="h"><a name="2238"></a>2238</td><td></td><td></td><td></td><td></td><td class="s">                  'value'</td></tr>
<tr><td class="h"><a name="2239"></a>2239</td><td></td><td></td><td></td><td></td><td class="s">                ]</td></tr>
<tr><td class="h"><a name="2240"></a>2240</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="2241"></a>2241</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2242"></a>2242</td><td></td><td></td><td></td><td></td><td class="s">instead of this (the default):</td></tr>
<tr><td class="h"><a name="2243"></a>2243</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2244"></a>2244</td><td></td><td></td><td></td><td></td><td class="s">    {</td></tr>
<tr><td class="h"><a name="2245"></a>2245</td><td></td><td></td><td></td><td></td><td class="s">      'name' =&gt; 'value'</td></tr>
<tr><td class="h"><a name="2246"></a>2246</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="2247"></a>2247</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2248"></a>2248</td><td></td><td></td><td></td><td></td><td class="s">This option is especially useful if the data structure is likely to be written</td></tr>
<tr><td class="h"><a name="2249"></a>2249</td><td></td><td></td><td></td><td></td><td class="s">back out as XML and the default behaviour of rolling single nested elements up</td></tr>
<tr><td class="h"><a name="2250"></a>2250</td><td></td><td></td><td></td><td></td><td class="s">into attributes is not desirable. </td></tr>
<tr><td class="h"><a name="2251"></a>2251</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2252"></a>2252</td><td></td><td></td><td></td><td></td><td class="s">If you are using the array folding feature, you should almost certainly enable</td></tr>
<tr><td class="h"><a name="2253"></a>2253</td><td></td><td></td><td></td><td></td><td class="s">this option.  If you do not, single nested elements will not be parsed to</td></tr>
<tr><td class="h"><a name="2254"></a>2254</td><td></td><td></td><td></td><td></td><td class="s">arrays and therefore will not be candidates for folding to a hash.  (Given that</td></tr>
<tr><td class="h"><a name="2255"></a>2255</td><td></td><td></td><td></td><td></td><td class="s">the default value of 'KeyAttr' enables array folding, the default value of this</td></tr>
<tr><td class="h"><a name="2256"></a>2256</td><td></td><td></td><td></td><td></td><td class="s">option should probably also have been enabled too - sorry).</td></tr>
<tr><td class="h"><a name="2257"></a>2257</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2258"></a>2258</td><td></td><td></td><td></td><td></td><td class="s">=head2 ForceArray =&gt; [ names ] I&lt;# in - important&gt;</td></tr>
<tr><td class="h"><a name="2259"></a>2259</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2260"></a>2260</td><td></td><td></td><td></td><td></td><td class="s">This alternative (and preferred) form of the 'ForceArray' option allows you to</td></tr>
<tr><td class="h"><a name="2261"></a>2261</td><td></td><td></td><td></td><td></td><td class="s">specify a list of element names which should always be forced into an array</td></tr>
<tr><td class="h"><a name="2262"></a>2262</td><td></td><td></td><td></td><td></td><td class="s">representation, rather than the 'all or nothing' approach above.</td></tr>
<tr><td class="h"><a name="2263"></a>2263</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2264"></a>2264</td><td></td><td></td><td></td><td></td><td class="s">It is also possible (since version 2.05) to include compiled regular</td></tr>
<tr><td class="h"><a name="2265"></a>2265</td><td></td><td></td><td></td><td></td><td class="s">expressions in the list - any element names which match the pattern will be</td></tr>
<tr><td class="h"><a name="2266"></a>2266</td><td></td><td></td><td></td><td></td><td class="s">forced to arrays.  If the list contains only a single regex, then it is not</td></tr>
<tr><td class="h"><a name="2267"></a>2267</td><td></td><td></td><td></td><td></td><td class="s">necessary to enclose it in an arrayref.  Eg:</td></tr>
<tr><td class="h"><a name="2268"></a>2268</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2269"></a>2269</td><td></td><td></td><td></td><td></td><td class="s">  ForceArray =&gt; qr/_list$/</td></tr>
<tr><td class="h"><a name="2270"></a>2270</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2271"></a>2271</td><td></td><td></td><td></td><td></td><td class="s">=head2 ForceContent =&gt; 1 I&lt;# in - seldom used&gt;</td></tr>
<tr><td class="h"><a name="2272"></a>2272</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2273"></a>2273</td><td></td><td></td><td></td><td></td><td class="s">When C&lt;XMLin()&gt; parses elements which have text content as well as attributes,</td></tr>
<tr><td class="h"><a name="2274"></a>2274</td><td></td><td></td><td></td><td></td><td class="s">the text content must be represented as a hash value rather than a simple</td></tr>
<tr><td class="h"><a name="2275"></a>2275</td><td></td><td></td><td></td><td></td><td class="s">scalar.  This option allows you to force text content to always parse to</td></tr>
<tr><td class="h"><a name="2276"></a>2276</td><td></td><td></td><td></td><td></td><td class="s">a hash value even when there are no attributes.  So for example:</td></tr>
<tr><td class="h"><a name="2277"></a>2277</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2278"></a>2278</td><td></td><td></td><td></td><td></td><td class="s">  XMLin('&lt;opt&gt;&lt;x&gt;text1&lt;/x&gt;&lt;y a=&quot;2&quot;&gt;text2&lt;/y&gt;&lt;/opt&gt;', ForceContent =&gt; 1)</td></tr>
<tr><td class="h"><a name="2279"></a>2279</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2280"></a>2280</td><td></td><td></td><td></td><td></td><td class="s">will parse to:</td></tr>
<tr><td class="h"><a name="2281"></a>2281</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2282"></a>2282</td><td></td><td></td><td></td><td></td><td class="s">  {</td></tr>
<tr><td class="h"><a name="2283"></a>2283</td><td></td><td></td><td></td><td></td><td class="s">    'x' =&gt; {           'content' =&gt; 'text1' },</td></tr>
<tr><td class="h"><a name="2284"></a>2284</td><td></td><td></td><td></td><td></td><td class="s">    'y' =&gt; { 'a' =&gt; 2, 'content' =&gt; 'text2' }</td></tr>
<tr><td class="h"><a name="2285"></a>2285</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="2286"></a>2286</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2287"></a>2287</td><td></td><td></td><td></td><td></td><td class="s">instead of:</td></tr>
<tr><td class="h"><a name="2288"></a>2288</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2289"></a>2289</td><td></td><td></td><td></td><td></td><td class="s">  {</td></tr>
<tr><td class="h"><a name="2290"></a>2290</td><td></td><td></td><td></td><td></td><td class="s">    'x' =&gt; 'text1',</td></tr>
<tr><td class="h"><a name="2291"></a>2291</td><td></td><td></td><td></td><td></td><td class="s">    'y' =&gt; { 'a' =&gt; 2, 'content' =&gt; 'text2' }</td></tr>
<tr><td class="h"><a name="2292"></a>2292</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="2293"></a>2293</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2294"></a>2294</td><td></td><td></td><td></td><td></td><td class="s">=head2 GroupTags =&gt; { grouping tag =&gt; grouped tag } I&lt;# in+out - handy&gt;</td></tr>
<tr><td class="h"><a name="2295"></a>2295</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2296"></a>2296</td><td></td><td></td><td></td><td></td><td class="s">You can use this option to eliminate extra levels of indirection in your Perl</td></tr>
<tr><td class="h"><a name="2297"></a>2297</td><td></td><td></td><td></td><td></td><td class="s">data structure.  For example this XML:</td></tr>
<tr><td class="h"><a name="2298"></a>2298</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2299"></a>2299</td><td></td><td></td><td></td><td></td><td class="s">  &lt;opt&gt;</td></tr>
<tr><td class="h"><a name="2300"></a>2300</td><td></td><td></td><td></td><td></td><td class="s">   &lt;searchpath&gt;</td></tr>
<tr><td class="h"><a name="2301"></a>2301</td><td></td><td></td><td></td><td></td><td class="s">     &lt;dir&gt;/usr/bin&lt;/dir&gt;</td></tr>
<tr><td class="h"><a name="2302"></a>2302</td><td></td><td></td><td></td><td></td><td class="s">     &lt;dir&gt;/usr/local/bin&lt;/dir&gt;</td></tr>
<tr><td class="h"><a name="2303"></a>2303</td><td></td><td></td><td></td><td></td><td class="s">     &lt;dir&gt;/usr/X11/bin&lt;/dir&gt;</td></tr>
<tr><td class="h"><a name="2304"></a>2304</td><td></td><td></td><td></td><td></td><td class="s">   &lt;/searchpath&gt;</td></tr>
<tr><td class="h"><a name="2305"></a>2305</td><td></td><td></td><td></td><td></td><td class="s"> &lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="2306"></a>2306</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2307"></a>2307</td><td></td><td></td><td></td><td></td><td class="s">Would normally be read into a structure like this:</td></tr>
<tr><td class="h"><a name="2308"></a>2308</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2309"></a>2309</td><td></td><td></td><td></td><td></td><td class="s">  {</td></tr>
<tr><td class="h"><a name="2310"></a>2310</td><td></td><td></td><td></td><td></td><td class="s">    searchpath =&gt; {</td></tr>
<tr><td class="h"><a name="2311"></a>2311</td><td></td><td></td><td></td><td></td><td class="s">                    dir =&gt; [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]</td></tr>
<tr><td class="h"><a name="2312"></a>2312</td><td></td><td></td><td></td><td></td><td class="s">                  }</td></tr>
<tr><td class="h"><a name="2313"></a>2313</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="2314"></a>2314</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2315"></a>2315</td><td></td><td></td><td></td><td></td><td class="s">But when read in with the appropriate value for 'GroupTags':</td></tr>
<tr><td class="h"><a name="2316"></a>2316</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2317"></a>2317</td><td></td><td></td><td></td><td></td><td class="s">  my $opt = XMLin($xml, GroupTags =&gt; { searchpath =&gt; 'dir' });</td></tr>
<tr><td class="h"><a name="2318"></a>2318</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2319"></a>2319</td><td></td><td></td><td></td><td></td><td class="s">It will return this simpler structure:</td></tr>
<tr><td class="h"><a name="2320"></a>2320</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2321"></a>2321</td><td></td><td></td><td></td><td></td><td class="s">  {</td></tr>
<tr><td class="h"><a name="2322"></a>2322</td><td></td><td></td><td></td><td></td><td class="s">    searchpath =&gt; [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]</td></tr>
<tr><td class="h"><a name="2323"></a>2323</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="2324"></a>2324</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2325"></a>2325</td><td></td><td></td><td></td><td></td><td class="s">The grouping element (C&lt;&lt; &lt;searchpath&gt; &gt;&gt; in the example) must not contain any</td></tr>
<tr><td class="h"><a name="2326"></a>2326</td><td></td><td></td><td></td><td></td><td class="s">attributes or elements other than the grouped element.</td></tr>
<tr><td class="h"><a name="2327"></a>2327</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2328"></a>2328</td><td></td><td></td><td></td><td></td><td class="s">You can specify multiple 'grouping element' to 'grouped element' mappings in</td></tr>
<tr><td class="h"><a name="2329"></a>2329</td><td></td><td></td><td></td><td></td><td class="s">the same hashref.  If this option is combined with C&lt;KeyAttr&gt;, the array</td></tr>
<tr><td class="h"><a name="2330"></a>2330</td><td></td><td></td><td></td><td></td><td class="s">folding will occur first and then the grouped element names will be eliminated.</td></tr>
<tr><td class="h"><a name="2331"></a>2331</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2332"></a>2332</td><td></td><td></td><td></td><td></td><td class="s">C&lt;XMLout&gt; will also use the grouptag mappings to re-introduce the tags around</td></tr>
<tr><td class="h"><a name="2333"></a>2333</td><td></td><td></td><td></td><td></td><td class="s">the grouped elements.  Beware though that this will occur in all places that</td></tr>
<tr><td class="h"><a name="2334"></a>2334</td><td></td><td></td><td></td><td></td><td class="s">the 'grouping tag' name occurs - you probably don't want to use the same name</td></tr>
<tr><td class="h"><a name="2335"></a>2335</td><td></td><td></td><td></td><td></td><td class="s">for elements as well as attributes.</td></tr>
<tr><td class="h"><a name="2336"></a>2336</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2337"></a>2337</td><td></td><td></td><td></td><td></td><td class="s">=head2 Handler =&gt; object_ref I&lt;# out - SAX only&gt;</td></tr>
<tr><td class="h"><a name="2338"></a>2338</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2339"></a>2339</td><td></td><td></td><td></td><td></td><td class="s">Use the 'Handler' option to have C&lt;XMLout()&gt; generate SAX events rather than </td></tr>
<tr><td class="h"><a name="2340"></a>2340</td><td></td><td></td><td></td><td></td><td class="s">returning a string of XML.  For more details see L&lt;&quot;SAX SUPPORT&quot;&gt; below.</td></tr>
<tr><td class="h"><a name="2341"></a>2341</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2342"></a>2342</td><td></td><td></td><td></td><td></td><td class="s">Note: the current implementation of this option generates a string of XML</td></tr>
<tr><td class="h"><a name="2343"></a>2343</td><td></td><td></td><td></td><td></td><td class="s">and uses a SAX parser to translate it into SAX events.  The normal encoding</td></tr>
<tr><td class="h"><a name="2344"></a>2344</td><td></td><td></td><td></td><td></td><td class="s">rules apply here - your data must be UTF8 encoded unless you specify an </td></tr>
<tr><td class="h"><a name="2345"></a>2345</td><td></td><td></td><td></td><td></td><td class="s">alternative encoding via the 'XMLDecl' option; and by the time the data reaches</td></tr>
<tr><td class="h"><a name="2346"></a>2346</td><td></td><td></td><td></td><td></td><td class="s">the handler object, it will be in UTF8 form regardless of the encoding you</td></tr>
<tr><td class="h"><a name="2347"></a>2347</td><td></td><td></td><td></td><td></td><td class="s">supply.  A future implementation of this option may generate the events </td></tr>
<tr><td class="h"><a name="2348"></a>2348</td><td></td><td></td><td></td><td></td><td class="s">directly.</td></tr>
<tr><td class="h"><a name="2349"></a>2349</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2350"></a>2350</td><td></td><td></td><td></td><td></td><td class="s">=head2 KeepRoot =&gt; 1 I&lt;# in+out - handy&gt;</td></tr>
<tr><td class="h"><a name="2351"></a>2351</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2352"></a>2352</td><td></td><td></td><td></td><td></td><td class="s">In its attempt to return a data structure free of superfluous detail and</td></tr>
<tr><td class="h"><a name="2353"></a>2353</td><td></td><td></td><td></td><td></td><td class="s">unnecessary levels of indirection, C&lt;XMLin()&gt; normally discards the root</td></tr>
<tr><td class="h"><a name="2354"></a>2354</td><td></td><td></td><td></td><td></td><td class="s">element name.  Setting the 'KeepRoot' option to '1' will cause the root element</td></tr>
<tr><td class="h"><a name="2355"></a>2355</td><td></td><td></td><td></td><td></td><td class="s">name to be retained.  So after executing this code:</td></tr>
<tr><td class="h"><a name="2356"></a>2356</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2357"></a>2357</td><td></td><td></td><td></td><td></td><td class="s">  $config = XMLin('&lt;config tempdir=&quot;/tmp&quot; /&gt;', KeepRoot =&gt; 1)</td></tr>
<tr><td class="h"><a name="2358"></a>2358</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2359"></a>2359</td><td></td><td></td><td></td><td></td><td class="s">You'll be able to reference the tempdir as</td></tr>
<tr><td class="h"><a name="2360"></a>2360</td><td></td><td></td><td></td><td></td><td class="s">C&lt;$config-E&lt;gt&gt;{config}-E&lt;gt&gt;{tempdir}&gt; instead of the default</td></tr>
<tr><td class="h"><a name="2361"></a>2361</td><td></td><td></td><td></td><td></td><td class="s">C&lt;$config-E&lt;gt&gt;{tempdir}&gt;.</td></tr>
<tr><td class="h"><a name="2362"></a>2362</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2363"></a>2363</td><td></td><td></td><td></td><td></td><td class="s">Similarly, setting the 'KeepRoot' option to '1' will tell C&lt;XMLout()&gt; that the</td></tr>
<tr><td class="h"><a name="2364"></a>2364</td><td></td><td></td><td></td><td></td><td class="s">data structure already contains a root element name and it is not necessary to</td></tr>
<tr><td class="h"><a name="2365"></a>2365</td><td></td><td></td><td></td><td></td><td class="s">add another.</td></tr>
<tr><td class="h"><a name="2366"></a>2366</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2367"></a>2367</td><td></td><td></td><td></td><td></td><td class="s">=head2 KeyAttr =&gt; [ list ] I&lt;# in+out - important&gt;</td></tr>
<tr><td class="h"><a name="2368"></a>2368</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2369"></a>2369</td><td></td><td></td><td></td><td></td><td class="s">This option controls the 'array folding' feature which translates nested</td></tr>
<tr><td class="h"><a name="2370"></a>2370</td><td></td><td></td><td></td><td></td><td class="s">elements from an array to a hash.  It also controls the 'unfolding' of hashes</td></tr>
<tr><td class="h"><a name="2371"></a>2371</td><td></td><td></td><td></td><td></td><td class="s">to arrays.</td></tr>
<tr><td class="h"><a name="2372"></a>2372</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2373"></a>2373</td><td></td><td></td><td></td><td></td><td class="s">For example, this XML:</td></tr>
<tr><td class="h"><a name="2374"></a>2374</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2375"></a>2375</td><td></td><td></td><td></td><td></td><td class="s">    &lt;opt&gt;</td></tr>
<tr><td class="h"><a name="2376"></a>2376</td><td></td><td></td><td></td><td></td><td class="s">      &lt;user login=&quot;grep&quot; fullname=&quot;Gary R Epstein&quot; /&gt;</td></tr>
<tr><td class="h"><a name="2377"></a>2377</td><td></td><td></td><td></td><td></td><td class="s">      &lt;user login=&quot;stty&quot; fullname=&quot;Simon T Tyson&quot; /&gt;</td></tr>
<tr><td class="h"><a name="2378"></a>2378</td><td></td><td></td><td></td><td></td><td class="s">    &lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="2379"></a>2379</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2380"></a>2380</td><td></td><td></td><td></td><td></td><td class="s">would, by default, parse to this:</td></tr>
<tr><td class="h"><a name="2381"></a>2381</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2382"></a>2382</td><td></td><td></td><td></td><td></td><td class="s">    {</td></tr>
<tr><td class="h"><a name="2383"></a>2383</td><td></td><td></td><td></td><td></td><td class="s">      'user' =&gt; [</td></tr>
<tr><td class="h"><a name="2384"></a>2384</td><td></td><td></td><td></td><td></td><td class="s">                  {</td></tr>
<tr><td class="h"><a name="2385"></a>2385</td><td></td><td></td><td></td><td></td><td class="s">                    'login' =&gt; 'grep',</td></tr>
<tr><td class="h"><a name="2386"></a>2386</td><td></td><td></td><td></td><td></td><td class="s">                    'fullname' =&gt; 'Gary R Epstein'</td></tr>
<tr><td class="h"><a name="2387"></a>2387</td><td></td><td></td><td></td><td></td><td class="s">                  },</td></tr>
<tr><td class="h"><a name="2388"></a>2388</td><td></td><td></td><td></td><td></td><td class="s">                  {</td></tr>
<tr><td class="h"><a name="2389"></a>2389</td><td></td><td></td><td></td><td></td><td class="s">                    'login' =&gt; 'stty',</td></tr>
<tr><td class="h"><a name="2390"></a>2390</td><td></td><td></td><td></td><td></td><td class="s">                    'fullname' =&gt; 'Simon T Tyson'</td></tr>
<tr><td class="h"><a name="2391"></a>2391</td><td></td><td></td><td></td><td></td><td class="s">                  }</td></tr>
<tr><td class="h"><a name="2392"></a>2392</td><td></td><td></td><td></td><td></td><td class="s">                ]</td></tr>
<tr><td class="h"><a name="2393"></a>2393</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="2394"></a>2394</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2395"></a>2395</td><td></td><td></td><td></td><td></td><td class="s">If the option 'KeyAttr =&gt; &quot;login&quot;' were used to specify that the 'login'</td></tr>
<tr><td class="h"><a name="2396"></a>2396</td><td></td><td></td><td></td><td></td><td class="s">attribute is a key, the same XML would parse to:</td></tr>
<tr><td class="h"><a name="2397"></a>2397</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2398"></a>2398</td><td></td><td></td><td></td><td></td><td class="s">    {</td></tr>
<tr><td class="h"><a name="2399"></a>2399</td><td></td><td></td><td></td><td></td><td class="s">      'user' =&gt; {</td></tr>
<tr><td class="h"><a name="2400"></a>2400</td><td></td><td></td><td></td><td></td><td class="s">                  'stty' =&gt; {</td></tr>
<tr><td class="h"><a name="2401"></a>2401</td><td></td><td></td><td></td><td></td><td class="s">                              'fullname' =&gt; 'Simon T Tyson'</td></tr>
<tr><td class="h"><a name="2402"></a>2402</td><td></td><td></td><td></td><td></td><td class="s">                            },</td></tr>
<tr><td class="h"><a name="2403"></a>2403</td><td></td><td></td><td></td><td></td><td class="s">                  'grep' =&gt; {</td></tr>
<tr><td class="h"><a name="2404"></a>2404</td><td></td><td></td><td></td><td></td><td class="s">                              'fullname' =&gt; 'Gary R Epstein'</td></tr>
<tr><td class="h"><a name="2405"></a>2405</td><td></td><td></td><td></td><td></td><td class="s">                            }</td></tr>
<tr><td class="h"><a name="2406"></a>2406</td><td></td><td></td><td></td><td></td><td class="s">                }</td></tr>
<tr><td class="h"><a name="2407"></a>2407</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="2408"></a>2408</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2409"></a>2409</td><td></td><td></td><td></td><td></td><td class="s">The key attribute names should be supplied in an arrayref if there is more</td></tr>
<tr><td class="h"><a name="2410"></a>2410</td><td></td><td></td><td></td><td></td><td class="s">than one.  C&lt;XMLin()&gt; will attempt to match attribute names in the order</td></tr>
<tr><td class="h"><a name="2411"></a>2411</td><td></td><td></td><td></td><td></td><td class="s">supplied.  C&lt;XMLout()&gt; will use the first attribute name supplied when</td></tr>
<tr><td class="h"><a name="2412"></a>2412</td><td></td><td></td><td></td><td></td><td class="s">'unfolding' a hash into an array.</td></tr>
<tr><td class="h"><a name="2413"></a>2413</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2414"></a>2414</td><td></td><td></td><td></td><td></td><td class="s">Note 1: The default value for 'KeyAttr' is ['name', 'key', 'id'].  If you do</td></tr>
<tr><td class="h"><a name="2415"></a>2415</td><td></td><td></td><td></td><td></td><td class="s">not want folding on input or unfolding on output you must setting this option</td></tr>
<tr><td class="h"><a name="2416"></a>2416</td><td></td><td></td><td></td><td></td><td class="s">to an empty list to disable the feature.</td></tr>
<tr><td class="h"><a name="2417"></a>2417</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2418"></a>2418</td><td></td><td></td><td></td><td></td><td class="s">Note 2: If you wish to use this option, you should also enable the</td></tr>
<tr><td class="h"><a name="2419"></a>2419</td><td></td><td></td><td></td><td></td><td class="s">C&lt;ForceArray&gt; option.  Without 'ForceArray', a single nested element will be</td></tr>
<tr><td class="h"><a name="2420"></a>2420</td><td></td><td></td><td></td><td></td><td class="s">rolled up into a scalar rather than an array and therefore will not be folded</td></tr>
<tr><td class="h"><a name="2421"></a>2421</td><td></td><td></td><td></td><td></td><td class="s">(since only arrays get folded).</td></tr>
<tr><td class="h"><a name="2422"></a>2422</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2423"></a>2423</td><td></td><td></td><td></td><td></td><td class="s">=head2 KeyAttr =&gt; { list } I&lt;# in+out - important&gt;</td></tr>
<tr><td class="h"><a name="2424"></a>2424</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2425"></a>2425</td><td></td><td></td><td></td><td></td><td class="s">This alternative (and preferred) method of specifiying the key attributes</td></tr>
<tr><td class="h"><a name="2426"></a>2426</td><td></td><td></td><td></td><td></td><td class="s">allows more fine grained control over which elements are folded and on which</td></tr>
<tr><td class="h"><a name="2427"></a>2427</td><td></td><td></td><td></td><td></td><td class="s">attributes.  For example the option 'KeyAttr =&gt; { package =&gt; 'id' } will cause</td></tr>
<tr><td class="h"><a name="2428"></a>2428</td><td></td><td></td><td></td><td></td><td class="s">any package elements to be folded on the 'id' attribute.  No other elements</td></tr>
<tr><td class="h"><a name="2429"></a>2429</td><td></td><td></td><td></td><td></td><td class="s">which have an 'id' attribute will be folded at all. </td></tr>
<tr><td class="h"><a name="2430"></a>2430</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2431"></a>2431</td><td></td><td></td><td></td><td></td><td class="s">Note: C&lt;XMLin()&gt; will generate a warning (or a fatal error in L&lt;&quot;STRICT MODE&quot;&gt;)</td></tr>
<tr><td class="h"><a name="2432"></a>2432</td><td></td><td></td><td></td><td></td><td class="s">if this syntax is used and an element which does not have the specified key</td></tr>
<tr><td class="h"><a name="2433"></a>2433</td><td></td><td></td><td></td><td></td><td class="s">attribute is encountered (eg: a 'package' element without an 'id' attribute, to</td></tr>
<tr><td class="h"><a name="2434"></a>2434</td><td></td><td></td><td></td><td></td><td class="s">use the example above).  Warnings will only be generated if B&lt;-w&gt; is in force.</td></tr>
<tr><td class="h"><a name="2435"></a>2435</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2436"></a>2436</td><td></td><td></td><td></td><td></td><td class="s">Two further variations are made possible by prefixing a '+' or a '-' character</td></tr>
<tr><td class="h"><a name="2437"></a>2437</td><td></td><td></td><td></td><td></td><td class="s">to the attribute name:</td></tr>
<tr><td class="h"><a name="2438"></a>2438</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2439"></a>2439</td><td></td><td></td><td></td><td></td><td class="s">The option 'KeyAttr =&gt; { user =&gt; &quot;+login&quot; }' will cause this XML:</td></tr>
<tr><td class="h"><a name="2440"></a>2440</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2441"></a>2441</td><td></td><td></td><td></td><td></td><td class="s">    &lt;opt&gt;</td></tr>
<tr><td class="h"><a name="2442"></a>2442</td><td></td><td></td><td></td><td></td><td class="s">      &lt;user login=&quot;grep&quot; fullname=&quot;Gary R Epstein&quot; /&gt;</td></tr>
<tr><td class="h"><a name="2443"></a>2443</td><td></td><td></td><td></td><td></td><td class="s">      &lt;user login=&quot;stty&quot; fullname=&quot;Simon T Tyson&quot; /&gt;</td></tr>
<tr><td class="h"><a name="2444"></a>2444</td><td></td><td></td><td></td><td></td><td class="s">    &lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="2445"></a>2445</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2446"></a>2446</td><td></td><td></td><td></td><td></td><td class="s">to parse to this data structure:</td></tr>
<tr><td class="h"><a name="2447"></a>2447</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2448"></a>2448</td><td></td><td></td><td></td><td></td><td class="s">    {</td></tr>
<tr><td class="h"><a name="2449"></a>2449</td><td></td><td></td><td></td><td></td><td class="s">      'user' =&gt; {</td></tr>
<tr><td class="h"><a name="2450"></a>2450</td><td></td><td></td><td></td><td></td><td class="s">                  'stty' =&gt; {</td></tr>
<tr><td class="h"><a name="2451"></a>2451</td><td></td><td></td><td></td><td></td><td class="s">                              'fullname' =&gt; 'Simon T Tyson',</td></tr>
<tr><td class="h"><a name="2452"></a>2452</td><td></td><td></td><td></td><td></td><td class="s">                              'login'    =&gt; 'stty'</td></tr>
<tr><td class="h"><a name="2453"></a>2453</td><td></td><td></td><td></td><td></td><td class="s">                            },</td></tr>
<tr><td class="h"><a name="2454"></a>2454</td><td></td><td></td><td></td><td></td><td class="s">                  'grep' =&gt; {</td></tr>
<tr><td class="h"><a name="2455"></a>2455</td><td></td><td></td><td></td><td></td><td class="s">                              'fullname' =&gt; 'Gary R Epstein',</td></tr>
<tr><td class="h"><a name="2456"></a>2456</td><td></td><td></td><td></td><td></td><td class="s">                              'login'    =&gt; 'grep'</td></tr>
<tr><td class="h"><a name="2457"></a>2457</td><td></td><td></td><td></td><td></td><td class="s">                            }</td></tr>
<tr><td class="h"><a name="2458"></a>2458</td><td></td><td></td><td></td><td></td><td class="s">                }</td></tr>
<tr><td class="h"><a name="2459"></a>2459</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="2460"></a>2460</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2461"></a>2461</td><td></td><td></td><td></td><td></td><td class="s">The '+' indicates that the value of the key attribute should be copied rather</td></tr>
<tr><td class="h"><a name="2462"></a>2462</td><td></td><td></td><td></td><td></td><td class="s">than moved to the folded hash key.</td></tr>
<tr><td class="h"><a name="2463"></a>2463</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2464"></a>2464</td><td></td><td></td><td></td><td></td><td class="s">A '-' prefix would produce this result:</td></tr>
<tr><td class="h"><a name="2465"></a>2465</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2466"></a>2466</td><td></td><td></td><td></td><td></td><td class="s">    {</td></tr>
<tr><td class="h"><a name="2467"></a>2467</td><td></td><td></td><td></td><td></td><td class="s">      'user' =&gt; {</td></tr>
<tr><td class="h"><a name="2468"></a>2468</td><td></td><td></td><td></td><td></td><td class="s">                  'stty' =&gt; {</td></tr>
<tr><td class="h"><a name="2469"></a>2469</td><td></td><td></td><td></td><td></td><td class="s">                              'fullname' =&gt; 'Simon T Tyson',</td></tr>
<tr><td class="h"><a name="2470"></a>2470</td><td></td><td></td><td></td><td></td><td class="s">                              '-login'    =&gt; 'stty'</td></tr>
<tr><td class="h"><a name="2471"></a>2471</td><td></td><td></td><td></td><td></td><td class="s">                            },</td></tr>
<tr><td class="h"><a name="2472"></a>2472</td><td></td><td></td><td></td><td></td><td class="s">                  'grep' =&gt; {</td></tr>
<tr><td class="h"><a name="2473"></a>2473</td><td></td><td></td><td></td><td></td><td class="s">                              'fullname' =&gt; 'Gary R Epstein',</td></tr>
<tr><td class="h"><a name="2474"></a>2474</td><td></td><td></td><td></td><td></td><td class="s">                              '-login'    =&gt; 'grep'</td></tr>
<tr><td class="h"><a name="2475"></a>2475</td><td></td><td></td><td></td><td></td><td class="s">                            }</td></tr>
<tr><td class="h"><a name="2476"></a>2476</td><td></td><td></td><td></td><td></td><td class="s">                }</td></tr>
<tr><td class="h"><a name="2477"></a>2477</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="2478"></a>2478</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2479"></a>2479</td><td></td><td></td><td></td><td></td><td class="s">As described earlier, C&lt;XMLout&gt; will ignore hash keys starting with a '-'.</td></tr>
<tr><td class="h"><a name="2480"></a>2480</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2481"></a>2481</td><td></td><td></td><td></td><td></td><td class="s">=head2 NoAttr =&gt; 1 I&lt;# in+out - handy&gt;</td></tr>
<tr><td class="h"><a name="2482"></a>2482</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2483"></a>2483</td><td></td><td></td><td></td><td></td><td class="s">When used with C&lt;XMLout()&gt;, the generated XML will contain no attributes.</td></tr>
<tr><td class="h"><a name="2484"></a>2484</td><td></td><td></td><td></td><td></td><td class="s">All hash key/values will be represented as nested elements instead.</td></tr>
<tr><td class="h"><a name="2485"></a>2485</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2486"></a>2486</td><td></td><td></td><td></td><td></td><td class="s">When used with C&lt;XMLin()&gt;, any attributes in the XML will be ignored.</td></tr>
<tr><td class="h"><a name="2487"></a>2487</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2488"></a>2488</td><td></td><td></td><td></td><td></td><td class="s">=head2 NoEscape =&gt; 1 I&lt;# out - seldom used&gt;</td></tr>
<tr><td class="h"><a name="2489"></a>2489</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2490"></a>2490</td><td></td><td></td><td></td><td></td><td class="s">By default, C&lt;XMLout()&gt; will translate the characters 'E&lt;lt&gt;', 'E&lt;gt&gt;', '&amp;' and</td></tr>
<tr><td class="h"><a name="2491"></a>2491</td><td></td><td></td><td></td><td></td><td class="s">'&quot;' to '&amp;lt;', '&amp;gt;', '&amp;amp;' and '&amp;quot' respectively.  Use this option to</td></tr>
<tr><td class="h"><a name="2492"></a>2492</td><td></td><td></td><td></td><td></td><td class="s">suppress escaping (presumably because you've already escaped the data in some</td></tr>
<tr><td class="h"><a name="2493"></a>2493</td><td></td><td></td><td></td><td></td><td class="s">more sophisticated manner).</td></tr>
<tr><td class="h"><a name="2494"></a>2494</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2495"></a>2495</td><td></td><td></td><td></td><td></td><td class="s">=head2 NoIndent =&gt; 1 I&lt;# out - seldom used&gt;</td></tr>
<tr><td class="h"><a name="2496"></a>2496</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2497"></a>2497</td><td></td><td></td><td></td><td></td><td class="s">Set this option to 1 to disable C&lt;XMLout()&gt;'s default 'pretty printing' mode.</td></tr>
<tr><td class="h"><a name="2498"></a>2498</td><td></td><td></td><td></td><td></td><td class="s">With this option enabled, the XML output will all be on one line (unless there</td></tr>
<tr><td class="h"><a name="2499"></a>2499</td><td></td><td></td><td></td><td></td><td class="s">are newlines in the data) - this may be easier for downstream processing.</td></tr>
<tr><td class="h"><a name="2500"></a>2500</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2501"></a>2501</td><td></td><td></td><td></td><td></td><td class="s">=head2 NoSort =&gt; 1 I&lt;# out - seldom used&gt;</td></tr>
<tr><td class="h"><a name="2502"></a>2502</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2503"></a>2503</td><td></td><td></td><td></td><td></td><td class="s">Newer versions of XML::Simple sort elements and attributes alphabetically (*),</td></tr>
<tr><td class="h"><a name="2504"></a>2504</td><td></td><td></td><td></td><td></td><td class="s">by default.  Enable this option to suppress the sorting - possibly for</td></tr>
<tr><td class="h"><a name="2505"></a>2505</td><td></td><td></td><td></td><td></td><td class="s">backwards compatibility.</td></tr>
<tr><td class="h"><a name="2506"></a>2506</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2507"></a>2507</td><td></td><td></td><td></td><td></td><td class="s">* Actually, sorting is alphabetical but 'key' attribute or element names (as in</td></tr>
<tr><td class="h"><a name="2508"></a>2508</td><td></td><td></td><td></td><td></td><td class="s">'KeyAttr') sort first.  Also, when a hash of hashes is 'unfolded', the elements</td></tr>
<tr><td class="h"><a name="2509"></a>2509</td><td></td><td></td><td></td><td></td><td class="s">are sorted alphabetically by the value of the key field.</td></tr>
<tr><td class="h"><a name="2510"></a>2510</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2511"></a>2511</td><td></td><td></td><td></td><td></td><td class="s">=head2 NormaliseSpace =&gt; 0 | 1 | 2 I&lt;# in - handy&gt;</td></tr>
<tr><td class="h"><a name="2512"></a>2512</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2513"></a>2513</td><td></td><td></td><td></td><td></td><td class="s">This option controls how whitespace in text content is handled.  Recognised</td></tr>
<tr><td class="h"><a name="2514"></a>2514</td><td></td><td></td><td></td><td></td><td class="s">values for the option are:</td></tr>
<tr><td class="h"><a name="2515"></a>2515</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2516"></a>2516</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="2517"></a>2517</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2518"></a>2518</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2519"></a>2519</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2520"></a>2520</td><td></td><td></td><td></td><td></td><td class="s">0 = (default) whitespace is passed through unaltered (except of course for the</td></tr>
<tr><td class="h"><a name="2521"></a>2521</td><td></td><td></td><td></td><td></td><td class="s">normalisation of whitespace in attribute values which is mandated by the XML</td></tr>
<tr><td class="h"><a name="2522"></a>2522</td><td></td><td></td><td></td><td></td><td class="s">recommendation)</td></tr>
<tr><td class="h"><a name="2523"></a>2523</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2524"></a>2524</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2525"></a>2525</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2526"></a>2526</td><td></td><td></td><td></td><td></td><td class="s">1 = whitespace is normalised in any value used as a hash key (normalising means</td></tr>
<tr><td class="h"><a name="2527"></a>2527</td><td></td><td></td><td></td><td></td><td class="s">removing leading and trailing whitespace and collapsing sequences of whitespace</td></tr>
<tr><td class="h"><a name="2528"></a>2528</td><td></td><td></td><td></td><td></td><td class="s">characters to a single space)</td></tr>
<tr><td class="h"><a name="2529"></a>2529</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2530"></a>2530</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2531"></a>2531</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2532"></a>2532</td><td></td><td></td><td></td><td></td><td class="s">2 = whitespace is normalised in all text content</td></tr>
<tr><td class="h"><a name="2533"></a>2533</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2534"></a>2534</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="2535"></a>2535</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2536"></a>2536</td><td></td><td></td><td></td><td></td><td class="s">Note: you can spell this option with a 'z' if that is more natural for you.</td></tr>
<tr><td class="h"><a name="2537"></a>2537</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2538"></a>2538</td><td></td><td></td><td></td><td></td><td class="s">=head2 NSExpand =&gt; 1 I&lt;# in+out handy - SAX only&gt;</td></tr>
<tr><td class="h"><a name="2539"></a>2539</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2540"></a>2540</td><td></td><td></td><td></td><td></td><td class="s">This option controls namespace expansion - the translation of element and</td></tr>
<tr><td class="h"><a name="2541"></a>2541</td><td></td><td></td><td></td><td></td><td class="s">attribute names of the form 'prefix:name' to '{uri}name'.  For example the</td></tr>
<tr><td class="h"><a name="2542"></a>2542</td><td></td><td></td><td></td><td></td><td class="s">element name 'xsl:template' might be expanded to:</td></tr>
<tr><td class="h"><a name="2543"></a>2543</td><td></td><td></td><td></td><td></td><td class="s">'{http://www.w3.org/1999/XSL/Transform}template'.</td></tr>
<tr><td class="h"><a name="2544"></a>2544</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2545"></a>2545</td><td></td><td></td><td></td><td></td><td class="s">By default, C&lt;XMLin()&gt; will return element names and attribute names exactly as</td></tr>
<tr><td class="h"><a name="2546"></a>2546</td><td></td><td></td><td></td><td></td><td class="s">they appear in the XML.  Setting this option to 1 will cause all element and</td></tr>
<tr><td class="h"><a name="2547"></a>2547</td><td></td><td></td><td></td><td></td><td class="s">attribute names to be expanded to include their namespace prefix.</td></tr>
<tr><td class="h"><a name="2548"></a>2548</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2549"></a>2549</td><td></td><td></td><td></td><td></td><td class="s">I&lt;Note: You must be using a SAX parser for this option to work (ie: it does not</td></tr>
<tr><td class="h"><a name="2550"></a>2550</td><td></td><td></td><td></td><td></td><td class="s">work with XML::Parser)&gt;.</td></tr>
<tr><td class="h"><a name="2551"></a>2551</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2552"></a>2552</td><td></td><td></td><td></td><td></td><td class="s">This option also controls whether C&lt;XMLout()&gt; performs the reverse translation</td></tr>
<tr><td class="h"><a name="2553"></a>2553</td><td></td><td></td><td></td><td></td><td class="s">from '{uri}name' back to 'prefix:name'.  The default is no translation.  If</td></tr>
<tr><td class="h"><a name="2554"></a>2554</td><td></td><td></td><td></td><td></td><td class="s">your data contains expanded names, you should set this option to 1 otherwise</td></tr>
<tr><td class="h"><a name="2555"></a>2555</td><td></td><td></td><td></td><td></td><td class="s">C&lt;XMLout&gt; will emit XML which is not well formed.</td></tr>
<tr><td class="h"><a name="2556"></a>2556</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2557"></a>2557</td><td></td><td></td><td></td><td></td><td class="s">I&lt;Note: You must have the XML::NamespaceSupport module installed if you want</td></tr>
<tr><td class="h"><a name="2558"></a>2558</td><td></td><td></td><td></td><td></td><td class="s">C&lt;XMLout()&gt; to translate URIs back to prefixes&gt;.</td></tr>
<tr><td class="h"><a name="2559"></a>2559</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2560"></a>2560</td><td></td><td></td><td></td><td></td><td class="s">=head2 NumericEscape =&gt; 0 | 1 | 2 I&lt;# out - handy&gt;</td></tr>
<tr><td class="h"><a name="2561"></a>2561</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2562"></a>2562</td><td></td><td></td><td></td><td></td><td class="s">Use this option to have 'high' (non-ASCII) characters in your Perl data</td></tr>
<tr><td class="h"><a name="2563"></a>2563</td><td></td><td></td><td></td><td></td><td class="s">structure converted to numeric entities (eg: &amp;#8364;) in the XML output.  Three</td></tr>
<tr><td class="h"><a name="2564"></a>2564</td><td></td><td></td><td></td><td></td><td class="s">levels are possible:</td></tr>
<tr><td class="h"><a name="2565"></a>2565</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2566"></a>2566</td><td></td><td></td><td></td><td></td><td class="s">0 - default: no numeric escaping (OK if you're writing out UTF8)</td></tr>
<tr><td class="h"><a name="2567"></a>2567</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2568"></a>2568</td><td></td><td></td><td></td><td></td><td class="s">1 - only characters above 0xFF are escaped (ie: characters in the 0x80-FF range are not escaped), possibly useful with ISO8859-1 output</td></tr>
<tr><td class="h"><a name="2569"></a>2569</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2570"></a>2570</td><td></td><td></td><td></td><td></td><td class="s">2 - all characters above 0x7F are escaped (good for plain ASCII output)</td></tr>
<tr><td class="h"><a name="2571"></a>2571</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2572"></a>2572</td><td></td><td></td><td></td><td></td><td class="s">=head2 OutputFile =&gt; &lt;file specifier&gt; I&lt;# out - handy&gt;</td></tr>
<tr><td class="h"><a name="2573"></a>2573</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2574"></a>2574</td><td></td><td></td><td></td><td></td><td class="s">The default behaviour of C&lt;XMLout()&gt; is to return the XML as a string.  If you</td></tr>
<tr><td class="h"><a name="2575"></a>2575</td><td></td><td></td><td></td><td></td><td class="s">wish to write the XML to a file, simply supply the filename using the</td></tr>
<tr><td class="h"><a name="2576"></a>2576</td><td></td><td></td><td></td><td></td><td class="s">'OutputFile' option.  </td></tr>
<tr><td class="h"><a name="2577"></a>2577</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2578"></a>2578</td><td></td><td></td><td></td><td></td><td class="s">This option also accepts an IO handle object - especially useful in Perl 5.8.0 </td></tr>
<tr><td class="h"><a name="2579"></a>2579</td><td></td><td></td><td></td><td></td><td class="s">and later for output using an encoding other than UTF-8, eg:</td></tr>
<tr><td class="h"><a name="2580"></a>2580</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2581"></a>2581</td><td></td><td></td><td></td><td></td><td class="s">  open my $fh, '&gt;:encoding(iso-8859-1)', $path or die &quot;open($path): $!&quot;;</td></tr>
<tr><td class="h"><a name="2582"></a>2582</td><td></td><td></td><td></td><td></td><td class="s">  XMLout($ref, OutputFile =&gt; $fh);</td></tr>
<tr><td class="h"><a name="2583"></a>2583</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2584"></a>2584</td><td></td><td></td><td></td><td></td><td class="s">Note, XML::Simple does not require that the object you pass in to the</td></tr>
<tr><td class="h"><a name="2585"></a>2585</td><td></td><td></td><td></td><td></td><td class="s">OutputFile option inherits from L&lt;IO::Handle&gt; - it simply assumes the object</td></tr>
<tr><td class="h"><a name="2586"></a>2586</td><td></td><td></td><td></td><td></td><td class="s">supports a C&lt;print&gt; method.</td></tr>
<tr><td class="h"><a name="2587"></a>2587</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2588"></a>2588</td><td></td><td></td><td></td><td></td><td class="s">=head2 ParserOpts =&gt; [ XML::Parser Options ] I&lt;# in - don't use this&gt;</td></tr>
<tr><td class="h"><a name="2589"></a>2589</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2590"></a>2590</td><td></td><td></td><td></td><td></td><td class="s">I&lt;Note: This option is now officially deprecated.  If you find it useful, email</td></tr>
<tr><td class="h"><a name="2591"></a>2591</td><td></td><td></td><td></td><td></td><td class="s">the author with an example of what you use it for.  Do not use this option to</td></tr>
<tr><td class="h"><a name="2592"></a>2592</td><td></td><td></td><td></td><td></td><td class="s">set the ProtocolEncoding, that's just plain wrong - fix the XML&gt;.</td></tr>
<tr><td class="h"><a name="2593"></a>2593</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2594"></a>2594</td><td></td><td></td><td></td><td></td><td class="s">This option allows you to pass parameters to the constructor of the underlying</td></tr>
<tr><td class="h"><a name="2595"></a>2595</td><td></td><td></td><td></td><td></td><td class="s">XML::Parser object (which of course assumes you're not using SAX).</td></tr>
<tr><td class="h"><a name="2596"></a>2596</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2597"></a>2597</td><td></td><td></td><td></td><td></td><td class="s">=head2 RootName =&gt; 'string' I&lt;# out - handy&gt;</td></tr>
<tr><td class="h"><a name="2598"></a>2598</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2599"></a>2599</td><td></td><td></td><td></td><td></td><td class="s">By default, when C&lt;XMLout()&gt; generates XML, the root element will be named</td></tr>
<tr><td class="h"><a name="2600"></a>2600</td><td></td><td></td><td></td><td></td><td class="s">'opt'.  This option allows you to specify an alternative name.</td></tr>
<tr><td class="h"><a name="2601"></a>2601</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2602"></a>2602</td><td></td><td></td><td></td><td></td><td class="s">Specifying either undef or the empty string for the RootName option will</td></tr>
<tr><td class="h"><a name="2603"></a>2603</td><td></td><td></td><td></td><td></td><td class="s">produce XML with no root elements.  In most cases the resulting XML fragment</td></tr>
<tr><td class="h"><a name="2604"></a>2604</td><td></td><td></td><td></td><td></td><td class="s">will not be 'well formed' and therefore could not be read back in by C&lt;XMLin()&gt;.</td></tr>
<tr><td class="h"><a name="2605"></a>2605</td><td></td><td></td><td></td><td></td><td class="s">Nevertheless, the option has been found to be useful in certain circumstances.</td></tr>
<tr><td class="h"><a name="2606"></a>2606</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2607"></a>2607</td><td></td><td></td><td></td><td></td><td class="s">=head2 SearchPath =&gt; [ list ] I&lt;# in - handy&gt;</td></tr>
<tr><td class="h"><a name="2608"></a>2608</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2609"></a>2609</td><td></td><td></td><td></td><td></td><td class="s">If you pass C&lt;XMLin()&gt; a filename, but the filename include no directory</td></tr>
<tr><td class="h"><a name="2610"></a>2610</td><td></td><td></td><td></td><td></td><td class="s">component, you can use this option to specify which directories should be</td></tr>
<tr><td class="h"><a name="2611"></a>2611</td><td></td><td></td><td></td><td></td><td class="s">searched to locate the file.  You might use this option to search first in the</td></tr>
<tr><td class="h"><a name="2612"></a>2612</td><td></td><td></td><td></td><td></td><td class="s">user's home directory, then in a global directory such as /etc.</td></tr>
<tr><td class="h"><a name="2613"></a>2613</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2614"></a>2614</td><td></td><td></td><td></td><td></td><td class="s">If a filename is provided to C&lt;XMLin()&gt; but SearchPath is not defined, the</td></tr>
<tr><td class="h"><a name="2615"></a>2615</td><td></td><td></td><td></td><td></td><td class="s">file is assumed to be in the current directory.</td></tr>
<tr><td class="h"><a name="2616"></a>2616</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2617"></a>2617</td><td></td><td></td><td></td><td></td><td class="s">If the first parameter to C&lt;XMLin()&gt; is undefined, the default SearchPath</td></tr>
<tr><td class="h"><a name="2618"></a>2618</td><td></td><td></td><td></td><td></td><td class="s">will contain only the directory in which the script itself is located.</td></tr>
<tr><td class="h"><a name="2619"></a>2619</td><td></td><td></td><td></td><td></td><td class="s">Otherwise the default SearchPath will be empty.  </td></tr>
<tr><td class="h"><a name="2620"></a>2620</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2621"></a>2621</td><td></td><td></td><td></td><td></td><td class="s">=head2 SuppressEmpty =&gt; 1 | '' | undef I&lt;# in+out - handy&gt;</td></tr>
<tr><td class="h"><a name="2622"></a>2622</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2623"></a>2623</td><td></td><td></td><td></td><td></td><td class="s">This option controls what C&lt;XMLin()&gt; should do with empty elements (no</td></tr>
<tr><td class="h"><a name="2624"></a>2624</td><td></td><td></td><td></td><td></td><td class="s">attributes and no content).  The default behaviour is to represent them as</td></tr>
<tr><td class="h"><a name="2625"></a>2625</td><td></td><td></td><td></td><td></td><td class="s">empty hashes.  Setting this option to a true value (eg: 1) will cause empty</td></tr>
<tr><td class="h"><a name="2626"></a>2626</td><td></td><td></td><td></td><td></td><td class="s">elements to be skipped altogether.  Setting the option to 'undef' or the empty</td></tr>
<tr><td class="h"><a name="2627"></a>2627</td><td></td><td></td><td></td><td></td><td class="s">string will cause empty elements to be represented as the undefined value or</td></tr>
<tr><td class="h"><a name="2628"></a>2628</td><td></td><td></td><td></td><td></td><td class="s">the empty string respectively.  The latter two alternatives are a little</td></tr>
<tr><td class="h"><a name="2629"></a>2629</td><td></td><td></td><td></td><td></td><td class="s">easier to test for in your code than a hash with no keys.</td></tr>
<tr><td class="h"><a name="2630"></a>2630</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2631"></a>2631</td><td></td><td></td><td></td><td></td><td class="s">The option also controls what C&lt;XMLout()&gt; does with undefined values.  Setting</td></tr>
<tr><td class="h"><a name="2632"></a>2632</td><td></td><td></td><td></td><td></td><td class="s">the option to undef causes undefined values to be output as empty elements</td></tr>
<tr><td class="h"><a name="2633"></a>2633</td><td></td><td></td><td></td><td></td><td class="s">(rather than empty attributes), it also suppresses the generation of warnings</td></tr>
<tr><td class="h"><a name="2634"></a>2634</td><td></td><td></td><td></td><td></td><td class="s">about undefined values.  Setting the option to a true value (eg: 1) causes</td></tr>
<tr><td class="h"><a name="2635"></a>2635</td><td></td><td></td><td></td><td></td><td class="s">undefined values to be skipped altogether on output.</td></tr>
<tr><td class="h"><a name="2636"></a>2636</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2637"></a>2637</td><td></td><td></td><td></td><td></td><td class="s">=head2 ValueAttr =&gt; [ names ] I&lt;# in - handy&gt;</td></tr>
<tr><td class="h"><a name="2638"></a>2638</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2639"></a>2639</td><td></td><td></td><td></td><td></td><td class="s">Use this option to deal elements which always have a single attribute and no</td></tr>
<tr><td class="h"><a name="2640"></a>2640</td><td></td><td></td><td></td><td></td><td class="s">content.  Eg:</td></tr>
<tr><td class="h"><a name="2641"></a>2641</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2642"></a>2642</td><td></td><td></td><td></td><td></td><td class="s">  &lt;opt&gt;</td></tr>
<tr><td class="h"><a name="2643"></a>2643</td><td></td><td></td><td></td><td></td><td class="s">    &lt;colour value=&quot;red&quot; /&gt;</td></tr>
<tr><td class="h"><a name="2644"></a>2644</td><td></td><td></td><td></td><td></td><td class="s">    &lt;size   value=&quot;XXL&quot; /&gt;</td></tr>
<tr><td class="h"><a name="2645"></a>2645</td><td></td><td></td><td></td><td></td><td class="s">  &lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="2646"></a>2646</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2647"></a>2647</td><td></td><td></td><td></td><td></td><td class="s">Setting C&lt;&lt; ValueAttr =&gt; [ 'value' ] &gt;&gt; will cause the above XML to parse to:</td></tr>
<tr><td class="h"><a name="2648"></a>2648</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2649"></a>2649</td><td></td><td></td><td></td><td></td><td class="s">  {</td></tr>
<tr><td class="h"><a name="2650"></a>2650</td><td></td><td></td><td></td><td></td><td class="s">    colour =&gt; 'red',</td></tr>
<tr><td class="h"><a name="2651"></a>2651</td><td></td><td></td><td></td><td></td><td class="s">    size   =&gt; 'XXL'</td></tr>
<tr><td class="h"><a name="2652"></a>2652</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="2653"></a>2653</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2654"></a>2654</td><td></td><td></td><td></td><td></td><td class="s">instead of this (the default):</td></tr>
<tr><td class="h"><a name="2655"></a>2655</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2656"></a>2656</td><td></td><td></td><td></td><td></td><td class="s">  {</td></tr>
<tr><td class="h"><a name="2657"></a>2657</td><td></td><td></td><td></td><td></td><td class="s">    colour =&gt; { value =&gt; 'red' },</td></tr>
<tr><td class="h"><a name="2658"></a>2658</td><td></td><td></td><td></td><td></td><td class="s">    size   =&gt; { value =&gt; 'XXL' }</td></tr>
<tr><td class="h"><a name="2659"></a>2659</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="2660"></a>2660</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2661"></a>2661</td><td></td><td></td><td></td><td></td><td class="s">Note: This form of the ValueAttr option is not compatible with C&lt;XMLout()&gt; -</td></tr>
<tr><td class="h"><a name="2662"></a>2662</td><td></td><td></td><td></td><td></td><td class="s">since the attribute name is discarded at parse time, the original XML cannot be</td></tr>
<tr><td class="h"><a name="2663"></a>2663</td><td></td><td></td><td></td><td></td><td class="s">reconstructed.</td></tr>
<tr><td class="h"><a name="2664"></a>2664</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2665"></a>2665</td><td></td><td></td><td></td><td></td><td class="s">=head2 ValueAttr =&gt; { element =&gt; attribute, ... } I&lt;# in+out - handy&gt;</td></tr>
<tr><td class="h"><a name="2666"></a>2666</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2667"></a>2667</td><td></td><td></td><td></td><td></td><td class="s">This (preferred) form of the ValueAttr option requires you to specify both</td></tr>
<tr><td class="h"><a name="2668"></a>2668</td><td></td><td></td><td></td><td></td><td class="s">the element and the attribute names.  This is not only safer, it also allows</td></tr>
<tr><td class="h"><a name="2669"></a>2669</td><td></td><td></td><td></td><td></td><td class="s">the original XML to be reconstructed by C&lt;XMLout()&gt;.</td></tr>
<tr><td class="h"><a name="2670"></a>2670</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2671"></a>2671</td><td></td><td></td><td></td><td></td><td class="s">Note: You probably don't want to use this option and the NoAttr option at the</td></tr>
<tr><td class="h"><a name="2672"></a>2672</td><td></td><td></td><td></td><td></td><td class="s">same time.</td></tr>
<tr><td class="h"><a name="2673"></a>2673</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2674"></a>2674</td><td></td><td></td><td></td><td></td><td class="s">=head2 Variables =&gt; { name =&gt; value } I&lt;# in - handy&gt;</td></tr>
<tr><td class="h"><a name="2675"></a>2675</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2676"></a>2676</td><td></td><td></td><td></td><td></td><td class="s">This option allows variables in the XML to be expanded when the file is read.</td></tr>
<tr><td class="h"><a name="2677"></a>2677</td><td></td><td></td><td></td><td></td><td class="s">(there is no facility for putting the variable names back if you regenerate</td></tr>
<tr><td class="h"><a name="2678"></a>2678</td><td></td><td></td><td></td><td></td><td class="s">XML using C&lt;XMLout&gt;).</td></tr>
<tr><td class="h"><a name="2679"></a>2679</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2680"></a>2680</td><td></td><td></td><td></td><td></td><td class="s">A 'variable' is any text of the form C&lt;${name}&gt; which occurs in an attribute</td></tr>
<tr><td class="h"><a name="2681"></a>2681</td><td></td><td></td><td></td><td></td><td class="s">value or in the text content of an element.  If 'name' matches a key in the</td></tr>
<tr><td class="h"><a name="2682"></a>2682</td><td></td><td></td><td></td><td></td><td class="s">supplied hashref, C&lt;${name}&gt; will be replaced with the corresponding value from</td></tr>
<tr><td class="h"><a name="2683"></a>2683</td><td></td><td></td><td></td><td></td><td class="s">the hashref.  If no matching key is found, the variable will not be replaced.</td></tr>
<tr><td class="h"><a name="2684"></a>2684</td><td></td><td></td><td></td><td></td><td class="s">Names must match the regex: C&lt;[\w.]+&gt; (ie: only 'word' characters and dots are</td></tr>
<tr><td class="h"><a name="2685"></a>2685</td><td></td><td></td><td></td><td></td><td class="s">allowed).</td></tr>
<tr><td class="h"><a name="2686"></a>2686</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2687"></a>2687</td><td></td><td></td><td></td><td></td><td class="s">=head2 VarAttr =&gt; 'attr_name' I&lt;# in - handy&gt;</td></tr>
<tr><td class="h"><a name="2688"></a>2688</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2689"></a>2689</td><td></td><td></td><td></td><td></td><td class="s">In addition to the variables defined using C&lt;Variables&gt;, this option allows</td></tr>
<tr><td class="h"><a name="2690"></a>2690</td><td></td><td></td><td></td><td></td><td class="s">variables to be defined in the XML.  A variable definition consists of an</td></tr>
<tr><td class="h"><a name="2691"></a>2691</td><td></td><td></td><td></td><td></td><td class="s">element with an attribute called 'attr_name' (the value of the C&lt;VarAttr&gt;</td></tr>
<tr><td class="h"><a name="2692"></a>2692</td><td></td><td></td><td></td><td></td><td class="s">option).  The value of the attribute will be used as the variable name and the</td></tr>
<tr><td class="h"><a name="2693"></a>2693</td><td></td><td></td><td></td><td></td><td class="s">text content of the element will be used as the value.  A variable defined in</td></tr>
<tr><td class="h"><a name="2694"></a>2694</td><td></td><td></td><td></td><td></td><td class="s">this way will override a variable defined using the C&lt;Variables&gt; option.  For</td></tr>
<tr><td class="h"><a name="2695"></a>2695</td><td></td><td></td><td></td><td></td><td class="s">example:</td></tr>
<tr><td class="h"><a name="2696"></a>2696</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2697"></a>2697</td><td></td><td></td><td></td><td></td><td class="s">  XMLin( '&lt;opt&gt;</td></tr>
<tr><td class="h"><a name="2698"></a>2698</td><td></td><td></td><td></td><td></td><td class="s">            &lt;dir name=&quot;prefix&quot;&gt;/usr/local/apache&lt;/dir&gt;</td></tr>
<tr><td class="h"><a name="2699"></a>2699</td><td></td><td></td><td></td><td></td><td class="s">            &lt;dir name=&quot;exec_prefix&quot;&gt;${prefix}&lt;/dir&gt;</td></tr>
<tr><td class="h"><a name="2700"></a>2700</td><td></td><td></td><td></td><td></td><td class="s">            &lt;dir name=&quot;bindir&quot;&gt;${exec_prefix}/bin&lt;/dir&gt;</td></tr>
<tr><td class="h"><a name="2701"></a>2701</td><td></td><td></td><td></td><td></td><td class="s">          &lt;/opt&gt;',</td></tr>
<tr><td class="h"><a name="2702"></a>2702</td><td></td><td></td><td></td><td></td><td class="s">         VarAttr =&gt; 'name', ContentKey =&gt; '-content'</td></tr>
<tr><td class="h"><a name="2703"></a>2703</td><td></td><td></td><td></td><td></td><td class="s">        );</td></tr>
<tr><td class="h"><a name="2704"></a>2704</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2705"></a>2705</td><td></td><td></td><td></td><td></td><td class="s">produces the following data structure:</td></tr>
<tr><td class="h"><a name="2706"></a>2706</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2707"></a>2707</td><td></td><td></td><td></td><td></td><td class="s">  {</td></tr>
<tr><td class="h"><a name="2708"></a>2708</td><td></td><td></td><td></td><td></td><td class="s">    dir =&gt; {</td></tr>
<tr><td class="h"><a name="2709"></a>2709</td><td></td><td></td><td></td><td></td><td class="s">             prefix      =&gt; '/usr/local/apache',</td></tr>
<tr><td class="h"><a name="2710"></a>2710</td><td></td><td></td><td></td><td></td><td class="s">             exec_prefix =&gt; '/usr/local/apache',</td></tr>
<tr><td class="h"><a name="2711"></a>2711</td><td></td><td></td><td></td><td></td><td class="s">             bindir      =&gt; '/usr/local/apache/bin',</td></tr>
<tr><td class="h"><a name="2712"></a>2712</td><td></td><td></td><td></td><td></td><td class="s">           }</td></tr>
<tr><td class="h"><a name="2713"></a>2713</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="2714"></a>2714</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2715"></a>2715</td><td></td><td></td><td></td><td></td><td class="s">=head2 XMLDecl =&gt; 1  or  XMLDecl =&gt; 'string'  I&lt;# out - handy&gt;</td></tr>
<tr><td class="h"><a name="2716"></a>2716</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2717"></a>2717</td><td></td><td></td><td></td><td></td><td class="s">If you want the output from C&lt;XMLout()&gt; to start with the optional XML</td></tr>
<tr><td class="h"><a name="2718"></a>2718</td><td></td><td></td><td></td><td></td><td class="s">declaration, simply set the option to '1'.  The default XML declaration is:</td></tr>
<tr><td class="h"><a name="2719"></a>2719</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2720"></a>2720</td><td></td><td></td><td></td><td></td><td class="s">        &lt;?xml version='1.0' standalone='yes'?&gt;</td></tr>
<tr><td class="h"><a name="2721"></a>2721</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2722"></a>2722</td><td></td><td></td><td></td><td></td><td class="s">If you want some other string (for example to declare an encoding value), set</td></tr>
<tr><td class="h"><a name="2723"></a>2723</td><td></td><td></td><td></td><td></td><td class="s">the value of this option to the complete string you require.</td></tr>
<tr><td class="h"><a name="2724"></a>2724</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2725"></a>2725</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2726"></a>2726</td><td></td><td></td><td></td><td></td><td class="s">=head1 OPTIONAL OO INTERFACE</td></tr>
<tr><td class="h"><a name="2727"></a>2727</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2728"></a>2728</td><td></td><td></td><td></td><td></td><td class="s">The procedural interface is both simple and convenient however there are a</td></tr>
<tr><td class="h"><a name="2729"></a>2729</td><td></td><td></td><td></td><td></td><td class="s">couple of reasons why you might prefer to use the object oriented (OO)</td></tr>
<tr><td class="h"><a name="2730"></a>2730</td><td></td><td></td><td></td><td></td><td class="s">interface:</td></tr>
<tr><td class="h"><a name="2731"></a>2731</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2732"></a>2732</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="2733"></a>2733</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2734"></a>2734</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2735"></a>2735</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2736"></a>2736</td><td></td><td></td><td></td><td></td><td class="s">to define a set of default values which should be used on all subsequent calls</td></tr>
<tr><td class="h"><a name="2737"></a>2737</td><td></td><td></td><td></td><td></td><td class="s">to C&lt;XMLin()&gt; or C&lt;XMLout()&gt;</td></tr>
<tr><td class="h"><a name="2738"></a>2738</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2739"></a>2739</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2740"></a>2740</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2741"></a>2741</td><td></td><td></td><td></td><td></td><td class="s">to override methods in B&lt;XML::Simple&gt; to provide customised behaviour</td></tr>
<tr><td class="h"><a name="2742"></a>2742</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2743"></a>2743</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="2744"></a>2744</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2745"></a>2745</td><td></td><td></td><td></td><td></td><td class="s">The default values for the options described above are unlikely to suit</td></tr>
<tr><td class="h"><a name="2746"></a>2746</td><td></td><td></td><td></td><td></td><td class="s">everyone.  The OO interface allows you to effectively override B&lt;XML::Simple&gt;'s</td></tr>
<tr><td class="h"><a name="2747"></a>2747</td><td></td><td></td><td></td><td></td><td class="s">defaults with your preferred values.  It works like this:</td></tr>
<tr><td class="h"><a name="2748"></a>2748</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2749"></a>2749</td><td></td><td></td><td></td><td></td><td class="s">First create an XML::Simple parser object with your preferred defaults:</td></tr>
<tr><td class="h"><a name="2750"></a>2750</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2751"></a>2751</td><td></td><td></td><td></td><td></td><td class="s">  my $xs = XML::Simple-&gt;new(ForceArray =&gt; 1, KeepRoot =&gt; 1);</td></tr>
<tr><td class="h"><a name="2752"></a>2752</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2753"></a>2753</td><td></td><td></td><td></td><td></td><td class="s">then call C&lt;XMLin()&gt; or C&lt;XMLout()&gt; as a method of that object:</td></tr>
<tr><td class="h"><a name="2754"></a>2754</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2755"></a>2755</td><td></td><td></td><td></td><td></td><td class="s">  my $ref = $xs-&gt;XMLin($xml);</td></tr>
<tr><td class="h"><a name="2756"></a>2756</td><td></td><td></td><td></td><td></td><td class="s">  my $xml = $xs-&gt;XMLout($ref);</td></tr>
<tr><td class="h"><a name="2757"></a>2757</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2758"></a>2758</td><td></td><td></td><td></td><td></td><td class="s">You can also specify options when you make the method calls and these values</td></tr>
<tr><td class="h"><a name="2759"></a>2759</td><td></td><td></td><td></td><td></td><td class="s">will be merged with the values specified when the object was created.  Values</td></tr>
<tr><td class="h"><a name="2760"></a>2760</td><td></td><td></td><td></td><td></td><td class="s">specified in a method call take precedence.</td></tr>
<tr><td class="h"><a name="2761"></a>2761</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2762"></a>2762</td><td></td><td></td><td></td><td></td><td class="s">Note: when called as methods, the C&lt;XMLin()&gt; and C&lt;XMLout()&gt; routines may be</td></tr>
<tr><td class="h"><a name="2763"></a>2763</td><td></td><td></td><td></td><td></td><td class="s">called as C&lt;xml_in()&gt; or C&lt;xml_out()&gt;.  The method names are aliased so the</td></tr>
<tr><td class="h"><a name="2764"></a>2764</td><td></td><td></td><td></td><td></td><td class="s">only difference is the aesthetics.</td></tr>
<tr><td class="h"><a name="2765"></a>2765</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2766"></a>2766</td><td></td><td></td><td></td><td></td><td class="s">=head2 Parsing Methods</td></tr>
<tr><td class="h"><a name="2767"></a>2767</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2768"></a>2768</td><td></td><td></td><td></td><td></td><td class="s">You can explicitly call one of the following methods rather than rely on the</td></tr>
<tr><td class="h"><a name="2769"></a>2769</td><td></td><td></td><td></td><td></td><td class="s">C&lt;xml_in()&gt; method automatically determining whether the target to be parsed is</td></tr>
<tr><td class="h"><a name="2770"></a>2770</td><td></td><td></td><td></td><td></td><td class="s">a string, a file or a filehandle:</td></tr>
<tr><td class="h"><a name="2771"></a>2771</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2772"></a>2772</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="2773"></a>2773</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2774"></a>2774</td><td></td><td></td><td></td><td></td><td class="s">=item parse_string(text)</td></tr>
<tr><td class="h"><a name="2775"></a>2775</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2776"></a>2776</td><td></td><td></td><td></td><td></td><td class="s">Works exactly like the C&lt;xml_in()&gt; method but assumes the first argument is</td></tr>
<tr><td class="h"><a name="2777"></a>2777</td><td></td><td></td><td></td><td></td><td class="s">a string of XML (or a reference to a scalar containing a string of XML).</td></tr>
<tr><td class="h"><a name="2778"></a>2778</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2779"></a>2779</td><td></td><td></td><td></td><td></td><td class="s">=item parse_file(filename)</td></tr>
<tr><td class="h"><a name="2780"></a>2780</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2781"></a>2781</td><td></td><td></td><td></td><td></td><td class="s">Works exactly like the C&lt;xml_in()&gt; method but assumes the first argument is</td></tr>
<tr><td class="h"><a name="2782"></a>2782</td><td></td><td></td><td></td><td></td><td class="s">the name of a file containing XML.</td></tr>
<tr><td class="h"><a name="2783"></a>2783</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2784"></a>2784</td><td></td><td></td><td></td><td></td><td class="s">=item parse_fh(file_handle)</td></tr>
<tr><td class="h"><a name="2785"></a>2785</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2786"></a>2786</td><td></td><td></td><td></td><td></td><td class="s">Works exactly like the C&lt;xml_in()&gt; method but assumes the first argument is</td></tr>
<tr><td class="h"><a name="2787"></a>2787</td><td></td><td></td><td></td><td></td><td class="s">a filehandle which can be read to get XML.</td></tr>
<tr><td class="h"><a name="2788"></a>2788</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2789"></a>2789</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="2790"></a>2790</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2791"></a>2791</td><td></td><td></td><td></td><td></td><td class="s">=head2 Hook Methods</td></tr>
<tr><td class="h"><a name="2792"></a>2792</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2793"></a>2793</td><td></td><td></td><td></td><td></td><td class="s">You can make your own class which inherits from XML::Simple and overrides</td></tr>
<tr><td class="h"><a name="2794"></a>2794</td><td></td><td></td><td></td><td></td><td class="s">certain behaviours.  The following methods may provide useful 'hooks' upon</td></tr>
<tr><td class="h"><a name="2795"></a>2795</td><td></td><td></td><td></td><td></td><td class="s">which to hang your modified behaviour.  You may find other undocumented methods</td></tr>
<tr><td class="h"><a name="2796"></a>2796</td><td></td><td></td><td></td><td></td><td class="s">by examining the source, but those may be subject to change in future releases.</td></tr>
<tr><td class="h"><a name="2797"></a>2797</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2798"></a>2798</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="2799"></a>2799</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2800"></a>2800</td><td></td><td></td><td></td><td></td><td class="s">=item handle_options(direction, name =&gt; value ...)</td></tr>
<tr><td class="h"><a name="2801"></a>2801</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2802"></a>2802</td><td></td><td></td><td></td><td></td><td class="s">This method will be called when one of the parsing methods or the C&lt;XMLout()&gt;</td></tr>
<tr><td class="h"><a name="2803"></a>2803</td><td></td><td></td><td></td><td></td><td class="s">method is called.  The initial argument will be a string (either 'in' or 'out')</td></tr>
<tr><td class="h"><a name="2804"></a>2804</td><td></td><td></td><td></td><td></td><td class="s">and the remaining arguments will be name value pairs.</td></tr>
<tr><td class="h"><a name="2805"></a>2805</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2806"></a>2806</td><td></td><td></td><td></td><td></td><td class="s">=item default_config_file()</td></tr>
<tr><td class="h"><a name="2807"></a>2807</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2808"></a>2808</td><td></td><td></td><td></td><td></td><td class="s">Calculates and returns the name of the file which should be parsed if no</td></tr>
<tr><td class="h"><a name="2809"></a>2809</td><td></td><td></td><td></td><td></td><td class="s">filename is passed to C&lt;XMLin()&gt; (default: C&lt;$0.xml&gt;).</td></tr>
<tr><td class="h"><a name="2810"></a>2810</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2811"></a>2811</td><td></td><td></td><td></td><td></td><td class="s">=item build_simple_tree(filename, string)</td></tr>
<tr><td class="h"><a name="2812"></a>2812</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2813"></a>2813</td><td></td><td></td><td></td><td></td><td class="s">Called from C&lt;XMLin()&gt; or any of the parsing methods.  Takes either a file name</td></tr>
<tr><td class="h"><a name="2814"></a>2814</td><td></td><td></td><td></td><td></td><td class="s">as the first argument or C&lt;undef&gt; followed by a 'string' as the second</td></tr>
<tr><td class="h"><a name="2815"></a>2815</td><td></td><td></td><td></td><td></td><td class="s">argument.  Returns a simple tree data structure.  You could override this</td></tr>
<tr><td class="h"><a name="2816"></a>2816</td><td></td><td></td><td></td><td></td><td class="s">method to apply your own transformations before the data structure is returned</td></tr>
<tr><td class="h"><a name="2817"></a>2817</td><td></td><td></td><td></td><td></td><td class="s">to the caller.</td></tr>
<tr><td class="h"><a name="2818"></a>2818</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2819"></a>2819</td><td></td><td></td><td></td><td></td><td class="s">=item new_hashref()</td></tr>
<tr><td class="h"><a name="2820"></a>2820</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2821"></a>2821</td><td></td><td></td><td></td><td></td><td class="s">When the 'simple tree' data structure is being built, this method will be</td></tr>
<tr><td class="h"><a name="2822"></a>2822</td><td></td><td></td><td></td><td></td><td class="s">called to create any required anonymous hashrefs.</td></tr>
<tr><td class="h"><a name="2823"></a>2823</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2824"></a>2824</td><td></td><td></td><td></td><td></td><td class="s">=item sorted_keys(name, hashref)</td></tr>
<tr><td class="h"><a name="2825"></a>2825</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2826"></a>2826</td><td></td><td></td><td></td><td></td><td class="s">Called when C&lt;XMLout()&gt; is translating a hashref to XML.  This routine returns</td></tr>
<tr><td class="h"><a name="2827"></a>2827</td><td></td><td></td><td></td><td></td><td class="s">a list of hash keys in the order that the corresponding attributes/elements</td></tr>
<tr><td class="h"><a name="2828"></a>2828</td><td></td><td></td><td></td><td></td><td class="s">should appear in the output.</td></tr>
<tr><td class="h"><a name="2829"></a>2829</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2830"></a>2830</td><td></td><td></td><td></td><td></td><td class="s">=item escape_value(string)</td></tr>
<tr><td class="h"><a name="2831"></a>2831</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2832"></a>2832</td><td></td><td></td><td></td><td></td><td class="s">Called from C&lt;XMLout()&gt;, takes a string and returns a copy of the string with</td></tr>
<tr><td class="h"><a name="2833"></a>2833</td><td></td><td></td><td></td><td></td><td class="s">XML character escaping rules applied.</td></tr>
<tr><td class="h"><a name="2834"></a>2834</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2835"></a>2835</td><td></td><td></td><td></td><td></td><td class="s">=item numeric_escape(string)</td></tr>
<tr><td class="h"><a name="2836"></a>2836</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2837"></a>2837</td><td></td><td></td><td></td><td></td><td class="s">Called from C&lt;escape_value()&gt;, to handle non-ASCII characters (depending on the</td></tr>
<tr><td class="h"><a name="2838"></a>2838</td><td></td><td></td><td></td><td></td><td class="s">value of the NumericEscape option).</td></tr>
<tr><td class="h"><a name="2839"></a>2839</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2840"></a>2840</td><td></td><td></td><td></td><td></td><td class="s">=item copy_hash(hashref, extra_key =&gt; value, ...)</td></tr>
<tr><td class="h"><a name="2841"></a>2841</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2842"></a>2842</td><td></td><td></td><td></td><td></td><td class="s">Called from C&lt;XMLout()&gt;, when 'unfolding' a hash of hashes into an array of</td></tr>
<tr><td class="h"><a name="2843"></a>2843</td><td></td><td></td><td></td><td></td><td class="s">hashes.  You might wish to override this method if you're using tied hashes and</td></tr>
<tr><td class="h"><a name="2844"></a>2844</td><td></td><td></td><td></td><td></td><td class="s">don't want them to get untied.</td></tr>
<tr><td class="h"><a name="2845"></a>2845</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2846"></a>2846</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="2847"></a>2847</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2848"></a>2848</td><td></td><td></td><td></td><td></td><td class="s">=head2 Cache Methods</td></tr>
<tr><td class="h"><a name="2849"></a>2849</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2850"></a>2850</td><td></td><td></td><td></td><td></td><td class="s">XML::Simple implements three caching schemes ('storable', 'memshare' and</td></tr>
<tr><td class="h"><a name="2851"></a>2851</td><td></td><td></td><td></td><td></td><td class="s">'memcopy').  You can implement a custom caching scheme by implementing</td></tr>
<tr><td class="h"><a name="2852"></a>2852</td><td></td><td></td><td></td><td></td><td class="s">two methods - one for reading from the cache and one for writing to it.</td></tr>
<tr><td class="h"><a name="2853"></a>2853</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2854"></a>2854</td><td></td><td></td><td></td><td></td><td class="s">For example, you might implement a new 'dbm' scheme that stores cached data</td></tr>
<tr><td class="h"><a name="2855"></a>2855</td><td></td><td></td><td></td><td></td><td class="s">structures using the L&lt;MLDBM&gt; module.  First, you would add a</td></tr>
<tr><td class="h"><a name="2856"></a>2856</td><td></td><td></td><td></td><td></td><td class="s">C&lt;cache_read_dbm()&gt; method which accepted a filename for use as a lookup key</td></tr>
<tr><td class="h"><a name="2857"></a>2857</td><td></td><td></td><td></td><td></td><td class="s">and returned a data structure on success, or undef on failure.  Then, you would</td></tr>
<tr><td class="h"><a name="2858"></a>2858</td><td></td><td></td><td></td><td></td><td class="s">implement a C&lt;cache_read_dbm()&gt; method which accepted a data structure and a</td></tr>
<tr><td class="h"><a name="2859"></a>2859</td><td></td><td></td><td></td><td></td><td class="s">filename.</td></tr>
<tr><td class="h"><a name="2860"></a>2860</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2861"></a>2861</td><td></td><td></td><td></td><td></td><td class="s">You would use this caching scheme by specifying the option:</td></tr>
<tr><td class="h"><a name="2862"></a>2862</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2863"></a>2863</td><td></td><td></td><td></td><td></td><td class="s">  Cache =&gt; [ 'dbm' ]</td></tr>
<tr><td class="h"><a name="2864"></a>2864</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2865"></a>2865</td><td></td><td></td><td></td><td></td><td class="s">=head1 STRICT MODE</td></tr>
<tr><td class="h"><a name="2866"></a>2866</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2867"></a>2867</td><td></td><td></td><td></td><td></td><td class="s">If you import the B&lt;XML::Simple&gt; routines like this:</td></tr>
<tr><td class="h"><a name="2868"></a>2868</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2869"></a>2869</td><td></td><td></td><td></td><td></td><td class="s">  use XML::Simple qw(:strict);</td></tr>
<tr><td class="h"><a name="2870"></a>2870</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2871"></a>2871</td><td></td><td></td><td></td><td></td><td class="s">the following common mistakes will be detected and treated as fatal errors</td></tr>
<tr><td class="h"><a name="2872"></a>2872</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2873"></a>2873</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="2874"></a>2874</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2875"></a>2875</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2876"></a>2876</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2877"></a>2877</td><td></td><td></td><td></td><td></td><td class="s">Failing to explicitly set the C&lt;KeyAttr&gt; option - if you can't be bothered</td></tr>
<tr><td class="h"><a name="2878"></a>2878</td><td></td><td></td><td></td><td></td><td class="s">reading about this option, turn it off with: KeyAttr =&gt; [ ]</td></tr>
<tr><td class="h"><a name="2879"></a>2879</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2880"></a>2880</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2881"></a>2881</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2882"></a>2882</td><td></td><td></td><td></td><td></td><td class="s">Failing to explicitly set the C&lt;ForceArray&gt; option - if you can't be bothered</td></tr>
<tr><td class="h"><a name="2883"></a>2883</td><td></td><td></td><td></td><td></td><td class="s">reading about this option, set it to the safest mode with: ForceArray =&gt; 1</td></tr>
<tr><td class="h"><a name="2884"></a>2884</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2885"></a>2885</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2886"></a>2886</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2887"></a>2887</td><td></td><td></td><td></td><td></td><td class="s">Setting ForceArray to an array, but failing to list all the elements from the</td></tr>
<tr><td class="h"><a name="2888"></a>2888</td><td></td><td></td><td></td><td></td><td class="s">KeyAttr hash.</td></tr>
<tr><td class="h"><a name="2889"></a>2889</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2890"></a>2890</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2891"></a>2891</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2892"></a>2892</td><td></td><td></td><td></td><td></td><td class="s">Data error - KeyAttr is set to say { part =&gt; 'partnum' } but the XML contains</td></tr>
<tr><td class="h"><a name="2893"></a>2893</td><td></td><td></td><td></td><td></td><td class="s">one or more E&lt;lt&gt;partE&lt;gt&gt; elements without a 'partnum' attribute (or nested</td></tr>
<tr><td class="h"><a name="2894"></a>2894</td><td></td><td></td><td></td><td></td><td class="s">element).  Note: if strict mode is not set but -w is, this condition triggers a</td></tr>
<tr><td class="h"><a name="2895"></a>2895</td><td></td><td></td><td></td><td></td><td class="s">warning.</td></tr>
<tr><td class="h"><a name="2896"></a>2896</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2897"></a>2897</td><td></td><td></td><td></td><td></td><td class="s">=item * </td></tr>
<tr><td class="h"><a name="2898"></a>2898</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2899"></a>2899</td><td></td><td></td><td></td><td></td><td class="s">Data error - as above, but non-unique values are present in the key attribute</td></tr>
<tr><td class="h"><a name="2900"></a>2900</td><td></td><td></td><td></td><td></td><td class="s">(eg: more than one E&lt;lt&gt;partE&lt;gt&gt; element with the same partnum).  This will</td></tr>
<tr><td class="h"><a name="2901"></a>2901</td><td></td><td></td><td></td><td></td><td class="s">also trigger a warning if strict mode is not enabled.</td></tr>
<tr><td class="h"><a name="2902"></a>2902</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2903"></a>2903</td><td></td><td></td><td></td><td></td><td class="s">=item * </td></tr>
<tr><td class="h"><a name="2904"></a>2904</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2905"></a>2905</td><td></td><td></td><td></td><td></td><td class="s">Data error - as above, but value of key attribute (eg: partnum) is not a </td></tr>
<tr><td class="h"><a name="2906"></a>2906</td><td></td><td></td><td></td><td></td><td class="s">scalar string (due to nested elements etc).  This will also trigger a warning</td></tr>
<tr><td class="h"><a name="2907"></a>2907</td><td></td><td></td><td></td><td></td><td class="s">if strict mode is not enabled.</td></tr>
<tr><td class="h"><a name="2908"></a>2908</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2909"></a>2909</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="2910"></a>2910</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2911"></a>2911</td><td></td><td></td><td></td><td></td><td class="s">=head1 SAX SUPPORT</td></tr>
<tr><td class="h"><a name="2912"></a>2912</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2913"></a>2913</td><td></td><td></td><td></td><td></td><td class="s">From version 1.08_01, B&lt;XML::Simple&gt; includes support for SAX (the Simple API</td></tr>
<tr><td class="h"><a name="2914"></a>2914</td><td></td><td></td><td></td><td></td><td class="s">for XML) - specifically SAX2. </td></tr>
<tr><td class="h"><a name="2915"></a>2915</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2916"></a>2916</td><td></td><td></td><td></td><td></td><td class="s">In a typical SAX application, an XML parser (or SAX 'driver') module generates</td></tr>
<tr><td class="h"><a name="2917"></a>2917</td><td></td><td></td><td></td><td></td><td class="s">SAX events (start of element, character data, end of element, etc) as it parses</td></tr>
<tr><td class="h"><a name="2918"></a>2918</td><td></td><td></td><td></td><td></td><td class="s">an XML document and a 'handler' module processes the events to extract the</td></tr>
<tr><td class="h"><a name="2919"></a>2919</td><td></td><td></td><td></td><td></td><td class="s">required data.  This simple model allows for some interesting and powerful</td></tr>
<tr><td class="h"><a name="2920"></a>2920</td><td></td><td></td><td></td><td></td><td class="s">possibilities:</td></tr>
<tr><td class="h"><a name="2921"></a>2921</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2922"></a>2922</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="2923"></a>2923</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2924"></a>2924</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2925"></a>2925</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2926"></a>2926</td><td></td><td></td><td></td><td></td><td class="s">Applications written to the SAX API can extract data from huge XML documents</td></tr>
<tr><td class="h"><a name="2927"></a>2927</td><td></td><td></td><td></td><td></td><td class="s">without the memory overheads of a DOM or tree API.</td></tr>
<tr><td class="h"><a name="2928"></a>2928</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2929"></a>2929</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2930"></a>2930</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2931"></a>2931</td><td></td><td></td><td></td><td></td><td class="s">The SAX API allows for plug and play interchange of parser modules without</td></tr>
<tr><td class="h"><a name="2932"></a>2932</td><td></td><td></td><td></td><td></td><td class="s">having to change your code to fit a new module's API.  A number of SAX parsers</td></tr>
<tr><td class="h"><a name="2933"></a>2933</td><td></td><td></td><td></td><td></td><td class="s">are available with capabilities ranging from extreme portability to blazing</td></tr>
<tr><td class="h"><a name="2934"></a>2934</td><td></td><td></td><td></td><td></td><td class="s">performance.</td></tr>
<tr><td class="h"><a name="2935"></a>2935</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2936"></a>2936</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2937"></a>2937</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2938"></a>2938</td><td></td><td></td><td></td><td></td><td class="s">A SAX 'filter' module can implement both a handler interface for receiving</td></tr>
<tr><td class="h"><a name="2939"></a>2939</td><td></td><td></td><td></td><td></td><td class="s">data and a generator interface for passing modified data on to a downstream</td></tr>
<tr><td class="h"><a name="2940"></a>2940</td><td></td><td></td><td></td><td></td><td class="s">handler.  Filters can be chained together in 'pipelines'.</td></tr>
<tr><td class="h"><a name="2941"></a>2941</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2942"></a>2942</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2943"></a>2943</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2944"></a>2944</td><td></td><td></td><td></td><td></td><td class="s">One filter module might split a data stream to direct data to two or more</td></tr>
<tr><td class="h"><a name="2945"></a>2945</td><td></td><td></td><td></td><td></td><td class="s">downstream handlers.</td></tr>
<tr><td class="h"><a name="2946"></a>2946</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2947"></a>2947</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="2948"></a>2948</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2949"></a>2949</td><td></td><td></td><td></td><td></td><td class="s">Generating SAX events is not the exclusive preserve of XML parsing modules.</td></tr>
<tr><td class="h"><a name="2950"></a>2950</td><td></td><td></td><td></td><td></td><td class="s">For example, a module might extract data from a relational database using DBI</td></tr>
<tr><td class="h"><a name="2951"></a>2951</td><td></td><td></td><td></td><td></td><td class="s">and pass it on to a SAX pipeline for filtering and formatting.</td></tr>
<tr><td class="h"><a name="2952"></a>2952</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2953"></a>2953</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="2954"></a>2954</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2955"></a>2955</td><td></td><td></td><td></td><td></td><td class="s">B&lt;XML::Simple&gt; can operate at either end of a SAX pipeline.  For example,</td></tr>
<tr><td class="h"><a name="2956"></a>2956</td><td></td><td></td><td></td><td></td><td class="s">you can take a data structure in the form of a hashref and pass it into a</td></tr>
<tr><td class="h"><a name="2957"></a>2957</td><td></td><td></td><td></td><td></td><td class="s">SAX pipeline using the 'Handler' option on C&lt;XMLout()&gt;:</td></tr>
<tr><td class="h"><a name="2958"></a>2958</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2959"></a>2959</td><td></td><td></td><td></td><td></td><td class="s">  use XML::Simple;</td></tr>
<tr><td class="h"><a name="2960"></a>2960</td><td></td><td></td><td></td><td></td><td class="s">  use Some::SAX::Filter;</td></tr>
<tr><td class="h"><a name="2961"></a>2961</td><td></td><td></td><td></td><td></td><td class="s">  use XML::SAX::Writer;</td></tr>
<tr><td class="h"><a name="2962"></a>2962</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2963"></a>2963</td><td></td><td></td><td></td><td></td><td class="s">  my $ref = {</td></tr>
<tr><td class="h"><a name="2964"></a>2964</td><td></td><td></td><td></td><td></td><td class="s">               ....   # your data here</td></tr>
<tr><td class="h"><a name="2965"></a>2965</td><td></td><td></td><td></td><td></td><td class="s">            };</td></tr>
<tr><td class="h"><a name="2966"></a>2966</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2967"></a>2967</td><td></td><td></td><td></td><td></td><td class="s">  my $writer = XML::SAX::Writer-&gt;new();</td></tr>
<tr><td class="h"><a name="2968"></a>2968</td><td></td><td></td><td></td><td></td><td class="s">  my $filter = Some::SAX::Filter-&gt;new(Handler =&gt; $writer);</td></tr>
<tr><td class="h"><a name="2969"></a>2969</td><td></td><td></td><td></td><td></td><td class="s">  my $simple = XML::Simple-&gt;new(Handler =&gt; $filter);</td></tr>
<tr><td class="h"><a name="2970"></a>2970</td><td></td><td></td><td></td><td></td><td class="s">  $simple-&gt;XMLout($ref);</td></tr>
<tr><td class="h"><a name="2971"></a>2971</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2972"></a>2972</td><td></td><td></td><td></td><td></td><td class="s">You can also put B&lt;XML::Simple&gt; at the opposite end of the pipeline to take</td></tr>
<tr><td class="h"><a name="2973"></a>2973</td><td></td><td></td><td></td><td></td><td class="s">advantage of the simple 'tree' data structure once the relevant data has been</td></tr>
<tr><td class="h"><a name="2974"></a>2974</td><td></td><td></td><td></td><td></td><td class="s">isolated through filtering:</td></tr>
<tr><td class="h"><a name="2975"></a>2975</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2976"></a>2976</td><td></td><td></td><td></td><td></td><td class="s">  use XML::SAX;</td></tr>
<tr><td class="h"><a name="2977"></a>2977</td><td></td><td></td><td></td><td></td><td class="s">  use Some::SAX::Filter;</td></tr>
<tr><td class="h"><a name="2978"></a>2978</td><td></td><td></td><td></td><td></td><td class="s">  use XML::Simple;</td></tr>
<tr><td class="h"><a name="2979"></a>2979</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2980"></a>2980</td><td></td><td></td><td></td><td></td><td class="s">  my $simple = XML::Simple-&gt;new(ForceArray =&gt; 1, KeyAttr =&gt; ['partnum']);</td></tr>
<tr><td class="h"><a name="2981"></a>2981</td><td></td><td></td><td></td><td></td><td class="s">  my $filter = Some::SAX::Filter-&gt;new(Handler =&gt; $simple);</td></tr>
<tr><td class="h"><a name="2982"></a>2982</td><td></td><td></td><td></td><td></td><td class="s">  my $parser = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $filter);</td></tr>
<tr><td class="h"><a name="2983"></a>2983</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2984"></a>2984</td><td></td><td></td><td></td><td></td><td class="s">  my $ref = $parser-&gt;parse_uri('some_huge_file.xml');</td></tr>
<tr><td class="h"><a name="2985"></a>2985</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2986"></a>2986</td><td></td><td></td><td></td><td></td><td class="s">  print $ref-&gt;{part}-&gt;{'555-1234'};</td></tr>
<tr><td class="h"><a name="2987"></a>2987</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2988"></a>2988</td><td></td><td></td><td></td><td></td><td class="s">You can build a filter by using an XML::Simple object as a handler and setting</td></tr>
<tr><td class="h"><a name="2989"></a>2989</td><td></td><td></td><td></td><td></td><td class="s">its DataHandler option to point to a routine which takes the resulting tree,</td></tr>
<tr><td class="h"><a name="2990"></a>2990</td><td></td><td></td><td></td><td></td><td class="s">modifies it and sends it off as SAX events to a downstream handler:</td></tr>
<tr><td class="h"><a name="2991"></a>2991</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2992"></a>2992</td><td></td><td></td><td></td><td></td><td class="s">  my $writer = XML::SAX::Writer-&gt;new();</td></tr>
<tr><td class="h"><a name="2993"></a>2993</td><td></td><td></td><td></td><td></td><td class="s">  my $filter = XML::Simple-&gt;new(</td></tr>
<tr><td class="h"><a name="2994"></a>2994</td><td></td><td></td><td></td><td></td><td class="s">                 DataHandler =&gt; sub {</td></tr>
<tr><td class="h"><a name="2995"></a>2995</td><td></td><td></td><td></td><td></td><td class="s">                                  my $simple = shift;</td></tr>
<tr><td class="h"><a name="2996"></a>2996</td><td></td><td></td><td></td><td></td><td class="s">                                  my $data = shift;</td></tr>
<tr><td class="h"><a name="2997"></a>2997</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="2998"></a>2998</td><td></td><td></td><td></td><td></td><td class="s">                                  # Modify $data here</td></tr>
<tr><td class="h"><a name="2999"></a>2999</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3000"></a>3000</td><td></td><td></td><td></td><td></td><td class="s">                                  $simple-&gt;XMLout($data, Handler =&gt; $writer);</td></tr>
<tr><td class="h"><a name="3001"></a>3001</td><td></td><td></td><td></td><td></td><td class="s">                                }</td></tr>
<tr><td class="h"><a name="3002"></a>3002</td><td></td><td></td><td></td><td></td><td class="s">               );</td></tr>
<tr><td class="h"><a name="3003"></a>3003</td><td></td><td></td><td></td><td></td><td class="s">  my $parser = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $filter);</td></tr>
<tr><td class="h"><a name="3004"></a>3004</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3005"></a>3005</td><td></td><td></td><td></td><td></td><td class="s">  $parser-&gt;parse_uri($filename);</td></tr>
<tr><td class="h"><a name="3006"></a>3006</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3007"></a>3007</td><td></td><td></td><td></td><td></td><td class="s">I&lt;Note: In this last example, the 'Handler' option was specified in the call to</td></tr>
<tr><td class="h"><a name="3008"></a>3008</td><td></td><td></td><td></td><td></td><td class="s">C&lt;XMLout()&gt; but it could also have been specified in the constructor&gt;.</td></tr>
<tr><td class="h"><a name="3009"></a>3009</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3010"></a>3010</td><td></td><td></td><td></td><td></td><td class="s">=head1 ENVIRONMENT</td></tr>
<tr><td class="h"><a name="3011"></a>3011</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3012"></a>3012</td><td></td><td></td><td></td><td></td><td class="s">If you don't care which parser module B&lt;XML::Simple&gt; uses then skip this</td></tr>
<tr><td class="h"><a name="3013"></a>3013</td><td></td><td></td><td></td><td></td><td class="s">section entirely (it looks more complicated than it really is).</td></tr>
<tr><td class="h"><a name="3014"></a>3014</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3015"></a>3015</td><td></td><td></td><td></td><td></td><td class="s">B&lt;XML::Simple&gt; will default to using a B&lt;SAX&gt; parser if one is available or</td></tr>
<tr><td class="h"><a name="3016"></a>3016</td><td></td><td></td><td></td><td></td><td class="s">B&lt;XML::Parser&gt; if SAX is not available.</td></tr>
<tr><td class="h"><a name="3017"></a>3017</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3018"></a>3018</td><td></td><td></td><td></td><td></td><td class="s">You can dictate which parser module is used by setting either the environment</td></tr>
<tr><td class="h"><a name="3019"></a>3019</td><td></td><td></td><td></td><td></td><td class="s">variable 'XML_SIMPLE_PREFERRED_PARSER' or the package variable</td></tr>
<tr><td class="h"><a name="3020"></a>3020</td><td></td><td></td><td></td><td></td><td class="s">$XML::Simple::PREFERRED_PARSER to contain the module name.  The following rules</td></tr>
<tr><td class="h"><a name="3021"></a>3021</td><td></td><td></td><td></td><td></td><td class="s">are used:</td></tr>
<tr><td class="h"><a name="3022"></a>3022</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3023"></a>3023</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="3024"></a>3024</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3025"></a>3025</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="3026"></a>3026</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3027"></a>3027</td><td></td><td></td><td></td><td></td><td class="s">The package variable takes precedence over the environment variable if both are defined.  To force B&lt;XML::Simple&gt; to ignore the environment settings and use</td></tr>
<tr><td class="h"><a name="3028"></a>3028</td><td></td><td></td><td></td><td></td><td class="s">its default rules, you can set the package variable to an empty string.</td></tr>
<tr><td class="h"><a name="3029"></a>3029</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3030"></a>3030</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="3031"></a>3031</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3032"></a>3032</td><td></td><td></td><td></td><td></td><td class="s">If the 'preferred parser' is set to the string 'XML::Parser', then</td></tr>
<tr><td class="h"><a name="3033"></a>3033</td><td></td><td></td><td></td><td></td><td class="s">L&lt;XML::Parser&gt; will be used (or C&lt;XMLin()&gt; will die if L&lt;XML::Parser&gt; is not</td></tr>
<tr><td class="h"><a name="3034"></a>3034</td><td></td><td></td><td></td><td></td><td class="s">installed).</td></tr>
<tr><td class="h"><a name="3035"></a>3035</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3036"></a>3036</td><td></td><td></td><td></td><td></td><td class="s">=item * </td></tr>
<tr><td class="h"><a name="3037"></a>3037</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3038"></a>3038</td><td></td><td></td><td></td><td></td><td class="s">If the 'preferred parser' is set to some other value, then it is assumed to be</td></tr>
<tr><td class="h"><a name="3039"></a>3039</td><td></td><td></td><td></td><td></td><td class="s">the name of a SAX parser module and is passed to L&lt;XML::SAX::ParserFactory.&gt;</td></tr>
<tr><td class="h"><a name="3040"></a>3040</td><td></td><td></td><td></td><td></td><td class="s">If L&lt;XML::SAX&gt; is not installed, or the requested parser module is not</td></tr>
<tr><td class="h"><a name="3041"></a>3041</td><td></td><td></td><td></td><td></td><td class="s">installed, then C&lt;XMLin()&gt; will die.</td></tr>
<tr><td class="h"><a name="3042"></a>3042</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3043"></a>3043</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="3044"></a>3044</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3045"></a>3045</td><td></td><td></td><td></td><td></td><td class="s">If the 'preferred parser' is not defined at all (the normal default</td></tr>
<tr><td class="h"><a name="3046"></a>3046</td><td></td><td></td><td></td><td></td><td class="s">state), an attempt will be made to load L&lt;XML::SAX&gt;.  If L&lt;XML::SAX&gt; is</td></tr>
<tr><td class="h"><a name="3047"></a>3047</td><td></td><td></td><td></td><td></td><td class="s">installed, then a parser module will be selected according to</td></tr>
<tr><td class="h"><a name="3048"></a>3048</td><td></td><td></td><td></td><td></td><td class="s">L&lt;XML::SAX::ParserFactory&gt;'s normal rules (which typically means the last SAX</td></tr>
<tr><td class="h"><a name="3049"></a>3049</td><td></td><td></td><td></td><td></td><td class="s">parser installed).</td></tr>
<tr><td class="h"><a name="3050"></a>3050</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3051"></a>3051</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="3052"></a>3052</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3053"></a>3053</td><td></td><td></td><td></td><td></td><td class="s">if the 'preferred parser' is not defined and B&lt;XML::SAX&gt; is not</td></tr>
<tr><td class="h"><a name="3054"></a>3054</td><td></td><td></td><td></td><td></td><td class="s">installed, then B&lt;XML::Parser&gt; will be used.  C&lt;XMLin()&gt; will die if</td></tr>
<tr><td class="h"><a name="3055"></a>3055</td><td></td><td></td><td></td><td></td><td class="s">L&lt;XML::Parser&gt; is not installed.</td></tr>
<tr><td class="h"><a name="3056"></a>3056</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3057"></a>3057</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="3058"></a>3058</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3059"></a>3059</td><td></td><td></td><td></td><td></td><td class="s">Note: The B&lt;XML::SAX&gt; distribution includes an XML parser written entirely in</td></tr>
<tr><td class="h"><a name="3060"></a>3060</td><td></td><td></td><td></td><td></td><td class="s">Perl.  It is very portable but it is not very fast.  You should consider</td></tr>
<tr><td class="h"><a name="3061"></a>3061</td><td></td><td></td><td></td><td></td><td class="s">installing L&lt;XML::LibXML&gt; or L&lt;XML::SAX::Expat&gt; if they are available for your</td></tr>
<tr><td class="h"><a name="3062"></a>3062</td><td></td><td></td><td></td><td></td><td class="s">platform.</td></tr>
<tr><td class="h"><a name="3063"></a>3063</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3064"></a>3064</td><td></td><td></td><td></td><td></td><td class="s">=head1 ERROR HANDLING</td></tr>
<tr><td class="h"><a name="3065"></a>3065</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3066"></a>3066</td><td></td><td></td><td></td><td></td><td class="s">The XML standard is very clear on the issue of non-compliant documents.  An</td></tr>
<tr><td class="h"><a name="3067"></a>3067</td><td></td><td></td><td></td><td></td><td class="s">error in parsing any single element (for example a missing end tag) must cause</td></tr>
<tr><td class="h"><a name="3068"></a>3068</td><td></td><td></td><td></td><td></td><td class="s">the whole document to be rejected.  B&lt;XML::Simple&gt; will die with an appropriate</td></tr>
<tr><td class="h"><a name="3069"></a>3069</td><td></td><td></td><td></td><td></td><td class="s">message if it encounters a parsing error.</td></tr>
<tr><td class="h"><a name="3070"></a>3070</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3071"></a>3071</td><td></td><td></td><td></td><td></td><td class="s">If dying is not appropriate for your application, you should arrange to call</td></tr>
<tr><td class="h"><a name="3072"></a>3072</td><td></td><td></td><td></td><td></td><td class="s">C&lt;XMLin()&gt; in an eval block and look for errors in $@.  eg:</td></tr>
<tr><td class="h"><a name="3073"></a>3073</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3074"></a>3074</td><td></td><td></td><td></td><td></td><td class="s">    my $config = eval { XMLin() };</td></tr>
<tr><td class="h"><a name="3075"></a>3075</td><td></td><td></td><td></td><td></td><td class="s">    PopUpMessage($@) if($@);</td></tr>
<tr><td class="h"><a name="3076"></a>3076</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3077"></a>3077</td><td></td><td></td><td></td><td></td><td class="s">Note, there is a common misconception that use of B&lt;eval&gt; will significantly</td></tr>
<tr><td class="h"><a name="3078"></a>3078</td><td></td><td></td><td></td><td></td><td class="s">slow down a script.  While that may be true when the code being eval'd is in a</td></tr>
<tr><td class="h"><a name="3079"></a>3079</td><td></td><td></td><td></td><td></td><td class="s">string, it is not true of code like the sample above.</td></tr>
<tr><td class="h"><a name="3080"></a>3080</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3081"></a>3081</td><td></td><td></td><td></td><td></td><td class="s">=head1 EXAMPLES</td></tr>
<tr><td class="h"><a name="3082"></a>3082</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3083"></a>3083</td><td></td><td></td><td></td><td></td><td class="s">When C&lt;XMLin()&gt; reads the following very simple piece of XML:</td></tr>
<tr><td class="h"><a name="3084"></a>3084</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3085"></a>3085</td><td></td><td></td><td></td><td></td><td class="s">    &lt;opt username=&quot;testuser&quot; password=&quot;frodo&quot;&gt;&lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="3086"></a>3086</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3087"></a>3087</td><td></td><td></td><td></td><td></td><td class="s">it returns the following data structure:</td></tr>
<tr><td class="h"><a name="3088"></a>3088</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3089"></a>3089</td><td></td><td></td><td></td><td></td><td class="s">    {</td></tr>
<tr><td class="h"><a name="3090"></a>3090</td><td></td><td></td><td></td><td></td><td class="s">      'username' =&gt; 'testuser',</td></tr>
<tr><td class="h"><a name="3091"></a>3091</td><td></td><td></td><td></td><td></td><td class="s">      'password' =&gt; 'frodo'</td></tr>
<tr><td class="h"><a name="3092"></a>3092</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="3093"></a>3093</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3094"></a>3094</td><td></td><td></td><td></td><td></td><td class="s">The identical result could have been produced with this alternative XML:</td></tr>
<tr><td class="h"><a name="3095"></a>3095</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3096"></a>3096</td><td></td><td></td><td></td><td></td><td class="s">    &lt;opt username=&quot;testuser&quot; password=&quot;frodo&quot; /&gt;</td></tr>
<tr><td class="h"><a name="3097"></a>3097</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3098"></a>3098</td><td></td><td></td><td></td><td></td><td class="s">Or this (although see 'ForceArray' option for variations):</td></tr>
<tr><td class="h"><a name="3099"></a>3099</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3100"></a>3100</td><td></td><td></td><td></td><td></td><td class="s">    &lt;opt&gt;</td></tr>
<tr><td class="h"><a name="3101"></a>3101</td><td></td><td></td><td></td><td></td><td class="s">      &lt;username&gt;testuser&lt;/username&gt;</td></tr>
<tr><td class="h"><a name="3102"></a>3102</td><td></td><td></td><td></td><td></td><td class="s">      &lt;password&gt;frodo&lt;/password&gt;</td></tr>
<tr><td class="h"><a name="3103"></a>3103</td><td></td><td></td><td></td><td></td><td class="s">    &lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="3104"></a>3104</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3105"></a>3105</td><td></td><td></td><td></td><td></td><td class="s">Repeated nested elements are represented as anonymous arrays:</td></tr>
<tr><td class="h"><a name="3106"></a>3106</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3107"></a>3107</td><td></td><td></td><td></td><td></td><td class="s">    &lt;opt&gt;</td></tr>
<tr><td class="h"><a name="3108"></a>3108</td><td></td><td></td><td></td><td></td><td class="s">      &lt;person firstname=&quot;Joe&quot; lastname=&quot;Smith&quot;&gt;</td></tr>
<tr><td class="h"><a name="3109"></a>3109</td><td></td><td></td><td></td><td></td><td class="s">        &lt;email&gt;joe@smith.com&lt;/email&gt;</td></tr>
<tr><td class="h"><a name="3110"></a>3110</td><td></td><td></td><td></td><td></td><td class="s">        &lt;email&gt;jsmith@yahoo.com&lt;/email&gt;</td></tr>
<tr><td class="h"><a name="3111"></a>3111</td><td></td><td></td><td></td><td></td><td class="s">      &lt;/person&gt;</td></tr>
<tr><td class="h"><a name="3112"></a>3112</td><td></td><td></td><td></td><td></td><td class="s">      &lt;person firstname=&quot;Bob&quot; lastname=&quot;Smith&quot;&gt;</td></tr>
<tr><td class="h"><a name="3113"></a>3113</td><td></td><td></td><td></td><td></td><td class="s">        &lt;email&gt;bob@smith.com&lt;/email&gt;</td></tr>
<tr><td class="h"><a name="3114"></a>3114</td><td></td><td></td><td></td><td></td><td class="s">      &lt;/person&gt;</td></tr>
<tr><td class="h"><a name="3115"></a>3115</td><td></td><td></td><td></td><td></td><td class="s">    &lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="3116"></a>3116</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3117"></a>3117</td><td></td><td></td><td></td><td></td><td class="s">    {</td></tr>
<tr><td class="h"><a name="3118"></a>3118</td><td></td><td></td><td></td><td></td><td class="s">      'person' =&gt; [</td></tr>
<tr><td class="h"><a name="3119"></a>3119</td><td></td><td></td><td></td><td></td><td class="s">                    {</td></tr>
<tr><td class="h"><a name="3120"></a>3120</td><td></td><td></td><td></td><td></td><td class="s">                      'email' =&gt; [</td></tr>
<tr><td class="h"><a name="3121"></a>3121</td><td></td><td></td><td></td><td></td><td class="s">                                   'joe@smith.com',</td></tr>
<tr><td class="h"><a name="3122"></a>3122</td><td></td><td></td><td></td><td></td><td class="s">                                   'jsmith@yahoo.com'</td></tr>
<tr><td class="h"><a name="3123"></a>3123</td><td></td><td></td><td></td><td></td><td class="s">                                 ],</td></tr>
<tr><td class="h"><a name="3124"></a>3124</td><td></td><td></td><td></td><td></td><td class="s">                      'firstname' =&gt; 'Joe',</td></tr>
<tr><td class="h"><a name="3125"></a>3125</td><td></td><td></td><td></td><td></td><td class="s">                      'lastname' =&gt; 'Smith'</td></tr>
<tr><td class="h"><a name="3126"></a>3126</td><td></td><td></td><td></td><td></td><td class="s">                    },</td></tr>
<tr><td class="h"><a name="3127"></a>3127</td><td></td><td></td><td></td><td></td><td class="s">                    {</td></tr>
<tr><td class="h"><a name="3128"></a>3128</td><td></td><td></td><td></td><td></td><td class="s">                      'email' =&gt; 'bob@smith.com',</td></tr>
<tr><td class="h"><a name="3129"></a>3129</td><td></td><td></td><td></td><td></td><td class="s">                      'firstname' =&gt; 'Bob',</td></tr>
<tr><td class="h"><a name="3130"></a>3130</td><td></td><td></td><td></td><td></td><td class="s">                      'lastname' =&gt; 'Smith'</td></tr>
<tr><td class="h"><a name="3131"></a>3131</td><td></td><td></td><td></td><td></td><td class="s">                    }</td></tr>
<tr><td class="h"><a name="3132"></a>3132</td><td></td><td></td><td></td><td></td><td class="s">                  ]</td></tr>
<tr><td class="h"><a name="3133"></a>3133</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="3134"></a>3134</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3135"></a>3135</td><td></td><td></td><td></td><td></td><td class="s">Nested elements with a recognised key attribute are transformed (folded) from</td></tr>
<tr><td class="h"><a name="3136"></a>3136</td><td></td><td></td><td></td><td></td><td class="s">an array into a hash keyed on the value of that attribute (see the C&lt;KeyAttr&gt;</td></tr>
<tr><td class="h"><a name="3137"></a>3137</td><td></td><td></td><td></td><td></td><td class="s">option):</td></tr>
<tr><td class="h"><a name="3138"></a>3138</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3139"></a>3139</td><td></td><td></td><td></td><td></td><td class="s">    &lt;opt&gt;</td></tr>
<tr><td class="h"><a name="3140"></a>3140</td><td></td><td></td><td></td><td></td><td class="s">      &lt;person key=&quot;jsmith&quot; firstname=&quot;Joe&quot; lastname=&quot;Smith&quot; /&gt;</td></tr>
<tr><td class="h"><a name="3141"></a>3141</td><td></td><td></td><td></td><td></td><td class="s">      &lt;person key=&quot;tsmith&quot; firstname=&quot;Tom&quot; lastname=&quot;Smith&quot; /&gt;</td></tr>
<tr><td class="h"><a name="3142"></a>3142</td><td></td><td></td><td></td><td></td><td class="s">      &lt;person key=&quot;jbloggs&quot; firstname=&quot;Joe&quot; lastname=&quot;Bloggs&quot; /&gt;</td></tr>
<tr><td class="h"><a name="3143"></a>3143</td><td></td><td></td><td></td><td></td><td class="s">    &lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="3144"></a>3144</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3145"></a>3145</td><td></td><td></td><td></td><td></td><td class="s">    {</td></tr>
<tr><td class="h"><a name="3146"></a>3146</td><td></td><td></td><td></td><td></td><td class="s">      'person' =&gt; {</td></tr>
<tr><td class="h"><a name="3147"></a>3147</td><td></td><td></td><td></td><td></td><td class="s">                    'jbloggs' =&gt; {</td></tr>
<tr><td class="h"><a name="3148"></a>3148</td><td></td><td></td><td></td><td></td><td class="s">                                   'firstname' =&gt; 'Joe',</td></tr>
<tr><td class="h"><a name="3149"></a>3149</td><td></td><td></td><td></td><td></td><td class="s">                                   'lastname' =&gt; 'Bloggs'</td></tr>
<tr><td class="h"><a name="3150"></a>3150</td><td></td><td></td><td></td><td></td><td class="s">                                 },</td></tr>
<tr><td class="h"><a name="3151"></a>3151</td><td></td><td></td><td></td><td></td><td class="s">                    'tsmith' =&gt; {</td></tr>
<tr><td class="h"><a name="3152"></a>3152</td><td></td><td></td><td></td><td></td><td class="s">                                  'firstname' =&gt; 'Tom',</td></tr>
<tr><td class="h"><a name="3153"></a>3153</td><td></td><td></td><td></td><td></td><td class="s">                                  'lastname' =&gt; 'Smith'</td></tr>
<tr><td class="h"><a name="3154"></a>3154</td><td></td><td></td><td></td><td></td><td class="s">                                },</td></tr>
<tr><td class="h"><a name="3155"></a>3155</td><td></td><td></td><td></td><td></td><td class="s">                    'jsmith' =&gt; {</td></tr>
<tr><td class="h"><a name="3156"></a>3156</td><td></td><td></td><td></td><td></td><td class="s">                                  'firstname' =&gt; 'Joe',</td></tr>
<tr><td class="h"><a name="3157"></a>3157</td><td></td><td></td><td></td><td></td><td class="s">                                  'lastname' =&gt; 'Smith'</td></tr>
<tr><td class="h"><a name="3158"></a>3158</td><td></td><td></td><td></td><td></td><td class="s">                                }</td></tr>
<tr><td class="h"><a name="3159"></a>3159</td><td></td><td></td><td></td><td></td><td class="s">                  }</td></tr>
<tr><td class="h"><a name="3160"></a>3160</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="3161"></a>3161</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3162"></a>3162</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3163"></a>3163</td><td></td><td></td><td></td><td></td><td class="s">The &lt;anon&gt; tag can be used to form anonymous arrays:</td></tr>
<tr><td class="h"><a name="3164"></a>3164</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3165"></a>3165</td><td></td><td></td><td></td><td></td><td class="s">    &lt;opt&gt;</td></tr>
<tr><td class="h"><a name="3166"></a>3166</td><td></td><td></td><td></td><td></td><td class="s">      &lt;head&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;anon&gt;Col 3&lt;/anon&gt;&lt;/head&gt;</td></tr>
<tr><td class="h"><a name="3167"></a>3167</td><td></td><td></td><td></td><td></td><td class="s">      &lt;data&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;anon&gt;R1C3&lt;/anon&gt;&lt;/data&gt;</td></tr>
<tr><td class="h"><a name="3168"></a>3168</td><td></td><td></td><td></td><td></td><td class="s">      &lt;data&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;anon&gt;R2C3&lt;/anon&gt;&lt;/data&gt;</td></tr>
<tr><td class="h"><a name="3169"></a>3169</td><td></td><td></td><td></td><td></td><td class="s">      &lt;data&gt;&lt;anon&gt;R3C1&lt;/anon&gt;&lt;anon&gt;R3C2&lt;/anon&gt;&lt;anon&gt;R3C3&lt;/anon&gt;&lt;/data&gt;</td></tr>
<tr><td class="h"><a name="3170"></a>3170</td><td></td><td></td><td></td><td></td><td class="s">    &lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="3171"></a>3171</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3172"></a>3172</td><td></td><td></td><td></td><td></td><td class="s">    {</td></tr>
<tr><td class="h"><a name="3173"></a>3173</td><td></td><td></td><td></td><td></td><td class="s">      'head' =&gt; [</td></tr>
<tr><td class="h"><a name="3174"></a>3174</td><td></td><td></td><td></td><td></td><td class="s">                  [ 'Col 1', 'Col 2', 'Col 3' ]</td></tr>
<tr><td class="h"><a name="3175"></a>3175</td><td></td><td></td><td></td><td></td><td class="s">                ],</td></tr>
<tr><td class="h"><a name="3176"></a>3176</td><td></td><td></td><td></td><td></td><td class="s">      'data' =&gt; [</td></tr>
<tr><td class="h"><a name="3177"></a>3177</td><td></td><td></td><td></td><td></td><td class="s">                  [ 'R1C1', 'R1C2', 'R1C3' ],</td></tr>
<tr><td class="h"><a name="3178"></a>3178</td><td></td><td></td><td></td><td></td><td class="s">                  [ 'R2C1', 'R2C2', 'R2C3' ],</td></tr>
<tr><td class="h"><a name="3179"></a>3179</td><td></td><td></td><td></td><td></td><td class="s">                  [ 'R3C1', 'R3C2', 'R3C3' ]</td></tr>
<tr><td class="h"><a name="3180"></a>3180</td><td></td><td></td><td></td><td></td><td class="s">                ]</td></tr>
<tr><td class="h"><a name="3181"></a>3181</td><td></td><td></td><td></td><td></td><td class="s">    }</td></tr>
<tr><td class="h"><a name="3182"></a>3182</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3183"></a>3183</td><td></td><td></td><td></td><td></td><td class="s">Anonymous arrays can be nested to arbirtrary levels and as a special case, if</td></tr>
<tr><td class="h"><a name="3184"></a>3184</td><td></td><td></td><td></td><td></td><td class="s">the surrounding tags for an XML document contain only an anonymous array the</td></tr>
<tr><td class="h"><a name="3185"></a>3185</td><td></td><td></td><td></td><td></td><td class="s">arrayref will be returned directly rather than the usual hashref:</td></tr>
<tr><td class="h"><a name="3186"></a>3186</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3187"></a>3187</td><td></td><td></td><td></td><td></td><td class="s">    &lt;opt&gt;</td></tr>
<tr><td class="h"><a name="3188"></a>3188</td><td></td><td></td><td></td><td></td><td class="s">      &lt;anon&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;/anon&gt;</td></tr>
<tr><td class="h"><a name="3189"></a>3189</td><td></td><td></td><td></td><td></td><td class="s">      &lt;anon&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;/anon&gt;</td></tr>
<tr><td class="h"><a name="3190"></a>3190</td><td></td><td></td><td></td><td></td><td class="s">      &lt;anon&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;/anon&gt;</td></tr>
<tr><td class="h"><a name="3191"></a>3191</td><td></td><td></td><td></td><td></td><td class="s">    &lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="3192"></a>3192</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3193"></a>3193</td><td></td><td></td><td></td><td></td><td class="s">    [</td></tr>
<tr><td class="h"><a name="3194"></a>3194</td><td></td><td></td><td></td><td></td><td class="s">      [ 'Col 1', 'Col 2' ],</td></tr>
<tr><td class="h"><a name="3195"></a>3195</td><td></td><td></td><td></td><td></td><td class="s">      [ 'R1C1', 'R1C2' ],</td></tr>
<tr><td class="h"><a name="3196"></a>3196</td><td></td><td></td><td></td><td></td><td class="s">      [ 'R2C1', 'R2C2' ]</td></tr>
<tr><td class="h"><a name="3197"></a>3197</td><td></td><td></td><td></td><td></td><td class="s">    ]</td></tr>
<tr><td class="h"><a name="3198"></a>3198</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3199"></a>3199</td><td></td><td></td><td></td><td></td><td class="s">Elements which only contain text content will simply be represented as a</td></tr>
<tr><td class="h"><a name="3200"></a>3200</td><td></td><td></td><td></td><td></td><td class="s">scalar.  Where an element has both attributes and text content, the element</td></tr>
<tr><td class="h"><a name="3201"></a>3201</td><td></td><td></td><td></td><td></td><td class="s">will be represented as a hashref with the text content in the 'content' key</td></tr>
<tr><td class="h"><a name="3202"></a>3202</td><td></td><td></td><td></td><td></td><td class="s">(see the C&lt;ContentKey&gt; option):</td></tr>
<tr><td class="h"><a name="3203"></a>3203</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3204"></a>3204</td><td></td><td></td><td></td><td></td><td class="s">  &lt;opt&gt;</td></tr>
<tr><td class="h"><a name="3205"></a>3205</td><td></td><td></td><td></td><td></td><td class="s">    &lt;one&gt;first&lt;/one&gt;</td></tr>
<tr><td class="h"><a name="3206"></a>3206</td><td></td><td></td><td></td><td></td><td class="s">    &lt;two attr=&quot;value&quot;&gt;second&lt;/two&gt;</td></tr>
<tr><td class="h"><a name="3207"></a>3207</td><td></td><td></td><td></td><td></td><td class="s">  &lt;/opt&gt;</td></tr>
<tr><td class="h"><a name="3208"></a>3208</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3209"></a>3209</td><td></td><td></td><td></td><td></td><td class="s">  {</td></tr>
<tr><td class="h"><a name="3210"></a>3210</td><td></td><td></td><td></td><td></td><td class="s">    'one' =&gt; 'first',</td></tr>
<tr><td class="h"><a name="3211"></a>3211</td><td></td><td></td><td></td><td></td><td class="s">    'two' =&gt; { 'attr' =&gt; 'value', 'content' =&gt; 'second' }</td></tr>
<tr><td class="h"><a name="3212"></a>3212</td><td></td><td></td><td></td><td></td><td class="s">  }</td></tr>
<tr><td class="h"><a name="3213"></a>3213</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3214"></a>3214</td><td></td><td></td><td></td><td></td><td class="s">Mixed content (elements which contain both text content and nested elements)</td></tr>
<tr><td class="h"><a name="3215"></a>3215</td><td></td><td></td><td></td><td></td><td class="s">will be not be represented in a useful way - element order and significant</td></tr>
<tr><td class="h"><a name="3216"></a>3216</td><td></td><td></td><td></td><td></td><td class="s">whitespace will be lost.  If you need to work with mixed content, then</td></tr>
<tr><td class="h"><a name="3217"></a>3217</td><td></td><td></td><td></td><td></td><td class="s">XML::Simple is not the right tool for your job - check out the next section.</td></tr>
<tr><td class="h"><a name="3218"></a>3218</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3219"></a>3219</td><td></td><td></td><td></td><td></td><td class="s">=head1 WHERE TO FROM HERE?</td></tr>
<tr><td class="h"><a name="3220"></a>3220</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3221"></a>3221</td><td></td><td></td><td></td><td></td><td class="s">B&lt;XML::Simple&gt; is able to present a simple API because it makes some</td></tr>
<tr><td class="h"><a name="3222"></a>3222</td><td></td><td></td><td></td><td></td><td class="s">assumptions on your behalf.  These include:</td></tr>
<tr><td class="h"><a name="3223"></a>3223</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3224"></a>3224</td><td></td><td></td><td></td><td></td><td class="s">=over 4</td></tr>
<tr><td class="h"><a name="3225"></a>3225</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3226"></a>3226</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="3227"></a>3227</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3228"></a>3228</td><td></td><td></td><td></td><td></td><td class="s">You're not interested in text content consisting only of whitespace</td></tr>
<tr><td class="h"><a name="3229"></a>3229</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3230"></a>3230</td><td></td><td></td><td></td><td></td><td class="s">=item * </td></tr>
<tr><td class="h"><a name="3231"></a>3231</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3232"></a>3232</td><td></td><td></td><td></td><td></td><td class="s">You don't mind that when things get slurped into a hash the order is lost</td></tr>
<tr><td class="h"><a name="3233"></a>3233</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3234"></a>3234</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="3235"></a>3235</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3236"></a>3236</td><td></td><td></td><td></td><td></td><td class="s">You don't want fine-grained control of the formatting of generated XML</td></tr>
<tr><td class="h"><a name="3237"></a>3237</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3238"></a>3238</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="3239"></a>3239</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3240"></a>3240</td><td></td><td></td><td></td><td></td><td class="s">You would never use a hash key that was not a legal XML element name</td></tr>
<tr><td class="h"><a name="3241"></a>3241</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3242"></a>3242</td><td></td><td></td><td></td><td></td><td class="s">=item *</td></tr>
<tr><td class="h"><a name="3243"></a>3243</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3244"></a>3244</td><td></td><td></td><td></td><td></td><td class="s">You don't need help converting between different encodings</td></tr>
<tr><td class="h"><a name="3245"></a>3245</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3246"></a>3246</td><td></td><td></td><td></td><td></td><td class="s">=back</td></tr>
<tr><td class="h"><a name="3247"></a>3247</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3248"></a>3248</td><td></td><td></td><td></td><td></td><td class="s">In a serious XML project, you'll probably outgrow these assumptions fairly</td></tr>
<tr><td class="h"><a name="3249"></a>3249</td><td></td><td></td><td></td><td></td><td class="s">quickly.  This section of the document used to offer some advice on chosing a</td></tr>
<tr><td class="h"><a name="3250"></a>3250</td><td></td><td></td><td></td><td></td><td class="s">more powerful option.  That advice has now grown into the 'Perl-XML FAQ'</td></tr>
<tr><td class="h"><a name="3251"></a>3251</td><td></td><td></td><td></td><td></td><td class="s">document which you can find at: L&lt;http://perl-xml.sourceforge.net/faq/&gt;</td></tr>
<tr><td class="h"><a name="3252"></a>3252</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3253"></a>3253</td><td></td><td></td><td></td><td></td><td class="s">The advice in the FAQ boils down to a quick explanation of tree versus</td></tr>
<tr><td class="h"><a name="3254"></a>3254</td><td></td><td></td><td></td><td></td><td class="s">event based parsers and then recommends:</td></tr>
<tr><td class="h"><a name="3255"></a>3255</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3256"></a>3256</td><td></td><td></td><td></td><td></td><td class="s">For event based parsing, use SAX (do not set out to write any new code for </td></tr>
<tr><td class="h"><a name="3257"></a>3257</td><td></td><td></td><td></td><td></td><td class="s">XML::Parser's handler API - it is obselete).</td></tr>
<tr><td class="h"><a name="3258"></a>3258</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3259"></a>3259</td><td></td><td></td><td></td><td></td><td class="s">For tree-based parsing, you could choose between the 'Perlish' approach of</td></tr>
<tr><td class="h"><a name="3260"></a>3260</td><td></td><td></td><td></td><td></td><td class="s">L&lt;XML::Twig&gt; and more standards based DOM implementations - preferably one with</td></tr>
<tr><td class="h"><a name="3261"></a>3261</td><td></td><td></td><td></td><td></td><td class="s">XPath support.</td></tr>
<tr><td class="h"><a name="3262"></a>3262</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3263"></a>3263</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3264"></a>3264</td><td></td><td></td><td></td><td></td><td class="s">=head1 SEE ALSO</td></tr>
<tr><td class="h"><a name="3265"></a>3265</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3266"></a>3266</td><td></td><td></td><td></td><td></td><td class="s">B&lt;XML::Simple&gt; requires either L&lt;XML::Parser&gt; or L&lt;XML::SAX&gt;.</td></tr>
<tr><td class="h"><a name="3267"></a>3267</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3268"></a>3268</td><td></td><td></td><td></td><td></td><td class="s">To generate documents with namespaces, L&lt;XML::NamespaceSupport&gt; is required.</td></tr>
<tr><td class="h"><a name="3269"></a>3269</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3270"></a>3270</td><td></td><td></td><td></td><td></td><td class="s">The optional caching functions require L&lt;Storable&gt;.</td></tr>
<tr><td class="h"><a name="3271"></a>3271</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3272"></a>3272</td><td></td><td></td><td></td><td></td><td class="s">Answers to Frequently Asked Questions about XML::Simple are bundled with this</td></tr>
<tr><td class="h"><a name="3273"></a>3273</td><td></td><td></td><td></td><td></td><td class="s">distribution as: L&lt;XML::Simple::FAQ&gt;</td></tr>
<tr><td class="h"><a name="3274"></a>3274</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3275"></a>3275</td><td></td><td></td><td></td><td></td><td class="s">=head1 COPYRIGHT </td></tr>
<tr><td class="h"><a name="3276"></a>3276</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3277"></a>3277</td><td></td><td></td><td></td><td></td><td class="s">Copyright 1999-2004 Grant McLean E&lt;lt&gt;grantm@cpan.orgE&lt;gt&gt;</td></tr>
<tr><td class="h"><a name="3278"></a>3278</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3279"></a>3279</td><td></td><td></td><td></td><td></td><td class="s">This library is free software; you can redistribute it and/or modify it</td></tr>
<tr><td class="h"><a name="3280"></a>3280</td><td></td><td></td><td></td><td></td><td class="s">under the same terms as Perl itself. </td></tr>
<tr><td class="h"><a name="3281"></a>3281</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3282"></a>3282</td><td></td><td></td><td></td><td></td><td class="s">=cut</td></tr>
<tr><td class="h"><a name="3283"></a>3283</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="3284"></a>3284</td><td></td><td></td><td></td><td></td><td class="s"></td></tr>
<tr><td class="h"><a name="XML__Simple__CORE_match"></a></td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 6.32ms (99&micro;s+6.22) within XML::Simple::CORE:match which was called 33 times, avg 191&micro;s/call:
# 28 times (85&micro;s+6.22ms) by XML::Simple::collapse at <a href="XML-Simple-pm-block.html#1023">line 1023 of XML/Simple.pm</a>, avg 225&micro;s/call
#  3 times (12&micro;s+0s) by XML::Simple::XMLin at <a href="XML-Simple-pm-block.html#171">line 171 of XML/Simple.pm</a>, avg 4&micro;s/call
#     once (1&micro;s+0s) by XML::Simple::import at <a href="XML-Simple-pm-block.html#95">line 95 of XML/Simple.pm</a>
#     once (300ns+0s) by XML::Simple::import at <a href="XML-Simple-pm-block.html#99">line 99 of XML/Simple.pm</a></div></div>sub XML::Simple::CORE:match; # xsub<br />        </td></tr>
<tr><td class="h"><a name="XML__Simple__CORE_subst"></a></td><td></td><td></td><td></td><td></td><td class="s"><div class="calls"><div class="calls_in"># spent 3&micro;s within XML::Simple::CORE:subst which was called 3 times, avg 1&micro;s/call:
# 3 times (3&micro;s+0s) by XML::Simple::handle_options at <a href="XML-Simple-pm-block.html#701">line 701 of XML/Simple.pm</a>, avg 1&micro;s/call</div></div>sub XML::Simple::CORE:subst; # xsub<br />        </td></tr>
</tbody></table></div>
        
            <script type="text/javascript"> $(document).ready(function() { 

        $("#subs_table").tablesorter({
            sortList: [[3,1]],
            headers: {
                3: { sorter: 'fmt_time' },
                4: { sorter: 'fmt_time' }
            }
        });
    
 } ); </script>
        
        <div class="footer">Report produced by the
        <a href="http://search.cpan.org/dist/Devel-NYTProf/">NYTProf 3.11</a>
        Perl profiler, developed by
        <a href="http://www.linkedin.com/in/timbunce">Tim Bunce</a> and
        <a href="http://code.nytimes.com">Adam Kaplan</a>.
        </div>
        <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
    </body></html>